
BQ27427_Sensor.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .intvec       000000c0  10040000  10040000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002a7c  100400c0  100400c0  000010c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         00000004  10042b3c  10042b3c  00003b3c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .fini         00000004  10042b40  10042b40  00003b40  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00000000  10042b44  10042b44  00004128  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         0000000c  2000011c  10042b44  0000411c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ram_preamble 0000002c  20000004  20000004  00005004  2**2
                  ALLOC
  7 .bss.blueRAM  00000000  200000c0  200000c0  00000000  2**0
                  ALLOC
  8 .bss          0000005c  200000c0  200000c0  00005004  2**2
                  ALLOC
  9 .noinit       00000000  20000128  10042b50  00000000  2**0
                  ALLOC
 10 .ota_region_end 00000000  10042b50  10042b50  00004128  2**0
                  CONTENTS
 11 .heap         00000000  20000128  20000128  00004128  2**0
                  CONTENTS
 12 .stack        00000c00  2000f400  2000f400  00004400  2**0
                  ALLOC
 13 .rom_info     00000000  10000000  10000000  00004128  2**0
                  CONTENTS
 14 .ARM.attributes 00000028  00000000  00000000  00004128  2**0
                  CONTENTS, READONLY
 15 .debug_info   000087b1  00000000  00000000  00004150  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 00001a60  00000000  00000000  0000c901  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_aranges 000009b0  00000000  00000000  0000e368  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_rnglists 0000074f  00000000  00000000  0000ed18  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_macro  00017bc4  00000000  00000000  0000f467  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_line   0000b021  00000000  00000000  0002702b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_str    0009d69b  00000000  00000000  0003204c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .comment      00000043  00000000  00000000  000cf6e7  2**0
                  CONTENTS, READONLY
 23 .debug_frame  00002200  00000000  00000000  000cf72c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 24 .debug_line_str 00000067  00000000  00000000  000d192c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

100400c0 <__udivsi3>:
100400c0:	2200      	movs	r2, #0
100400c2:	0843      	lsrs	r3, r0, #1
100400c4:	428b      	cmp	r3, r1
100400c6:	d374      	bcc.n	100401b2 <__udivsi3+0xf2>
100400c8:	0903      	lsrs	r3, r0, #4
100400ca:	428b      	cmp	r3, r1
100400cc:	d35f      	bcc.n	1004018e <__udivsi3+0xce>
100400ce:	0a03      	lsrs	r3, r0, #8
100400d0:	428b      	cmp	r3, r1
100400d2:	d344      	bcc.n	1004015e <__udivsi3+0x9e>
100400d4:	0b03      	lsrs	r3, r0, #12
100400d6:	428b      	cmp	r3, r1
100400d8:	d328      	bcc.n	1004012c <__udivsi3+0x6c>
100400da:	0c03      	lsrs	r3, r0, #16
100400dc:	428b      	cmp	r3, r1
100400de:	d30d      	bcc.n	100400fc <__udivsi3+0x3c>
100400e0:	22ff      	movs	r2, #255	@ 0xff
100400e2:	0209      	lsls	r1, r1, #8
100400e4:	ba12      	rev	r2, r2
100400e6:	0c03      	lsrs	r3, r0, #16
100400e8:	428b      	cmp	r3, r1
100400ea:	d302      	bcc.n	100400f2 <__udivsi3+0x32>
100400ec:	1212      	asrs	r2, r2, #8
100400ee:	0209      	lsls	r1, r1, #8
100400f0:	d065      	beq.n	100401be <__udivsi3+0xfe>
100400f2:	0b03      	lsrs	r3, r0, #12
100400f4:	428b      	cmp	r3, r1
100400f6:	d319      	bcc.n	1004012c <__udivsi3+0x6c>
100400f8:	e000      	b.n	100400fc <__udivsi3+0x3c>
100400fa:	0a09      	lsrs	r1, r1, #8
100400fc:	0bc3      	lsrs	r3, r0, #15
100400fe:	428b      	cmp	r3, r1
10040100:	d301      	bcc.n	10040106 <__udivsi3+0x46>
10040102:	03cb      	lsls	r3, r1, #15
10040104:	1ac0      	subs	r0, r0, r3
10040106:	4152      	adcs	r2, r2
10040108:	0b83      	lsrs	r3, r0, #14
1004010a:	428b      	cmp	r3, r1
1004010c:	d301      	bcc.n	10040112 <__udivsi3+0x52>
1004010e:	038b      	lsls	r3, r1, #14
10040110:	1ac0      	subs	r0, r0, r3
10040112:	4152      	adcs	r2, r2
10040114:	0b43      	lsrs	r3, r0, #13
10040116:	428b      	cmp	r3, r1
10040118:	d301      	bcc.n	1004011e <__udivsi3+0x5e>
1004011a:	034b      	lsls	r3, r1, #13
1004011c:	1ac0      	subs	r0, r0, r3
1004011e:	4152      	adcs	r2, r2
10040120:	0b03      	lsrs	r3, r0, #12
10040122:	428b      	cmp	r3, r1
10040124:	d301      	bcc.n	1004012a <__udivsi3+0x6a>
10040126:	030b      	lsls	r3, r1, #12
10040128:	1ac0      	subs	r0, r0, r3
1004012a:	4152      	adcs	r2, r2
1004012c:	0ac3      	lsrs	r3, r0, #11
1004012e:	428b      	cmp	r3, r1
10040130:	d301      	bcc.n	10040136 <__udivsi3+0x76>
10040132:	02cb      	lsls	r3, r1, #11
10040134:	1ac0      	subs	r0, r0, r3
10040136:	4152      	adcs	r2, r2
10040138:	0a83      	lsrs	r3, r0, #10
1004013a:	428b      	cmp	r3, r1
1004013c:	d301      	bcc.n	10040142 <__udivsi3+0x82>
1004013e:	028b      	lsls	r3, r1, #10
10040140:	1ac0      	subs	r0, r0, r3
10040142:	4152      	adcs	r2, r2
10040144:	0a43      	lsrs	r3, r0, #9
10040146:	428b      	cmp	r3, r1
10040148:	d301      	bcc.n	1004014e <__udivsi3+0x8e>
1004014a:	024b      	lsls	r3, r1, #9
1004014c:	1ac0      	subs	r0, r0, r3
1004014e:	4152      	adcs	r2, r2
10040150:	0a03      	lsrs	r3, r0, #8
10040152:	428b      	cmp	r3, r1
10040154:	d301      	bcc.n	1004015a <__udivsi3+0x9a>
10040156:	020b      	lsls	r3, r1, #8
10040158:	1ac0      	subs	r0, r0, r3
1004015a:	4152      	adcs	r2, r2
1004015c:	d2cd      	bcs.n	100400fa <__udivsi3+0x3a>
1004015e:	09c3      	lsrs	r3, r0, #7
10040160:	428b      	cmp	r3, r1
10040162:	d301      	bcc.n	10040168 <__udivsi3+0xa8>
10040164:	01cb      	lsls	r3, r1, #7
10040166:	1ac0      	subs	r0, r0, r3
10040168:	4152      	adcs	r2, r2
1004016a:	0983      	lsrs	r3, r0, #6
1004016c:	428b      	cmp	r3, r1
1004016e:	d301      	bcc.n	10040174 <__udivsi3+0xb4>
10040170:	018b      	lsls	r3, r1, #6
10040172:	1ac0      	subs	r0, r0, r3
10040174:	4152      	adcs	r2, r2
10040176:	0943      	lsrs	r3, r0, #5
10040178:	428b      	cmp	r3, r1
1004017a:	d301      	bcc.n	10040180 <__udivsi3+0xc0>
1004017c:	014b      	lsls	r3, r1, #5
1004017e:	1ac0      	subs	r0, r0, r3
10040180:	4152      	adcs	r2, r2
10040182:	0903      	lsrs	r3, r0, #4
10040184:	428b      	cmp	r3, r1
10040186:	d301      	bcc.n	1004018c <__udivsi3+0xcc>
10040188:	010b      	lsls	r3, r1, #4
1004018a:	1ac0      	subs	r0, r0, r3
1004018c:	4152      	adcs	r2, r2
1004018e:	08c3      	lsrs	r3, r0, #3
10040190:	428b      	cmp	r3, r1
10040192:	d301      	bcc.n	10040198 <__udivsi3+0xd8>
10040194:	00cb      	lsls	r3, r1, #3
10040196:	1ac0      	subs	r0, r0, r3
10040198:	4152      	adcs	r2, r2
1004019a:	0883      	lsrs	r3, r0, #2
1004019c:	428b      	cmp	r3, r1
1004019e:	d301      	bcc.n	100401a4 <__udivsi3+0xe4>
100401a0:	008b      	lsls	r3, r1, #2
100401a2:	1ac0      	subs	r0, r0, r3
100401a4:	4152      	adcs	r2, r2
100401a6:	0843      	lsrs	r3, r0, #1
100401a8:	428b      	cmp	r3, r1
100401aa:	d301      	bcc.n	100401b0 <__udivsi3+0xf0>
100401ac:	004b      	lsls	r3, r1, #1
100401ae:	1ac0      	subs	r0, r0, r3
100401b0:	4152      	adcs	r2, r2
100401b2:	1a41      	subs	r1, r0, r1
100401b4:	d200      	bcs.n	100401b8 <__udivsi3+0xf8>
100401b6:	4601      	mov	r1, r0
100401b8:	4152      	adcs	r2, r2
100401ba:	4610      	mov	r0, r2
100401bc:	4770      	bx	lr
100401be:	e7ff      	b.n	100401c0 <__udivsi3+0x100>
100401c0:	b501      	push	{r0, lr}
100401c2:	2000      	movs	r0, #0
100401c4:	f000 f8f0 	bl	100403a8 <__aeabi_idiv0>
100401c8:	bd02      	pop	{r1, pc}
100401ca:	46c0      	nop			@ (mov r8, r8)

100401cc <__aeabi_uidivmod>:
100401cc:	2900      	cmp	r1, #0
100401ce:	d0f7      	beq.n	100401c0 <__udivsi3+0x100>
100401d0:	e776      	b.n	100400c0 <__udivsi3>
100401d2:	4770      	bx	lr

100401d4 <__divsi3>:
100401d4:	4603      	mov	r3, r0
100401d6:	430b      	orrs	r3, r1
100401d8:	d47f      	bmi.n	100402da <__divsi3+0x106>
100401da:	2200      	movs	r2, #0
100401dc:	0843      	lsrs	r3, r0, #1
100401de:	428b      	cmp	r3, r1
100401e0:	d374      	bcc.n	100402cc <__divsi3+0xf8>
100401e2:	0903      	lsrs	r3, r0, #4
100401e4:	428b      	cmp	r3, r1
100401e6:	d35f      	bcc.n	100402a8 <__divsi3+0xd4>
100401e8:	0a03      	lsrs	r3, r0, #8
100401ea:	428b      	cmp	r3, r1
100401ec:	d344      	bcc.n	10040278 <__divsi3+0xa4>
100401ee:	0b03      	lsrs	r3, r0, #12
100401f0:	428b      	cmp	r3, r1
100401f2:	d328      	bcc.n	10040246 <__divsi3+0x72>
100401f4:	0c03      	lsrs	r3, r0, #16
100401f6:	428b      	cmp	r3, r1
100401f8:	d30d      	bcc.n	10040216 <__divsi3+0x42>
100401fa:	22ff      	movs	r2, #255	@ 0xff
100401fc:	0209      	lsls	r1, r1, #8
100401fe:	ba12      	rev	r2, r2
10040200:	0c03      	lsrs	r3, r0, #16
10040202:	428b      	cmp	r3, r1
10040204:	d302      	bcc.n	1004020c <__divsi3+0x38>
10040206:	1212      	asrs	r2, r2, #8
10040208:	0209      	lsls	r1, r1, #8
1004020a:	d065      	beq.n	100402d8 <__divsi3+0x104>
1004020c:	0b03      	lsrs	r3, r0, #12
1004020e:	428b      	cmp	r3, r1
10040210:	d319      	bcc.n	10040246 <__divsi3+0x72>
10040212:	e000      	b.n	10040216 <__divsi3+0x42>
10040214:	0a09      	lsrs	r1, r1, #8
10040216:	0bc3      	lsrs	r3, r0, #15
10040218:	428b      	cmp	r3, r1
1004021a:	d301      	bcc.n	10040220 <__divsi3+0x4c>
1004021c:	03cb      	lsls	r3, r1, #15
1004021e:	1ac0      	subs	r0, r0, r3
10040220:	4152      	adcs	r2, r2
10040222:	0b83      	lsrs	r3, r0, #14
10040224:	428b      	cmp	r3, r1
10040226:	d301      	bcc.n	1004022c <__divsi3+0x58>
10040228:	038b      	lsls	r3, r1, #14
1004022a:	1ac0      	subs	r0, r0, r3
1004022c:	4152      	adcs	r2, r2
1004022e:	0b43      	lsrs	r3, r0, #13
10040230:	428b      	cmp	r3, r1
10040232:	d301      	bcc.n	10040238 <__divsi3+0x64>
10040234:	034b      	lsls	r3, r1, #13
10040236:	1ac0      	subs	r0, r0, r3
10040238:	4152      	adcs	r2, r2
1004023a:	0b03      	lsrs	r3, r0, #12
1004023c:	428b      	cmp	r3, r1
1004023e:	d301      	bcc.n	10040244 <__divsi3+0x70>
10040240:	030b      	lsls	r3, r1, #12
10040242:	1ac0      	subs	r0, r0, r3
10040244:	4152      	adcs	r2, r2
10040246:	0ac3      	lsrs	r3, r0, #11
10040248:	428b      	cmp	r3, r1
1004024a:	d301      	bcc.n	10040250 <__divsi3+0x7c>
1004024c:	02cb      	lsls	r3, r1, #11
1004024e:	1ac0      	subs	r0, r0, r3
10040250:	4152      	adcs	r2, r2
10040252:	0a83      	lsrs	r3, r0, #10
10040254:	428b      	cmp	r3, r1
10040256:	d301      	bcc.n	1004025c <__divsi3+0x88>
10040258:	028b      	lsls	r3, r1, #10
1004025a:	1ac0      	subs	r0, r0, r3
1004025c:	4152      	adcs	r2, r2
1004025e:	0a43      	lsrs	r3, r0, #9
10040260:	428b      	cmp	r3, r1
10040262:	d301      	bcc.n	10040268 <__divsi3+0x94>
10040264:	024b      	lsls	r3, r1, #9
10040266:	1ac0      	subs	r0, r0, r3
10040268:	4152      	adcs	r2, r2
1004026a:	0a03      	lsrs	r3, r0, #8
1004026c:	428b      	cmp	r3, r1
1004026e:	d301      	bcc.n	10040274 <__divsi3+0xa0>
10040270:	020b      	lsls	r3, r1, #8
10040272:	1ac0      	subs	r0, r0, r3
10040274:	4152      	adcs	r2, r2
10040276:	d2cd      	bcs.n	10040214 <__divsi3+0x40>
10040278:	09c3      	lsrs	r3, r0, #7
1004027a:	428b      	cmp	r3, r1
1004027c:	d301      	bcc.n	10040282 <__divsi3+0xae>
1004027e:	01cb      	lsls	r3, r1, #7
10040280:	1ac0      	subs	r0, r0, r3
10040282:	4152      	adcs	r2, r2
10040284:	0983      	lsrs	r3, r0, #6
10040286:	428b      	cmp	r3, r1
10040288:	d301      	bcc.n	1004028e <__divsi3+0xba>
1004028a:	018b      	lsls	r3, r1, #6
1004028c:	1ac0      	subs	r0, r0, r3
1004028e:	4152      	adcs	r2, r2
10040290:	0943      	lsrs	r3, r0, #5
10040292:	428b      	cmp	r3, r1
10040294:	d301      	bcc.n	1004029a <__divsi3+0xc6>
10040296:	014b      	lsls	r3, r1, #5
10040298:	1ac0      	subs	r0, r0, r3
1004029a:	4152      	adcs	r2, r2
1004029c:	0903      	lsrs	r3, r0, #4
1004029e:	428b      	cmp	r3, r1
100402a0:	d301      	bcc.n	100402a6 <__divsi3+0xd2>
100402a2:	010b      	lsls	r3, r1, #4
100402a4:	1ac0      	subs	r0, r0, r3
100402a6:	4152      	adcs	r2, r2
100402a8:	08c3      	lsrs	r3, r0, #3
100402aa:	428b      	cmp	r3, r1
100402ac:	d301      	bcc.n	100402b2 <__divsi3+0xde>
100402ae:	00cb      	lsls	r3, r1, #3
100402b0:	1ac0      	subs	r0, r0, r3
100402b2:	4152      	adcs	r2, r2
100402b4:	0883      	lsrs	r3, r0, #2
100402b6:	428b      	cmp	r3, r1
100402b8:	d301      	bcc.n	100402be <__divsi3+0xea>
100402ba:	008b      	lsls	r3, r1, #2
100402bc:	1ac0      	subs	r0, r0, r3
100402be:	4152      	adcs	r2, r2
100402c0:	0843      	lsrs	r3, r0, #1
100402c2:	428b      	cmp	r3, r1
100402c4:	d301      	bcc.n	100402ca <__divsi3+0xf6>
100402c6:	004b      	lsls	r3, r1, #1
100402c8:	1ac0      	subs	r0, r0, r3
100402ca:	4152      	adcs	r2, r2
100402cc:	1a41      	subs	r1, r0, r1
100402ce:	d200      	bcs.n	100402d2 <__divsi3+0xfe>
100402d0:	4601      	mov	r1, r0
100402d2:	4152      	adcs	r2, r2
100402d4:	4610      	mov	r0, r2
100402d6:	4770      	bx	lr
100402d8:	e05d      	b.n	10040396 <__divsi3+0x1c2>
100402da:	0fca      	lsrs	r2, r1, #31
100402dc:	d000      	beq.n	100402e0 <__divsi3+0x10c>
100402de:	4249      	negs	r1, r1
100402e0:	1003      	asrs	r3, r0, #32
100402e2:	d300      	bcc.n	100402e6 <__divsi3+0x112>
100402e4:	4240      	negs	r0, r0
100402e6:	4053      	eors	r3, r2
100402e8:	2200      	movs	r2, #0
100402ea:	469c      	mov	ip, r3
100402ec:	0903      	lsrs	r3, r0, #4
100402ee:	428b      	cmp	r3, r1
100402f0:	d32d      	bcc.n	1004034e <__divsi3+0x17a>
100402f2:	0a03      	lsrs	r3, r0, #8
100402f4:	428b      	cmp	r3, r1
100402f6:	d312      	bcc.n	1004031e <__divsi3+0x14a>
100402f8:	22fc      	movs	r2, #252	@ 0xfc
100402fa:	0189      	lsls	r1, r1, #6
100402fc:	ba12      	rev	r2, r2
100402fe:	0a03      	lsrs	r3, r0, #8
10040300:	428b      	cmp	r3, r1
10040302:	d30c      	bcc.n	1004031e <__divsi3+0x14a>
10040304:	0189      	lsls	r1, r1, #6
10040306:	1192      	asrs	r2, r2, #6
10040308:	428b      	cmp	r3, r1
1004030a:	d308      	bcc.n	1004031e <__divsi3+0x14a>
1004030c:	0189      	lsls	r1, r1, #6
1004030e:	1192      	asrs	r2, r2, #6
10040310:	428b      	cmp	r3, r1
10040312:	d304      	bcc.n	1004031e <__divsi3+0x14a>
10040314:	0189      	lsls	r1, r1, #6
10040316:	d03a      	beq.n	1004038e <__divsi3+0x1ba>
10040318:	1192      	asrs	r2, r2, #6
1004031a:	e000      	b.n	1004031e <__divsi3+0x14a>
1004031c:	0989      	lsrs	r1, r1, #6
1004031e:	09c3      	lsrs	r3, r0, #7
10040320:	428b      	cmp	r3, r1
10040322:	d301      	bcc.n	10040328 <__divsi3+0x154>
10040324:	01cb      	lsls	r3, r1, #7
10040326:	1ac0      	subs	r0, r0, r3
10040328:	4152      	adcs	r2, r2
1004032a:	0983      	lsrs	r3, r0, #6
1004032c:	428b      	cmp	r3, r1
1004032e:	d301      	bcc.n	10040334 <__divsi3+0x160>
10040330:	018b      	lsls	r3, r1, #6
10040332:	1ac0      	subs	r0, r0, r3
10040334:	4152      	adcs	r2, r2
10040336:	0943      	lsrs	r3, r0, #5
10040338:	428b      	cmp	r3, r1
1004033a:	d301      	bcc.n	10040340 <__divsi3+0x16c>
1004033c:	014b      	lsls	r3, r1, #5
1004033e:	1ac0      	subs	r0, r0, r3
10040340:	4152      	adcs	r2, r2
10040342:	0903      	lsrs	r3, r0, #4
10040344:	428b      	cmp	r3, r1
10040346:	d301      	bcc.n	1004034c <__divsi3+0x178>
10040348:	010b      	lsls	r3, r1, #4
1004034a:	1ac0      	subs	r0, r0, r3
1004034c:	4152      	adcs	r2, r2
1004034e:	08c3      	lsrs	r3, r0, #3
10040350:	428b      	cmp	r3, r1
10040352:	d301      	bcc.n	10040358 <__divsi3+0x184>
10040354:	00cb      	lsls	r3, r1, #3
10040356:	1ac0      	subs	r0, r0, r3
10040358:	4152      	adcs	r2, r2
1004035a:	0883      	lsrs	r3, r0, #2
1004035c:	428b      	cmp	r3, r1
1004035e:	d301      	bcc.n	10040364 <__divsi3+0x190>
10040360:	008b      	lsls	r3, r1, #2
10040362:	1ac0      	subs	r0, r0, r3
10040364:	4152      	adcs	r2, r2
10040366:	d2d9      	bcs.n	1004031c <__divsi3+0x148>
10040368:	0843      	lsrs	r3, r0, #1
1004036a:	428b      	cmp	r3, r1
1004036c:	d301      	bcc.n	10040372 <__divsi3+0x19e>
1004036e:	004b      	lsls	r3, r1, #1
10040370:	1ac0      	subs	r0, r0, r3
10040372:	4152      	adcs	r2, r2
10040374:	1a41      	subs	r1, r0, r1
10040376:	d200      	bcs.n	1004037a <__divsi3+0x1a6>
10040378:	4601      	mov	r1, r0
1004037a:	4663      	mov	r3, ip
1004037c:	4152      	adcs	r2, r2
1004037e:	105b      	asrs	r3, r3, #1
10040380:	4610      	mov	r0, r2
10040382:	d301      	bcc.n	10040388 <__divsi3+0x1b4>
10040384:	4240      	negs	r0, r0
10040386:	2b00      	cmp	r3, #0
10040388:	d500      	bpl.n	1004038c <__divsi3+0x1b8>
1004038a:	4249      	negs	r1, r1
1004038c:	4770      	bx	lr
1004038e:	4663      	mov	r3, ip
10040390:	105b      	asrs	r3, r3, #1
10040392:	d300      	bcc.n	10040396 <__divsi3+0x1c2>
10040394:	4240      	negs	r0, r0
10040396:	b501      	push	{r0, lr}
10040398:	2000      	movs	r0, #0
1004039a:	f000 f805 	bl	100403a8 <__aeabi_idiv0>
1004039e:	bd02      	pop	{r1, pc}

100403a0 <__aeabi_idivmod>:
100403a0:	2900      	cmp	r1, #0
100403a2:	d0f8      	beq.n	10040396 <__divsi3+0x1c2>
100403a4:	e716      	b.n	100401d4 <__divsi3>
100403a6:	4770      	bx	lr

100403a8 <__aeabi_idiv0>:
100403a8:	4770      	bx	lr
100403aa:	46c0      	nop			@ (mov r8, r8)

100403ac <BQ27427_Read>:
 * @brief Lê um registrador do sensor.
 * @param sensor_BQ27427 Ponteiro para a estrutura do sensor.
 * @param command Endereço do registrador a ser lido.
 * @return Valor de 16 bits do registrador lido. Retorna 0xFFFF em caso de erro.
 */
static uint16_t BQ27427_Read(BQ27427_t *sensor_BQ27427, uint16_t command) {
100403ac:	b580      	push	{r7, lr}
100403ae:	b088      	sub	sp, #32
100403b0:	af04      	add	r7, sp, #16
100403b2:	6078      	str	r0, [r7, #4]
100403b4:	000a      	movs	r2, r1
100403b6:	1cbb      	adds	r3, r7, #2
100403b8:	801a      	strh	r2, [r3, #0]
    uint8_t aRxBuffer[2];
    uint16_t resultado;

    if (HAL_I2C_Mem_Read(sensor_BQ27427->hi2c, BQ27427_I2C_ADDR, command, I2C_MEMADD_SIZE_8BIT, aRxBuffer, 2, BQ27427_MAX_DELAY) != HAL_OK) {
100403ba:	687b      	ldr	r3, [r7, #4]
100403bc:	6818      	ldr	r0, [r3, #0]
100403be:	1cbb      	adds	r3, r7, #2
100403c0:	881a      	ldrh	r2, [r3, #0]
100403c2:	2396      	movs	r3, #150	@ 0x96
100403c4:	009b      	lsls	r3, r3, #2
100403c6:	9302      	str	r3, [sp, #8]
100403c8:	2302      	movs	r3, #2
100403ca:	9301      	str	r3, [sp, #4]
100403cc:	230c      	movs	r3, #12
100403ce:	18fb      	adds	r3, r7, r3
100403d0:	9300      	str	r3, [sp, #0]
100403d2:	2301      	movs	r3, #1
100403d4:	21aa      	movs	r1, #170	@ 0xaa
100403d6:	f001 fcdb 	bl	10041d90 <HAL_I2C_Mem_Read>
100403da:	1e03      	subs	r3, r0, #0
100403dc:	d005      	beq.n	100403ea <BQ27427_Read+0x3e>
        resultado = 0xFFFF; // Retorna um valor inválido em caso de falha
100403de:	230e      	movs	r3, #14
100403e0:	18fb      	adds	r3, r7, r3
100403e2:	2201      	movs	r2, #1
100403e4:	4252      	negs	r2, r2
100403e6:	801a      	strh	r2, [r3, #0]
100403e8:	e00d      	b.n	10040406 <BQ27427_Read+0x5a>
    } else {
        resultado = (aRxBuffer[1] << 8) | aRxBuffer[0]; // Concatena os bytes em um valor de 16 bits
100403ea:	210c      	movs	r1, #12
100403ec:	187b      	adds	r3, r7, r1
100403ee:	785b      	ldrb	r3, [r3, #1]
100403f0:	b21b      	sxth	r3, r3
100403f2:	021b      	lsls	r3, r3, #8
100403f4:	b21a      	sxth	r2, r3
100403f6:	187b      	adds	r3, r7, r1
100403f8:	781b      	ldrb	r3, [r3, #0]
100403fa:	b21b      	sxth	r3, r3
100403fc:	4313      	orrs	r3, r2
100403fe:	b21a      	sxth	r2, r3
10040400:	230e      	movs	r3, #14
10040402:	18fb      	adds	r3, r7, r3
10040404:	801a      	strh	r2, [r3, #0]
    }
    return resultado;
10040406:	230e      	movs	r3, #14
10040408:	18fb      	adds	r3, r7, r3
1004040a:	881b      	ldrh	r3, [r3, #0]
}
1004040c:	0018      	movs	r0, r3
1004040e:	46bd      	mov	sp, r7
10040410:	b004      	add	sp, #16
10040412:	bd80      	pop	{r7, pc}

10040414 <BQ27427_Write>:
 * @param   aTxBuffer       Ponteiro para o buffer de dados a serem enviados.
 * @param   len             Quantidade de bytes a escrever.
 * @return  Código de status HAL (HAL_OK em sucesso).
 */

static HAL_StatusTypeDef BQ27427_Write(BQ27427_t *sensor_BQ27427, uint8_t command, const uint8_t *aTxBuffer, uint8_t len){
10040414:	b5b0      	push	{r4, r5, r7, lr}
10040416:	b088      	sub	sp, #32
10040418:	af04      	add	r7, sp, #16
1004041a:	60f8      	str	r0, [r7, #12]
1004041c:	0008      	movs	r0, r1
1004041e:	607a      	str	r2, [r7, #4]
10040420:	0019      	movs	r1, r3
10040422:	240b      	movs	r4, #11
10040424:	193b      	adds	r3, r7, r4
10040426:	1c02      	adds	r2, r0, #0
10040428:	701a      	strb	r2, [r3, #0]
1004042a:	250a      	movs	r5, #10
1004042c:	197b      	adds	r3, r7, r5
1004042e:	1c0a      	adds	r2, r1, #0
10040430:	701a      	strb	r2, [r3, #0]
    return HAL_I2C_Mem_Write(sensor_BQ27427->hi2c, BQ27427_I2C_ADDR, command, I2C_MEMADD_SIZE_8BIT, (uint8_t*)aTxBuffer, len, BQ27427_MAX_DELAY);
10040432:	68fb      	ldr	r3, [r7, #12]
10040434:	6818      	ldr	r0, [r3, #0]
10040436:	193b      	adds	r3, r7, r4
10040438:	781b      	ldrb	r3, [r3, #0]
1004043a:	b299      	uxth	r1, r3
1004043c:	197b      	adds	r3, r7, r5
1004043e:	781b      	ldrb	r3, [r3, #0]
10040440:	b29b      	uxth	r3, r3
10040442:	2296      	movs	r2, #150	@ 0x96
10040444:	0092      	lsls	r2, r2, #2
10040446:	9202      	str	r2, [sp, #8]
10040448:	9301      	str	r3, [sp, #4]
1004044a:	687b      	ldr	r3, [r7, #4]
1004044c:	9300      	str	r3, [sp, #0]
1004044e:	2301      	movs	r3, #1
10040450:	000a      	movs	r2, r1
10040452:	21aa      	movs	r1, #170	@ 0xaa
10040454:	f001 fb6e 	bl	10041b34 <HAL_I2C_Mem_Write>
10040458:	0003      	movs	r3, r0
}
1004045a:	0018      	movs	r0, r3
1004045c:	46bd      	mov	sp, r7
1004045e:	b004      	add	sp, #16
10040460:	bdb0      	pop	{r4, r5, r7, pc}

10040462 <BQ27427_Init>:
//	}
//
//	return HAL_OK;
//}

void BQ27427_Init(BQ27427_t *sensor_BQ27427, I2C_HandleTypeDef *hi2c) {
10040462:	b580      	push	{r7, lr}
10040464:	b082      	sub	sp, #8
10040466:	af00      	add	r7, sp, #0
10040468:	6078      	str	r0, [r7, #4]
1004046a:	6039      	str	r1, [r7, #0]
    sensor_BQ27427->hi2c = hi2c; // Associa a interface I2C ao sensor
1004046c:	687b      	ldr	r3, [r7, #4]
1004046e:	683a      	ldr	r2, [r7, #0]
10040470:	601a      	str	r2, [r3, #0]
}
10040472:	46c0      	nop			@ (mov r8, r8)
10040474:	46bd      	mov	sp, r7
10040476:	b002      	add	sp, #8
10040478:	bd80      	pop	{r7, pc}
	...

1004047c <BQ27427_ReadVoltage>:

/**
 * @brief Lê a voltagem atual da bateria em mV.
 * @return Voltagem da bateria.
 */
uint16_t BQ27427_ReadVoltage(BQ27427_t *sensor_BQ27427) {
1004047c:	b580      	push	{r7, lr}
1004047e:	b082      	sub	sp, #8
10040480:	af00      	add	r7, sp, #0
10040482:	6078      	str	r0, [r7, #4]
    return BQ27427_Read(sensor_BQ27427, 0x0504);
10040484:	4a05      	ldr	r2, [pc, #20]	@ (1004049c <BQ27427_ReadVoltage+0x20>)
10040486:	687b      	ldr	r3, [r7, #4]
10040488:	0011      	movs	r1, r2
1004048a:	0018      	movs	r0, r3
1004048c:	f7ff ff8e 	bl	100403ac <BQ27427_Read>
10040490:	0003      	movs	r3, r0
}
10040492:	0018      	movs	r0, r3
10040494:	46bd      	mov	sp, r7
10040496:	b002      	add	sp, #8
10040498:	bd80      	pop	{r7, pc}
1004049a:	46c0      	nop			@ (mov r8, r8)
1004049c:	00000504 	.word	0x00000504

100404a0 <BQ27427_ReadFlags>:

/**
 * @brief Lê os flags de status do sensor.
 * @return Flags indicando o estado da bateria.
 */
uint16_t BQ27427_ReadFlags(BQ27427_t *sensor_BQ27427) {
100404a0:	b580      	push	{r7, lr}
100404a2:	b082      	sub	sp, #8
100404a4:	af00      	add	r7, sp, #0
100404a6:	6078      	str	r0, [r7, #4]
    return BQ27427_Read(sensor_BQ27427, 0x0706);
100404a8:	4a05      	ldr	r2, [pc, #20]	@ (100404c0 <BQ27427_ReadFlags+0x20>)
100404aa:	687b      	ldr	r3, [r7, #4]
100404ac:	0011      	movs	r1, r2
100404ae:	0018      	movs	r0, r3
100404b0:	f7ff ff7c 	bl	100403ac <BQ27427_Read>
100404b4:	0003      	movs	r3, r0
}
100404b6:	0018      	movs	r0, r3
100404b8:	46bd      	mov	sp, r7
100404ba:	b002      	add	sp, #8
100404bc:	bd80      	pop	{r7, pc}
100404be:	46c0      	nop			@ (mov r8, r8)
100404c0:	00000706 	.word	0x00000706

100404c4 <BQ27427_ReadNominalAvailableCapacity>:
/**
 * @brief Lê a capacidade nominal disponível da bateria.
 * @param sensor_BQ27427 Ponteiro para a estrutura do sensor BQ27427.
 * @return Capacidade nominal disponível em mAh.
 */
uint16_t BQ27427_ReadNominalAvailableCapacity(BQ27427_t *sensor_BQ27427) {
100404c4:	b580      	push	{r7, lr}
100404c6:	b082      	sub	sp, #8
100404c8:	af00      	add	r7, sp, #0
100404ca:	6078      	str	r0, [r7, #4]
    return BQ27427_Read(sensor_BQ27427, 0x0908);
100404cc:	4a05      	ldr	r2, [pc, #20]	@ (100404e4 <BQ27427_ReadNominalAvailableCapacity+0x20>)
100404ce:	687b      	ldr	r3, [r7, #4]
100404d0:	0011      	movs	r1, r2
100404d2:	0018      	movs	r0, r3
100404d4:	f7ff ff6a 	bl	100403ac <BQ27427_Read>
100404d8:	0003      	movs	r3, r0
}
100404da:	0018      	movs	r0, r3
100404dc:	46bd      	mov	sp, r7
100404de:	b002      	add	sp, #8
100404e0:	bd80      	pop	{r7, pc}
100404e2:	46c0      	nop			@ (mov r8, r8)
100404e4:	00000908 	.word	0x00000908

100404e8 <BQ27427_ReadFullAvailableCapacity>:
/**
 * @brief Lê a capacidade total disponível da bateria.
 * @param sensor_BQ27427 Ponteiro para a estrutura do sensor BQ27427.
 * @return Capacidade total disponível em mAh.
 */
uint16_t BQ27427_ReadFullAvailableCapacity(BQ27427_t *sensor_BQ27427) {
100404e8:	b580      	push	{r7, lr}
100404ea:	b082      	sub	sp, #8
100404ec:	af00      	add	r7, sp, #0
100404ee:	6078      	str	r0, [r7, #4]
    return BQ27427_Read(sensor_BQ27427, 0x0A0B);
100404f0:	4a05      	ldr	r2, [pc, #20]	@ (10040508 <BQ27427_ReadFullAvailableCapacity+0x20>)
100404f2:	687b      	ldr	r3, [r7, #4]
100404f4:	0011      	movs	r1, r2
100404f6:	0018      	movs	r0, r3
100404f8:	f7ff ff58 	bl	100403ac <BQ27427_Read>
100404fc:	0003      	movs	r3, r0
}
100404fe:	0018      	movs	r0, r3
10040500:	46bd      	mov	sp, r7
10040502:	b002      	add	sp, #8
10040504:	bd80      	pop	{r7, pc}
10040506:	46c0      	nop			@ (mov r8, r8)
10040508:	00000a0b 	.word	0x00000a0b

1004050c <BQ27427_ReadRemainingCapacity>:
/**
 * @brief Lê a capacidade restante da bateria.
 * @param sensor_BQ27427 Ponteiro para a estrutura do sensor BQ27427.
 * @return Capacidade restante em mAh.
 */
uint16_t BQ27427_ReadRemainingCapacity(BQ27427_t *sensor_BQ27427) {
1004050c:	b580      	push	{r7, lr}
1004050e:	b082      	sub	sp, #8
10040510:	af00      	add	r7, sp, #0
10040512:	6078      	str	r0, [r7, #4]
    return BQ27427_Read(sensor_BQ27427, 0x0D0C);
10040514:	4a05      	ldr	r2, [pc, #20]	@ (1004052c <BQ27427_ReadRemainingCapacity+0x20>)
10040516:	687b      	ldr	r3, [r7, #4]
10040518:	0011      	movs	r1, r2
1004051a:	0018      	movs	r0, r3
1004051c:	f7ff ff46 	bl	100403ac <BQ27427_Read>
10040520:	0003      	movs	r3, r0
}
10040522:	0018      	movs	r0, r3
10040524:	46bd      	mov	sp, r7
10040526:	b002      	add	sp, #8
10040528:	bd80      	pop	{r7, pc}
1004052a:	46c0      	nop			@ (mov r8, r8)
1004052c:	00000d0c 	.word	0x00000d0c

10040530 <BQ27427_ReadFullChargeCapacity>:
/**
 * @brief Lê a capacidade total de carga da bateria.
 * @param sensor_BQ27427 Ponteiro para a estrutura do sensor BQ27427.
 * @return Capacidade total de carga em mAh.
 */
uint16_t BQ27427_ReadFullChargeCapacity(BQ27427_t *sensor_BQ27427) {
10040530:	b580      	push	{r7, lr}
10040532:	b082      	sub	sp, #8
10040534:	af00      	add	r7, sp, #0
10040536:	6078      	str	r0, [r7, #4]
    return BQ27427_Read(sensor_BQ27427, 0x0E0F);
10040538:	4a05      	ldr	r2, [pc, #20]	@ (10040550 <BQ27427_ReadFullChargeCapacity+0x20>)
1004053a:	687b      	ldr	r3, [r7, #4]
1004053c:	0011      	movs	r1, r2
1004053e:	0018      	movs	r0, r3
10040540:	f7ff ff34 	bl	100403ac <BQ27427_Read>
10040544:	0003      	movs	r3, r0
}
10040546:	0018      	movs	r0, r3
10040548:	46bd      	mov	sp, r7
1004054a:	b002      	add	sp, #8
1004054c:	bd80      	pop	{r7, pc}
1004054e:	46c0      	nop			@ (mov r8, r8)
10040550:	00000e0f 	.word	0x00000e0f

10040554 <BQ27427_ReadAverageCurrent>:
/**
 * @brief Lê a corrente média consumida pela bateria.
 * @param sensor_BQ27427 Ponteiro para a estrutura do sensor BQ27427.
 * @return Corrente média em mA.
 */
uint16_t BQ27427_ReadAverageCurrent(BQ27427_t *sensor_BQ27427) {
10040554:	b580      	push	{r7, lr}
10040556:	b082      	sub	sp, #8
10040558:	af00      	add	r7, sp, #0
1004055a:	6078      	str	r0, [r7, #4]
    return BQ27427_Read(sensor_BQ27427, 0x1110);
1004055c:	4a05      	ldr	r2, [pc, #20]	@ (10040574 <BQ27427_ReadAverageCurrent+0x20>)
1004055e:	687b      	ldr	r3, [r7, #4]
10040560:	0011      	movs	r1, r2
10040562:	0018      	movs	r0, r3
10040564:	f7ff ff22 	bl	100403ac <BQ27427_Read>
10040568:	0003      	movs	r3, r0
}
1004056a:	0018      	movs	r0, r3
1004056c:	46bd      	mov	sp, r7
1004056e:	b002      	add	sp, #8
10040570:	bd80      	pop	{r7, pc}
10040572:	46c0      	nop			@ (mov r8, r8)
10040574:	00001110 	.word	0x00001110

10040578 <BQ27427_ReadStateOfCharge>:
/**
 * @brief Lê o estado de carga da bateria.
 * @param sensor_BQ27427 Ponteiro para a estrutura do sensor BQ27427.
 * @return Estado de carga em porcentagem (%).
 */
uint16_t BQ27427_ReadStateOfCharge(BQ27427_t *sensor_BQ27427) {
10040578:	b580      	push	{r7, lr}
1004057a:	b082      	sub	sp, #8
1004057c:	af00      	add	r7, sp, #0
1004057e:	6078      	str	r0, [r7, #4]
    return BQ27427_Read(sensor_BQ27427, 0x1D1C);
10040580:	4a05      	ldr	r2, [pc, #20]	@ (10040598 <BQ27427_ReadStateOfCharge+0x20>)
10040582:	687b      	ldr	r3, [r7, #4]
10040584:	0011      	movs	r1, r2
10040586:	0018      	movs	r0, r3
10040588:	f7ff ff10 	bl	100403ac <BQ27427_Read>
1004058c:	0003      	movs	r3, r0
}
1004058e:	0018      	movs	r0, r3
10040590:	46bd      	mov	sp, r7
10040592:	b002      	add	sp, #8
10040594:	bd80      	pop	{r7, pc}
10040596:	46c0      	nop			@ (mov r8, r8)
10040598:	00001d1c 	.word	0x00001d1c

1004059c <BQ27427_ReadRemainingCapacityUnfiltered>:
/**
 * @brief Lê a capacidade restante não filtrada da bateria.
 * @param sensor_BQ27427 Ponteiro para a estrutura do sensor BQ27427.
 * @return Capacidade restante não filtrada em mAh.
 */
uint16_t BQ27427_ReadRemainingCapacityUnfiltered(BQ27427_t *sensor_BQ27427) {
1004059c:	b580      	push	{r7, lr}
1004059e:	b082      	sub	sp, #8
100405a0:	af00      	add	r7, sp, #0
100405a2:	6078      	str	r0, [r7, #4]
    return BQ27427_Read(sensor_BQ27427, 0x2928);
100405a4:	4a05      	ldr	r2, [pc, #20]	@ (100405bc <BQ27427_ReadRemainingCapacityUnfiltered+0x20>)
100405a6:	687b      	ldr	r3, [r7, #4]
100405a8:	0011      	movs	r1, r2
100405aa:	0018      	movs	r0, r3
100405ac:	f7ff fefe 	bl	100403ac <BQ27427_Read>
100405b0:	0003      	movs	r3, r0
}
100405b2:	0018      	movs	r0, r3
100405b4:	46bd      	mov	sp, r7
100405b6:	b002      	add	sp, #8
100405b8:	bd80      	pop	{r7, pc}
100405ba:	46c0      	nop			@ (mov r8, r8)
100405bc:	00002928 	.word	0x00002928

100405c0 <BQ27427_selectDataBlock>:
 * @param   blockClass      Identificador da classe de bloco (DataBlockClass).
 * @param   offset          Offset dentro do bloco (DataBlockOffset).
 * @return  Código de status HAL (HAL_OK em sucesso).
 */

static HAL_StatusTypeDef BQ27427_selectDataBlock(BQ27427_t *sensor_BQ27427, uint8_t blockClass, uint8_t offset){
100405c0:	b5b0      	push	{r4, r5, r7, lr}
100405c2:	b084      	sub	sp, #16
100405c4:	af00      	add	r7, sp, #0
100405c6:	6078      	str	r0, [r7, #4]
100405c8:	0008      	movs	r0, r1
100405ca:	0011      	movs	r1, r2
100405cc:	1cfb      	adds	r3, r7, #3
100405ce:	1c02      	adds	r2, r0, #0
100405d0:	701a      	strb	r2, [r3, #0]
100405d2:	1cbb      	adds	r3, r7, #2
100405d4:	1c0a      	adds	r2, r1, #0
100405d6:	701a      	strb	r2, [r3, #0]
    HAL_StatusTypeDef ret;
    ret = BQ27427_Write(sensor_BQ27427, BQ27427_REG_BLOCKDATA_CTRL, (uint8_t[]){0x00}, 1);
100405d8:	210c      	movs	r1, #12
100405da:	187b      	adds	r3, r7, r1
100405dc:	2200      	movs	r2, #0
100405de:	701a      	strb	r2, [r3, #0]
100405e0:	250f      	movs	r5, #15
100405e2:	197c      	adds	r4, r7, r5
100405e4:	187a      	adds	r2, r7, r1
100405e6:	6878      	ldr	r0, [r7, #4]
100405e8:	2301      	movs	r3, #1
100405ea:	2161      	movs	r1, #97	@ 0x61
100405ec:	f7ff ff12 	bl	10040414 <BQ27427_Write>
100405f0:	0003      	movs	r3, r0
100405f2:	7023      	strb	r3, [r4, #0]
    if (ret != HAL_OK) return ret;
100405f4:	197b      	adds	r3, r7, r5
100405f6:	781b      	ldrb	r3, [r3, #0]
100405f8:	2b00      	cmp	r3, #0
100405fa:	d002      	beq.n	10040602 <BQ27427_selectDataBlock+0x42>
100405fc:	197b      	adds	r3, r7, r5
100405fe:	781b      	ldrb	r3, [r3, #0]
10040600:	e017      	b.n	10040632 <BQ27427_selectDataBlock+0x72>
    ret = BQ27427_Write(sensor_BQ27427, BQ27427_REG_DATACLASS, &blockClass, 1);
10040602:	250f      	movs	r5, #15
10040604:	197c      	adds	r4, r7, r5
10040606:	1cfa      	adds	r2, r7, #3
10040608:	6878      	ldr	r0, [r7, #4]
1004060a:	2301      	movs	r3, #1
1004060c:	213e      	movs	r1, #62	@ 0x3e
1004060e:	f7ff ff01 	bl	10040414 <BQ27427_Write>
10040612:	0003      	movs	r3, r0
10040614:	7023      	strb	r3, [r4, #0]
    if (ret != HAL_OK) return ret;
10040616:	197b      	adds	r3, r7, r5
10040618:	781b      	ldrb	r3, [r3, #0]
1004061a:	2b00      	cmp	r3, #0
1004061c:	d002      	beq.n	10040624 <BQ27427_selectDataBlock+0x64>
1004061e:	197b      	adds	r3, r7, r5
10040620:	781b      	ldrb	r3, [r3, #0]
10040622:	e006      	b.n	10040632 <BQ27427_selectDataBlock+0x72>
    return BQ27427_Write(sensor_BQ27427, BQ27427_REG_DATAOFFSET, &offset, 1);
10040624:	1cba      	adds	r2, r7, #2
10040626:	6878      	ldr	r0, [r7, #4]
10040628:	2301      	movs	r3, #1
1004062a:	213f      	movs	r1, #63	@ 0x3f
1004062c:	f7ff fef2 	bl	10040414 <BQ27427_Write>
10040630:	0003      	movs	r3, r0
}
10040632:	0018      	movs	r0, r3
10040634:	46bd      	mov	sp, r7
10040636:	b004      	add	sp, #16
10040638:	bdb0      	pop	{r4, r5, r7, pc}
	...

1004063c <BQ27427_GetDesignCapacity>:
 * @brief   Lê o valor atual de "Design Capacity" configurado no gauge.
 * @param   sensor_BQ27427 Ponteiro para o handle do sensor inicializado.
 * @return  Capacidade configurada em mAh, ou 0xFFFF em caso de erro.
 */

uint16_t BQ27427_GetDesignCapacity(BQ27427_t *sensor_BQ27427){
1004063c:	b5b0      	push	{r4, r5, r7, lr}
1004063e:	b088      	sub	sp, #32
10040640:	af00      	add	r7, sp, #0
10040642:	6078      	str	r0, [r7, #4]
		HAL_StatusTypeDef ret;
//	    uint16_t flags;
	    uint16_t densign_capacity;
	    // 1) Unseal twice
	    BQ27427_sendCmd(sensor_BQ27427, BQ27427_SUBCMD_UNSEAL);
10040644:	2118      	movs	r1, #24
10040646:	187b      	adds	r3, r7, r1
10040648:	4a2d      	ldr	r2, [pc, #180]	@ (10040700 <BQ27427_GetDesignCapacity+0xc4>)
1004064a:	801a      	strh	r2, [r3, #0]
1004064c:	187a      	adds	r2, r7, r1
1004064e:	6878      	ldr	r0, [r7, #4]
10040650:	2302      	movs	r3, #2
10040652:	2100      	movs	r1, #0
10040654:	f7ff fede 	bl	10040414 <BQ27427_Write>
	    BQ27427_sendCmd(sensor_BQ27427, BQ27427_SUBCMD_UNSEAL);
10040658:	2114      	movs	r1, #20
1004065a:	187b      	adds	r3, r7, r1
1004065c:	4a28      	ldr	r2, [pc, #160]	@ (10040700 <BQ27427_GetDesignCapacity+0xc4>)
1004065e:	801a      	strh	r2, [r3, #0]
10040660:	187a      	adds	r2, r7, r1
10040662:	6878      	ldr	r0, [r7, #4]
10040664:	2302      	movs	r3, #2
10040666:	2100      	movs	r1, #0
10040668:	f7ff fed4 	bl	10040414 <BQ27427_Write>

	    // 2) Enter CONFIG UPDATE
	    BQ27427_sendCmd(sensor_BQ27427, BQ27427_SUBCMD_CFGUPDATE);
1004066c:	2110      	movs	r1, #16
1004066e:	187b      	adds	r3, r7, r1
10040670:	2213      	movs	r2, #19
10040672:	801a      	strh	r2, [r3, #0]
10040674:	187a      	adds	r2, r7, r1
10040676:	6878      	ldr	r0, [r7, #4]
10040678:	2302      	movs	r3, #2
1004067a:	2100      	movs	r1, #0
1004067c:	f7ff feca 	bl	10040414 <BQ27427_Write>
	    HAL_Delay(1100);
10040680:	4b20      	ldr	r3, [pc, #128]	@ (10040704 <BQ27427_GetDesignCapacity+0xc8>)
10040682:	0018      	movs	r0, r3
10040684:	f000 ff32 	bl	100414ec <HAL_Delay>
//	    do {
//	        flags = BQ27427_ReadFlags(sensor_BQ27427);
//	    } while (!(flags & BQ27427_FLAG_CFGUPMODE));

	    // 4) Select State block, offset 0
	    ret = BQ27427_selectDataBlock(sensor_BQ27427, BQ27427_BLOCK_CLASS_STATE, 0);
10040688:	251f      	movs	r5, #31
1004068a:	197c      	adds	r4, r7, r5
1004068c:	687b      	ldr	r3, [r7, #4]
1004068e:	2200      	movs	r2, #0
10040690:	2152      	movs	r1, #82	@ 0x52
10040692:	0018      	movs	r0, r3
10040694:	f7ff ff94 	bl	100405c0 <BQ27427_selectDataBlock>
10040698:	0003      	movs	r3, r0
1004069a:	7023      	strb	r3, [r4, #0]
	    if (ret != HAL_OK) return ret;
1004069c:	197b      	adds	r3, r7, r5
1004069e:	781b      	ldrb	r3, [r3, #0]
100406a0:	2b00      	cmp	r3, #0
100406a2:	d003      	beq.n	100406ac <BQ27427_GetDesignCapacity+0x70>
100406a4:	197b      	adds	r3, r7, r5
100406a6:	781b      	ldrb	r3, [r3, #0]
100406a8:	b29b      	uxth	r3, r3
100406aa:	e025      	b.n	100406f8 <BQ27427_GetDesignCapacity+0xbc>

	    HAL_Delay(100);
100406ac:	2064      	movs	r0, #100	@ 0x64
100406ae:	f000 ff1d 	bl	100414ec <HAL_Delay>
	    densign_capacity = BQ27427_Read(sensor_BQ27427, 0x4746);
100406b2:	251c      	movs	r5, #28
100406b4:	197c      	adds	r4, r7, r5
100406b6:	4a14      	ldr	r2, [pc, #80]	@ (10040708 <BQ27427_GetDesignCapacity+0xcc>)
100406b8:	687b      	ldr	r3, [r7, #4]
100406ba:	0011      	movs	r1, r2
100406bc:	0018      	movs	r0, r3
100406be:	f7ff fe75 	bl	100403ac <BQ27427_Read>
100406c2:	0003      	movs	r3, r0
100406c4:	8023      	strh	r3, [r4, #0]

	    // 7) Soft-reset to exit CONFIG UPDATE
	    BQ27427_sendCmd(sensor_BQ27427, BQ27427_SUBCMD_SOFT_RESET);
100406c6:	210c      	movs	r1, #12
100406c8:	187b      	adds	r3, r7, r1
100406ca:	2242      	movs	r2, #66	@ 0x42
100406cc:	801a      	strh	r2, [r3, #0]
100406ce:	187a      	adds	r2, r7, r1
100406d0:	6878      	ldr	r0, [r7, #4]
100406d2:	2302      	movs	r3, #2
100406d4:	2100      	movs	r1, #0
100406d6:	f7ff fe9d 	bl	10040414 <BQ27427_Write>
	    HAL_Delay(10);
100406da:	200a      	movs	r0, #10
100406dc:	f000 ff06 	bl	100414ec <HAL_Delay>

	    // Optional: re-seal
	    BQ27427_sendCmd(sensor_BQ27427, BQ27427_SUBCMD_SEALED);
100406e0:	2108      	movs	r1, #8
100406e2:	187b      	adds	r3, r7, r1
100406e4:	2220      	movs	r2, #32
100406e6:	801a      	strh	r2, [r3, #0]
100406e8:	187a      	adds	r2, r7, r1
100406ea:	6878      	ldr	r0, [r7, #4]
100406ec:	2302      	movs	r3, #2
100406ee:	2100      	movs	r1, #0
100406f0:	f7ff fe90 	bl	10040414 <BQ27427_Write>

	    return densign_capacity;
100406f4:	197b      	adds	r3, r7, r5
100406f6:	881b      	ldrh	r3, [r3, #0]
}
100406f8:	0018      	movs	r0, r3
100406fa:	46bd      	mov	sp, r7
100406fc:	b008      	add	sp, #32
100406fe:	bdb0      	pop	{r4, r5, r7, pc}
10040700:	ffff8000 	.word	0xffff8000
10040704:	0000044c 	.word	0x0000044c
10040708:	00004746 	.word	0x00004746

1004070c <LL_AHB1_GRP1_EnableClock>:
  * @arg LL_AHB1_GRP1_PERIPH_RNG
  * @retval None
  * @note   LL_AHB1_GRP1_PERIPH_PKA
  */
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
1004070c:	b580      	push	{r7, lr}
1004070e:	b084      	sub	sp, #16
10040710:	af00      	add	r7, sp, #0
10040712:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHBENR, Periphs);
10040714:	4b07      	ldr	r3, [pc, #28]	@ (10040734 <LL_AHB1_GRP1_EnableClock+0x28>)
10040716:	6d19      	ldr	r1, [r3, #80]	@ 0x50
10040718:	4b06      	ldr	r3, [pc, #24]	@ (10040734 <LL_AHB1_GRP1_EnableClock+0x28>)
1004071a:	687a      	ldr	r2, [r7, #4]
1004071c:	430a      	orrs	r2, r1
1004071e:	651a      	str	r2, [r3, #80]	@ 0x50
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
10040720:	4b04      	ldr	r3, [pc, #16]	@ (10040734 <LL_AHB1_GRP1_EnableClock+0x28>)
10040722:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
10040724:	687a      	ldr	r2, [r7, #4]
10040726:	4013      	ands	r3, r2
10040728:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
1004072a:	68fb      	ldr	r3, [r7, #12]
}
1004072c:	46c0      	nop			@ (mov r8, r8)
1004072e:	46bd      	mov	sp, r7
10040730:	b004      	add	sp, #16
10040732:	bd80      	pop	{r7, pc}
10040734:	48400000 	.word	0x48400000

10040738 <gauge_write>:

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
static HAL_StatusTypeDef gauge_write(uint8_t reg, uint8_t *data, uint8_t len){
10040738:	b580      	push	{r7, lr}
1004073a:	b086      	sub	sp, #24
1004073c:	af04      	add	r7, sp, #16
1004073e:	6039      	str	r1, [r7, #0]
10040740:	0011      	movs	r1, r2
10040742:	1dfb      	adds	r3, r7, #7
10040744:	1c02      	adds	r2, r0, #0
10040746:	701a      	strb	r2, [r3, #0]
10040748:	1dbb      	adds	r3, r7, #6
1004074a:	1c0a      	adds	r2, r1, #0
1004074c:	701a      	strb	r2, [r3, #0]
    return HAL_I2C_Mem_Write(&hi2c1, BQ27427_I2C_ADDR, reg,
1004074e:	1dfb      	adds	r3, r7, #7
10040750:	781b      	ldrb	r3, [r3, #0]
10040752:	b299      	uxth	r1, r3
10040754:	1dbb      	adds	r3, r7, #6
10040756:	781b      	ldrb	r3, [r3, #0]
10040758:	b29b      	uxth	r3, r3
1004075a:	4808      	ldr	r0, [pc, #32]	@ (1004077c <gauge_write+0x44>)
1004075c:	2201      	movs	r2, #1
1004075e:	4252      	negs	r2, r2
10040760:	9202      	str	r2, [sp, #8]
10040762:	9301      	str	r3, [sp, #4]
10040764:	683b      	ldr	r3, [r7, #0]
10040766:	9300      	str	r3, [sp, #0]
10040768:	2301      	movs	r3, #1
1004076a:	000a      	movs	r2, r1
1004076c:	21aa      	movs	r1, #170	@ 0xaa
1004076e:	f001 f9e1 	bl	10041b34 <HAL_I2C_Mem_Write>
10040772:	0003      	movs	r3, r0
                             I2C_MEMADD_SIZE_8BIT, data, len, HAL_MAX_DELAY);
}
10040774:	0018      	movs	r0, r3
10040776:	46bd      	mov	sp, r7
10040778:	b002      	add	sp, #8
1004077a:	bd80      	pop	{r7, pc}
1004077c:	200000c0 	.word	0x200000c0

10040780 <gauge_read>:

static uint16_t gauge_read(uint8_t reg, uint8_t *data, uint8_t len){
10040780:	b580      	push	{r7, lr}
10040782:	b086      	sub	sp, #24
10040784:	af04      	add	r7, sp, #16
10040786:	6039      	str	r1, [r7, #0]
10040788:	0011      	movs	r1, r2
1004078a:	1dfb      	adds	r3, r7, #7
1004078c:	1c02      	adds	r2, r0, #0
1004078e:	701a      	strb	r2, [r3, #0]
10040790:	1dbb      	adds	r3, r7, #6
10040792:	1c0a      	adds	r2, r1, #0
10040794:	701a      	strb	r2, [r3, #0]
    return HAL_I2C_Mem_Read(&hi2c1, BQ27427_I2C_ADDR, reg,
10040796:	1dfb      	adds	r3, r7, #7
10040798:	781b      	ldrb	r3, [r3, #0]
1004079a:	b299      	uxth	r1, r3
1004079c:	1dbb      	adds	r3, r7, #6
1004079e:	781b      	ldrb	r3, [r3, #0]
100407a0:	b29b      	uxth	r3, r3
100407a2:	4808      	ldr	r0, [pc, #32]	@ (100407c4 <gauge_read+0x44>)
100407a4:	2201      	movs	r2, #1
100407a6:	4252      	negs	r2, r2
100407a8:	9202      	str	r2, [sp, #8]
100407aa:	9301      	str	r3, [sp, #4]
100407ac:	683b      	ldr	r3, [r7, #0]
100407ae:	9300      	str	r3, [sp, #0]
100407b0:	2301      	movs	r3, #1
100407b2:	000a      	movs	r2, r1
100407b4:	21aa      	movs	r1, #170	@ 0xaa
100407b6:	f001 faeb 	bl	10041d90 <HAL_I2C_Mem_Read>
100407ba:	0003      	movs	r3, r0
                            I2C_MEMADD_SIZE_8BIT, data, len, HAL_MAX_DELAY);
}
100407bc:	0018      	movs	r0, r3
100407be:	46bd      	mov	sp, r7
100407c0:	b002      	add	sp, #8
100407c2:	bd80      	pop	{r7, pc}
100407c4:	200000c0 	.word	0x200000c0

100407c8 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
100407c8:	b590      	push	{r4, r7, lr}
100407ca:	b089      	sub	sp, #36	@ 0x24
100407cc:	af00      	add	r7, sp, #0
int main(void)
100407ce:	2330      	movs	r3, #48	@ 0x30
100407d0:	18fb      	adds	r3, r7, r3
100407d2:	60bb      	str	r3, [r7, #8]
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
100407d4:	f000 fe05 	bl	100413e2 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
100407d8:	f000 fabc 	bl	10040d54 <SystemClock_Config>

  /* Configure the peripherals common clocks */
  PeriphCommonClock_Config();
100407dc:	f000 fad7 	bl	10040d8e <PeriphCommonClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
100407e0:	f000 fb32 	bl	10040e48 <MX_GPIO_Init>
  MX_I2C1_Init();
100407e4:	f000 faf0 	bl	10040dc8 <MX_I2C1_Init>
  /* USER CODE BEGIN 2 */

  BQ27427_Init(&sensor, &hi2c1); // Inicializa o sensor
100407e8:	4a2e      	ldr	r2, [pc, #184]	@ (100408a4 <main+0xdc>)
100407ea:	4b2f      	ldr	r3, [pc, #188]	@ (100408a8 <main+0xe0>)
100407ec:	0011      	movs	r1, r2
100407ee:	0018      	movs	r0, r3
100407f0:	f7ff fe37 	bl	10040462 <BQ27427_Init>

//	do { control = BQ27427_Control(&sensor);
//	} while ((control & (1 << 0)) != 0 );


	bq27427_set_valores_padrao(150, 3500);
100407f4:	4a2d      	ldr	r2, [pc, #180]	@ (100408ac <main+0xe4>)
100407f6:	2308      	movs	r3, #8
100407f8:	18fb      	adds	r3, r7, r3
100407fa:	469c      	mov	ip, r3
100407fc:	0011      	movs	r1, r2
100407fe:	2096      	movs	r0, #150	@ 0x96
10040800:	f000 f856 	bl	100408b0 <bq27427_set_valores_padrao.0>
//	  (void) nova_capacidade;

//	  uint16_t nova_capacidade = BQ27427_SetDesignCapacity(&sensor, 150);
//	  (void) nova_capacidade;
	  uint8_t old_lsb_CTTC;
	  gauge_read(0x55, &old_lsb_CTTC, 1);
10040804:	1dfb      	adds	r3, r7, #7
10040806:	2201      	movs	r2, #1
10040808:	0019      	movs	r1, r3
1004080a:	2055      	movs	r0, #85	@ 0x55
1004080c:	f7ff ffb8 	bl	10040780 <gauge_read>
	  uint16_t capacidade_da_bateria = BQ27427_GetDesignCapacity(&sensor);
10040810:	231e      	movs	r3, #30
10040812:	18fc      	adds	r4, r7, r3
10040814:	4b24      	ldr	r3, [pc, #144]	@ (100408a8 <main+0xe0>)
10040816:	0018      	movs	r0, r3
10040818:	f7ff ff10 	bl	1004063c <BQ27427_GetDesignCapacity>
1004081c:	0003      	movs	r3, r0
1004081e:	8023      	strh	r3, [r4, #0]
	  (void)capacidade_da_bateria;
	  uint16_t nivel_da_bateria = BQ27427_ReadStateOfCharge(&sensor);
10040820:	231c      	movs	r3, #28
10040822:	18fc      	adds	r4, r7, r3
10040824:	4b20      	ldr	r3, [pc, #128]	@ (100408a8 <main+0xe0>)
10040826:	0018      	movs	r0, r3
10040828:	f7ff fea6 	bl	10040578 <BQ27427_ReadStateOfCharge>
1004082c:	0003      	movs	r3, r0
1004082e:	8023      	strh	r3, [r4, #0]
	  (void)nivel_da_bateria;
	  uint16_t voltage = BQ27427_ReadVoltage(&sensor);
10040830:	231a      	movs	r3, #26
10040832:	18fc      	adds	r4, r7, r3
10040834:	4b1c      	ldr	r3, [pc, #112]	@ (100408a8 <main+0xe0>)
10040836:	0018      	movs	r0, r3
10040838:	f7ff fe20 	bl	1004047c <BQ27427_ReadVoltage>
1004083c:	0003      	movs	r3, r0
1004083e:	8023      	strh	r3, [r4, #0]
	  (void)voltage;
	  uint16_t current = BQ27427_ReadAverageCurrent(&sensor);
10040840:	2318      	movs	r3, #24
10040842:	18fc      	adds	r4, r7, r3
10040844:	4b18      	ldr	r3, [pc, #96]	@ (100408a8 <main+0xe0>)
10040846:	0018      	movs	r0, r3
10040848:	f7ff fe84 	bl	10040554 <BQ27427_ReadAverageCurrent>
1004084c:	0003      	movs	r3, r0
1004084e:	8023      	strh	r3, [r4, #0]
	  (void)current;
      uint16_t NominalAvailableCapacity = BQ27427_ReadNominalAvailableCapacity(&sensor);
10040850:	2316      	movs	r3, #22
10040852:	18fc      	adds	r4, r7, r3
10040854:	4b14      	ldr	r3, [pc, #80]	@ (100408a8 <main+0xe0>)
10040856:	0018      	movs	r0, r3
10040858:	f7ff fe34 	bl	100404c4 <BQ27427_ReadNominalAvailableCapacity>
1004085c:	0003      	movs	r3, r0
1004085e:	8023      	strh	r3, [r4, #0]
      (void)NominalAvailableCapacity;
      uint16_t FullAvailableCapacity = BQ27427_ReadFullAvailableCapacity(&sensor);
10040860:	2314      	movs	r3, #20
10040862:	18fc      	adds	r4, r7, r3
10040864:	4b10      	ldr	r3, [pc, #64]	@ (100408a8 <main+0xe0>)
10040866:	0018      	movs	r0, r3
10040868:	f7ff fe3e 	bl	100404e8 <BQ27427_ReadFullAvailableCapacity>
1004086c:	0003      	movs	r3, r0
1004086e:	8023      	strh	r3, [r4, #0]
      (void)FullAvailableCapacity;
//      uint8_t bat_ins[] = {0x0C,0x00};
//      gauge_write(0x00, bat_ins, 2);
//      HAL_Delay(10);
      uint16_t RemainingCapacity = BQ27427_ReadRemainingCapacity(&sensor);
10040870:	2312      	movs	r3, #18
10040872:	18fc      	adds	r4, r7, r3
10040874:	4b0c      	ldr	r3, [pc, #48]	@ (100408a8 <main+0xe0>)
10040876:	0018      	movs	r0, r3
10040878:	f7ff fe48 	bl	1004050c <BQ27427_ReadRemainingCapacity>
1004087c:	0003      	movs	r3, r0
1004087e:	8023      	strh	r3, [r4, #0]
      (void)RemainingCapacity;
      uint16_t FullChargeCapacity = BQ27427_ReadFullChargeCapacity(&sensor);
10040880:	2310      	movs	r3, #16
10040882:	18fc      	adds	r4, r7, r3
10040884:	4b08      	ldr	r3, [pc, #32]	@ (100408a8 <main+0xe0>)
10040886:	0018      	movs	r0, r3
10040888:	f7ff fe52 	bl	10040530 <BQ27427_ReadFullChargeCapacity>
1004088c:	0003      	movs	r3, r0
1004088e:	8023      	strh	r3, [r4, #0]
      (void)FullChargeCapacity;
      uint16_t RemainingCapacityUnfiltered = BQ27427_ReadRemainingCapacityUnfiltered(&sensor);
10040890:	230e      	movs	r3, #14
10040892:	18fc      	adds	r4, r7, r3
10040894:	4b04      	ldr	r3, [pc, #16]	@ (100408a8 <main+0xe0>)
10040896:	0018      	movs	r0, r3
10040898:	f7ff fe80 	bl	1004059c <BQ27427_ReadRemainingCapacityUnfiltered>
1004089c:	0003      	movs	r3, r0
1004089e:	8023      	strh	r3, [r4, #0]
  {
100408a0:	46c0      	nop			@ (mov r8, r8)
100408a2:	e7af      	b.n	10040804 <main+0x3c>
100408a4:	200000c0 	.word	0x200000c0
100408a8:	20000114 	.word	0x20000114
100408ac:	00000dac 	.word	0x00000dac

100408b0 <bq27427_set_valores_padrao.0>:
{
100408b0:	b5f0      	push	{r4, r5, r6, r7, lr}
100408b2:	b08f      	sub	sp, #60	@ 0x3c
100408b4:	af00      	add	r7, sp, #0
100408b6:	0002      	movs	r2, r0
100408b8:	1dbb      	adds	r3, r7, #6
100408ba:	801a      	strh	r2, [r3, #0]
100408bc:	1d3b      	adds	r3, r7, #4
100408be:	1c0a      	adds	r2, r1, #0
100408c0:	801a      	strh	r2, [r3, #0]
100408c2:	4663      	mov	r3, ip
100408c4:	603b      	str	r3, [r7, #0]
	uint8_t unseal[2] = {0x00, 0x80};
100408c6:	2130      	movs	r1, #48	@ 0x30
100408c8:	187b      	adds	r3, r7, r1
100408ca:	4a15      	ldr	r2, [pc, #84]	@ (10040920 <bq27427_set_valores_padrao.0+0x70>)
100408cc:	801a      	strh	r2, [r3, #0]
	gauge_write(0x00, unseal, 2);
100408ce:	000c      	movs	r4, r1
100408d0:	187b      	adds	r3, r7, r1
100408d2:	2202      	movs	r2, #2
100408d4:	0019      	movs	r1, r3
100408d6:	2000      	movs	r0, #0
100408d8:	f7ff ff2e 	bl	10040738 <gauge_write>
	gauge_write(0x00, unseal, 2);
100408dc:	193b      	adds	r3, r7, r4
100408de:	2202      	movs	r2, #2
100408e0:	0019      	movs	r1, r3
100408e2:	2000      	movs	r0, #0
100408e4:	f7ff ff28 	bl	10040738 <gauge_write>
	uint8_t cfg[2] = {0x13, 0x00};
100408e8:	212c      	movs	r1, #44	@ 0x2c
100408ea:	187b      	adds	r3, r7, r1
100408ec:	2213      	movs	r2, #19
100408ee:	801a      	strh	r2, [r3, #0]
	gauge_write(0x00, cfg, 2);
100408f0:	187b      	adds	r3, r7, r1
100408f2:	2202      	movs	r2, #2
100408f4:	0019      	movs	r1, r3
100408f6:	2000      	movs	r0, #0
100408f8:	f7ff ff1e 	bl	10040738 <gauge_write>
	HAL_Delay(5);
100408fc:	2005      	movs	r0, #5
100408fe:	f000 fdf5 	bl	100414ec <HAL_Delay>
	do { flags = BQ27427_ReadFlags(&sensor); }
10040902:	2536      	movs	r5, #54	@ 0x36
10040904:	197c      	adds	r4, r7, r5
10040906:	4b07      	ldr	r3, [pc, #28]	@ (10040924 <bq27427_set_valores_padrao.0+0x74>)
10040908:	0018      	movs	r0, r3
1004090a:	f7ff fdc9 	bl	100404a0 <BQ27427_ReadFlags>
1004090e:	0003      	movs	r3, r0
10040910:	8023      	strh	r3, [r4, #0]
	while (!(flags & (1U<<4)));
10040912:	197b      	adds	r3, r7, r5
10040914:	881b      	ldrh	r3, [r3, #0]
10040916:	2210      	movs	r2, #16
10040918:	4013      	ands	r3, r2
1004091a:	d0f2      	beq.n	10040902 <bq27427_set_valores_padrao.0+0x52>
1004091c:	e004      	b.n	10040928 <bq27427_set_valores_padrao.0+0x78>
1004091e:	46c0      	nop			@ (mov r8, r8)
10040920:	ffff8000 	.word	0xffff8000
10040924:	20000114 	.word	0x20000114
	uint8_t zero = 0x00, cls = 0x52;
10040928:	212b      	movs	r1, #43	@ 0x2b
1004092a:	187b      	adds	r3, r7, r1
1004092c:	2200      	movs	r2, #0
1004092e:	701a      	strb	r2, [r3, #0]
10040930:	252a      	movs	r5, #42	@ 0x2a
10040932:	197b      	adds	r3, r7, r5
10040934:	2252      	movs	r2, #82	@ 0x52
10040936:	701a      	strb	r2, [r3, #0]
	gauge_write(0x61, &zero, 1);           /* BlockDataControl */
10040938:	000c      	movs	r4, r1
1004093a:	187b      	adds	r3, r7, r1
1004093c:	2201      	movs	r2, #1
1004093e:	0019      	movs	r1, r3
10040940:	2061      	movs	r0, #97	@ 0x61
10040942:	f7ff fef9 	bl	10040738 <gauge_write>
	gauge_write(0x3E, &cls,  1);           /* DataClass = 0x40 */
10040946:	197b      	adds	r3, r7, r5
10040948:	2201      	movs	r2, #1
1004094a:	0019      	movs	r1, r3
1004094c:	203e      	movs	r0, #62	@ 0x3e
1004094e:	f7ff fef3 	bl	10040738 <gauge_write>
	gauge_write(0x3F, &zero, 1);           /* DataBlock = 0 */
10040952:	193b      	adds	r3, r7, r4
10040954:	2201      	movs	r2, #1
10040956:	0019      	movs	r1, r3
10040958:	203f      	movs	r0, #63	@ 0x3f
1004095a:	f7ff feed 	bl	10040738 <gauge_write>
    HAL_Delay(100);
1004095e:	2064      	movs	r0, #100	@ 0x64
10040960:	f000 fdc4 	bl	100414ec <HAL_Delay>
	gauge_read(0x60, &old_csum, 1);   // deve ser o mesmo checksum estável
10040964:	2329      	movs	r3, #41	@ 0x29
10040966:	18fb      	adds	r3, r7, r3
10040968:	2201      	movs	r2, #1
1004096a:	0019      	movs	r1, r3
1004096c:	2060      	movs	r0, #96	@ 0x60
1004096e:	f7ff ff07 	bl	10040780 <gauge_read>
    HAL_Delay(100);
10040972:	2064      	movs	r0, #100	@ 0x64
10040974:	f000 fdba 	bl	100414ec <HAL_Delay>
	gauge_read(0x46, &old_lsb_DC, 1);
10040978:	2127      	movs	r1, #39	@ 0x27
1004097a:	187b      	adds	r3, r7, r1
1004097c:	2201      	movs	r2, #1
1004097e:	0019      	movs	r1, r3
10040980:	2046      	movs	r0, #70	@ 0x46
10040982:	f7ff fefd 	bl	10040780 <gauge_read>
    HAL_Delay(100);
10040986:	2064      	movs	r0, #100	@ 0x64
10040988:	f000 fdb0 	bl	100414ec <HAL_Delay>
	gauge_read(0x47, &old_msb_DC, 1);
1004098c:	2028      	movs	r0, #40	@ 0x28
1004098e:	183b      	adds	r3, r7, r0
10040990:	2201      	movs	r2, #1
10040992:	0019      	movs	r1, r3
10040994:	2047      	movs	r0, #71	@ 0x47
10040996:	f7ff fef3 	bl	10040780 <gauge_read>
    HAL_Delay(100);
1004099a:	2064      	movs	r0, #100	@ 0x64
1004099c:	f000 fda6 	bl	100414ec <HAL_Delay>
	gauge_read(0x55, &old_lsb_CTTC, 1);
100409a0:	241e      	movs	r4, #30
100409a2:	193b      	adds	r3, r7, r4
100409a4:	2201      	movs	r2, #1
100409a6:	0019      	movs	r1, r3
100409a8:	2055      	movs	r0, #85	@ 0x55
100409aa:	f7ff fee9 	bl	10040780 <gauge_read>
    HAL_Delay(100);
100409ae:	2064      	movs	r0, #100	@ 0x64
100409b0:	f000 fd9c 	bl	100414ec <HAL_Delay>
	gauge_read(0x40, &old_lsb_DCT, 1);
100409b4:	2525      	movs	r5, #37	@ 0x25
100409b6:	197b      	adds	r3, r7, r5
100409b8:	2201      	movs	r2, #1
100409ba:	0019      	movs	r1, r3
100409bc:	2040      	movs	r0, #64	@ 0x40
100409be:	f7ff fedf 	bl	10040780 <gauge_read>
    HAL_Delay(100);
100409c2:	2064      	movs	r0, #100	@ 0x64
100409c4:	f000 fd92 	bl	100414ec <HAL_Delay>
	gauge_read(0x41, &old_msb_DCT, 1);
100409c8:	2626      	movs	r6, #38	@ 0x26
100409ca:	19bb      	adds	r3, r7, r6
100409cc:	2201      	movs	r2, #1
100409ce:	0019      	movs	r1, r3
100409d0:	2041      	movs	r0, #65	@ 0x41
100409d2:	f7ff fed5 	bl	10040780 <gauge_read>
    HAL_Delay(100);
100409d6:	2064      	movs	r0, #100	@ 0x64
100409d8:	f000 fd88 	bl	100414ec <HAL_Delay>
	gauge_read(0x42, &old_lsb_CCT, 1);
100409dc:	2323      	movs	r3, #35	@ 0x23
100409de:	18fb      	adds	r3, r7, r3
100409e0:	2201      	movs	r2, #1
100409e2:	0019      	movs	r1, r3
100409e4:	2042      	movs	r0, #66	@ 0x42
100409e6:	f7ff fecb 	bl	10040780 <gauge_read>
    HAL_Delay(100);
100409ea:	2064      	movs	r0, #100	@ 0x64
100409ec:	f000 fd7e 	bl	100414ec <HAL_Delay>
	gauge_read(0x43, &old_msb_CCT, 1);
100409f0:	2424      	movs	r4, #36	@ 0x24
100409f2:	193b      	adds	r3, r7, r4
100409f4:	2201      	movs	r2, #1
100409f6:	0019      	movs	r1, r3
100409f8:	2043      	movs	r0, #67	@ 0x43
100409fa:	f7ff fec1 	bl	10040780 <gauge_read>
    HAL_Delay(100);
100409fe:	2064      	movs	r0, #100	@ 0x64
10040a00:	f000 fd74 	bl	100414ec <HAL_Delay>
	gauge_read(0x44, &old_lsb_QC, 1);
10040a04:	2521      	movs	r5, #33	@ 0x21
10040a06:	197b      	adds	r3, r7, r5
10040a08:	2201      	movs	r2, #1
10040a0a:	0019      	movs	r1, r3
10040a0c:	2044      	movs	r0, #68	@ 0x44
10040a0e:	f7ff feb7 	bl	10040780 <gauge_read>
    HAL_Delay(100);
10040a12:	2064      	movs	r0, #100	@ 0x64
10040a14:	f000 fd6a 	bl	100414ec <HAL_Delay>
	gauge_read(0x45, &old_msb_QC, 1);
10040a18:	2622      	movs	r6, #34	@ 0x22
10040a1a:	19bb      	adds	r3, r7, r6
10040a1c:	2201      	movs	r2, #1
10040a1e:	0019      	movs	r1, r3
10040a20:	2045      	movs	r0, #69	@ 0x45
10040a22:	f7ff fead 	bl	10040780 <gauge_read>
    HAL_Delay(100);
10040a26:	2064      	movs	r0, #100	@ 0x64
10040a28:	f000 fd60 	bl	100414ec <HAL_Delay>
	gauge_read(0x48, &old_lsb_mWh, 1);
10040a2c:	221d      	movs	r2, #29
10040a2e:	18bb      	adds	r3, r7, r2
10040a30:	2201      	movs	r2, #1
10040a32:	0019      	movs	r1, r3
10040a34:	2048      	movs	r0, #72	@ 0x48
10040a36:	f7ff fea3 	bl	10040780 <gauge_read>
    HAL_Delay(100);
10040a3a:	2064      	movs	r0, #100	@ 0x64
10040a3c:	f000 fd56 	bl	100414ec <HAL_Delay>
	gauge_read(0x49, &old_msb_mWh, 1);
10040a40:	241c      	movs	r4, #28
10040a42:	193b      	adds	r3, r7, r4
10040a44:	2201      	movs	r2, #1
10040a46:	0019      	movs	r1, r3
10040a48:	2049      	movs	r0, #73	@ 0x49
10040a4a:	f7ff fe99 	bl	10040780 <gauge_read>
    HAL_Delay(100);
10040a4e:	2064      	movs	r0, #100	@ 0x64
10040a50:	f000 fd4c 	bl	100414ec <HAL_Delay>
	gauge_read(0x4A, &old_lsb_TV, 1);
10040a54:	251f      	movs	r5, #31
10040a56:	197b      	adds	r3, r7, r5
10040a58:	2201      	movs	r2, #1
10040a5a:	0019      	movs	r1, r3
10040a5c:	204a      	movs	r0, #74	@ 0x4a
10040a5e:	f7ff fe8f 	bl	10040780 <gauge_read>
    HAL_Delay(100);
10040a62:	2064      	movs	r0, #100	@ 0x64
10040a64:	f000 fd42 	bl	100414ec <HAL_Delay>
	gauge_read(0x4B, &old_msb_TV, 1);
10040a68:	2620      	movs	r6, #32
10040a6a:	19bb      	adds	r3, r7, r6
10040a6c:	2201      	movs	r2, #1
10040a6e:	0019      	movs	r1, r3
10040a70:	204b      	movs	r0, #75	@ 0x4b
10040a72:	f7ff fe85 	bl	10040780 <gauge_read>
    lsb_DC =  mAh       & 0xFF;
10040a76:	1dbb      	adds	r3, r7, #6
10040a78:	881b      	ldrh	r3, [r3, #0]
10040a7a:	b2da      	uxtb	r2, r3
10040a7c:	241a      	movs	r4, #26
10040a7e:	193b      	adds	r3, r7, r4
10040a80:	701a      	strb	r2, [r3, #0]
    msb_DC = (mAh >> 8) & 0xFF;
10040a82:	1dbb      	adds	r3, r7, #6
10040a84:	881b      	ldrh	r3, [r3, #0]
10040a86:	0a1b      	lsrs	r3, r3, #8
10040a88:	b29b      	uxth	r3, r3
10040a8a:	b2da      	uxtb	r2, r3
10040a8c:	251b      	movs	r5, #27
10040a8e:	197b      	adds	r3, r7, r5
10040a90:	701a      	strb	r2, [r3, #0]
	gauge_write(0x46, &lsb_DC, 1);
10040a92:	193b      	adds	r3, r7, r4
10040a94:	2201      	movs	r2, #1
10040a96:	0019      	movs	r1, r3
10040a98:	2046      	movs	r0, #70	@ 0x46
10040a9a:	f7ff fe4d 	bl	10040738 <gauge_write>
	gauge_write(0x47, &msb_DC, 1);
10040a9e:	197b      	adds	r3, r7, r5
10040aa0:	2201      	movs	r2, #1
10040aa2:	0019      	movs	r1, r3
10040aa4:	2047      	movs	r0, #71	@ 0x47
10040aa6:	f7ff fe47 	bl	10040738 <gauge_write>
	uint8_t lsb_CTTC = 0xF;
10040aaa:	2611      	movs	r6, #17
10040aac:	19bb      	adds	r3, r7, r6
10040aae:	220f      	movs	r2, #15
10040ab0:	701a      	strb	r2, [r3, #0]
	gauge_write(0x55, &lsb_CTTC, 1);
10040ab2:	19bb      	adds	r3, r7, r6
10040ab4:	2201      	movs	r2, #1
10040ab6:	0019      	movs	r1, r3
10040ab8:	2055      	movs	r0, #85	@ 0x55
10040aba:	f7ff fe3d 	bl	10040738 <gauge_write>
	lsb_DCT = 0xA7;
10040abe:	2118      	movs	r1, #24
10040ac0:	187b      	adds	r3, r7, r1
10040ac2:	22a7      	movs	r2, #167	@ 0xa7
10040ac4:	701a      	strb	r2, [r3, #0]
	msb_DCT = 0x00;
10040ac6:	2319      	movs	r3, #25
10040ac8:	18fb      	adds	r3, r7, r3
10040aca:	2200      	movs	r2, #0
10040acc:	701a      	strb	r2, [r3, #0]
	gauge_write(0x40, &lsb_DCT, 1);
10040ace:	187b      	adds	r3, r7, r1
10040ad0:	2201      	movs	r2, #1
10040ad2:	0019      	movs	r1, r3
10040ad4:	2040      	movs	r0, #64	@ 0x40
10040ad6:	f7ff fe2f 	bl	10040738 <gauge_write>
	gauge_write(0x41, &msb_DCT, 1);
10040ada:	2319      	movs	r3, #25
10040adc:	18fb      	adds	r3, r7, r3
10040ade:	2201      	movs	r2, #1
10040ae0:	0019      	movs	r1, r3
10040ae2:	2041      	movs	r0, #65	@ 0x41
10040ae4:	f7ff fe28 	bl	10040738 <gauge_write>
	lsb_CCT = 0x64;
10040ae8:	2016      	movs	r0, #22
10040aea:	183b      	adds	r3, r7, r0
10040aec:	2264      	movs	r2, #100	@ 0x64
10040aee:	701a      	strb	r2, [r3, #0]
	msb_CCT = 0x00;
10040af0:	2217      	movs	r2, #23
10040af2:	18bb      	adds	r3, r7, r2
10040af4:	2200      	movs	r2, #0
10040af6:	701a      	strb	r2, [r3, #0]
	gauge_write(0x42, &lsb_CCT, 1);
10040af8:	183b      	adds	r3, r7, r0
10040afa:	2201      	movs	r2, #1
10040afc:	0019      	movs	r1, r3
10040afe:	2042      	movs	r0, #66	@ 0x42
10040b00:	f7ff fe1a 	bl	10040738 <gauge_write>
	gauge_write(0x43, &msb_CCT, 1);
10040b04:	2217      	movs	r2, #23
10040b06:	18bb      	adds	r3, r7, r2
10040b08:	2201      	movs	r2, #1
10040b0a:	0019      	movs	r1, r3
10040b0c:	2043      	movs	r0, #67	@ 0x43
10040b0e:	f7ff fe13 	bl	10040738 <gauge_write>
	lsb_QC = 0xFA;
10040b12:	2214      	movs	r2, #20
10040b14:	0011      	movs	r1, r2
10040b16:	18bb      	adds	r3, r7, r2
10040b18:	22fa      	movs	r2, #250	@ 0xfa
10040b1a:	701a      	strb	r2, [r3, #0]
	msb_QC = 0x00;
10040b1c:	2215      	movs	r2, #21
10040b1e:	18bb      	adds	r3, r7, r2
10040b20:	2200      	movs	r2, #0
10040b22:	701a      	strb	r2, [r3, #0]
	gauge_write(0x44, &lsb_QC, 1);
10040b24:	000a      	movs	r2, r1
10040b26:	18bb      	adds	r3, r7, r2
10040b28:	2201      	movs	r2, #1
10040b2a:	0019      	movs	r1, r3
10040b2c:	2044      	movs	r0, #68	@ 0x44
10040b2e:	f7ff fe03 	bl	10040738 <gauge_write>
	gauge_write(0x45, &msb_QC, 1);
10040b32:	2215      	movs	r2, #21
10040b34:	18bb      	adds	r3, r7, r2
10040b36:	2201      	movs	r2, #1
10040b38:	0019      	movs	r1, r3
10040b3a:	2045      	movs	r0, #69	@ 0x45
10040b3c:	f7ff fdfc 	bl	10040738 <gauge_write>
	lsb_TV =  mV       & 0xFF;
10040b40:	1d3b      	adds	r3, r7, #4
10040b42:	881b      	ldrh	r3, [r3, #0]
10040b44:	b2da      	uxtb	r2, r3
10040b46:	2012      	movs	r0, #18
10040b48:	183b      	adds	r3, r7, r0
10040b4a:	701a      	strb	r2, [r3, #0]
    msb_TV = (mV >> 8) & 0xFF;
10040b4c:	1d3b      	adds	r3, r7, #4
10040b4e:	881b      	ldrh	r3, [r3, #0]
10040b50:	0a1b      	lsrs	r3, r3, #8
10040b52:	b29b      	uxth	r3, r3
10040b54:	b2da      	uxtb	r2, r3
10040b56:	2113      	movs	r1, #19
10040b58:	187b      	adds	r3, r7, r1
10040b5a:	701a      	strb	r2, [r3, #0]
	gauge_write(0x4A, &lsb_TV, 1);
10040b5c:	183b      	adds	r3, r7, r0
10040b5e:	2201      	movs	r2, #1
10040b60:	0019      	movs	r1, r3
10040b62:	204a      	movs	r0, #74	@ 0x4a
10040b64:	f7ff fde8 	bl	10040738 <gauge_write>
	gauge_write(0x4B, &msb_TV, 1);
10040b68:	2213      	movs	r2, #19
10040b6a:	18bb      	adds	r3, r7, r2
10040b6c:	2201      	movs	r2, #1
10040b6e:	0019      	movs	r1, r3
10040b70:	204b      	movs	r0, #75	@ 0x4b
10040b72:	f7ff fde1 	bl	10040738 <gauge_write>
    uint16_t mWh = mAh*mV/1000;
10040b76:	1dbb      	adds	r3, r7, #6
10040b78:	881b      	ldrh	r3, [r3, #0]
10040b7a:	1d3a      	adds	r2, r7, #4
10040b7c:	8812      	ldrh	r2, [r2, #0]
10040b7e:	4353      	muls	r3, r2
10040b80:	22fa      	movs	r2, #250	@ 0xfa
10040b82:	0091      	lsls	r1, r2, #2
10040b84:	0018      	movs	r0, r3
10040b86:	f7ff fb25 	bl	100401d4 <__divsi3>
10040b8a:	0003      	movs	r3, r0
10040b8c:	001a      	movs	r2, r3
10040b8e:	2034      	movs	r0, #52	@ 0x34
10040b90:	183b      	adds	r3, r7, r0
10040b92:	801a      	strh	r2, [r3, #0]
	lsb_mWh =  mWh       & 0xFF;
10040b94:	183b      	adds	r3, r7, r0
10040b96:	881b      	ldrh	r3, [r3, #0]
10040b98:	b2da      	uxtb	r2, r3
10040b9a:	2310      	movs	r3, #16
10040b9c:	0019      	movs	r1, r3
10040b9e:	18fb      	adds	r3, r7, r3
10040ba0:	701a      	strb	r2, [r3, #0]
    msb_mWh = (mWh >> 8) & 0xFF;
10040ba2:	183b      	adds	r3, r7, r0
10040ba4:	881b      	ldrh	r3, [r3, #0]
10040ba6:	0a1b      	lsrs	r3, r3, #8
10040ba8:	b29b      	uxth	r3, r3
10040baa:	b2da      	uxtb	r2, r3
10040bac:	230f      	movs	r3, #15
10040bae:	18fb      	adds	r3, r7, r3
10040bb0:	701a      	strb	r2, [r3, #0]
    gauge_write(0x48, &lsb_mWh, 1);       // 0x04
10040bb2:	000b      	movs	r3, r1
10040bb4:	18fb      	adds	r3, r7, r3
10040bb6:	2201      	movs	r2, #1
10040bb8:	0019      	movs	r1, r3
10040bba:	2048      	movs	r0, #72	@ 0x48
10040bbc:	f7ff fdbc 	bl	10040738 <gauge_write>
    gauge_write(0x49, &msb_mWh, 1);       // 0xB0
10040bc0:	220f      	movs	r2, #15
10040bc2:	18bb      	adds	r3, r7, r2
10040bc4:	2201      	movs	r2, #1
10040bc6:	0019      	movs	r1, r3
10040bc8:	2049      	movs	r0, #73	@ 0x49
10040bca:	f7ff fdb5 	bl	10040738 <gauge_write>
    uint8_t old_sum = (0xFF - old_csum) & 0xFF;
10040bce:	2229      	movs	r2, #41	@ 0x29
10040bd0:	18bb      	adds	r3, r7, r2
10040bd2:	781a      	ldrb	r2, [r3, #0]
10040bd4:	2333      	movs	r3, #51	@ 0x33
10040bd6:	0018      	movs	r0, r3
10040bd8:	18fb      	adds	r3, r7, r3
10040bda:	43d2      	mvns	r2, r2
10040bdc:	701a      	strb	r2, [r3, #0]
    uint8_t new_sum = (old_sum - old_msb_DC - old_lsb_DC - old_lsb_CTTC - old_msb_DCT - old_lsb_DCT - old_msb_CCT - old_lsb_CCT - old_msb_QC - old_lsb_mWh - old_msb_mWh - old_lsb_QC - old_msb_TV - old_lsb_TV + msb_DC + lsb_DC + lsb_CTTC + msb_DCT + lsb_DCT + msb_CCT + lsb_CCT + msb_QC + lsb_QC + msb_TV + lsb_TV + msb_mWh + lsb_mWh) & 0xFF;
10040bde:	2228      	movs	r2, #40	@ 0x28
10040be0:	18bb      	adds	r3, r7, r2
10040be2:	781b      	ldrb	r3, [r3, #0]
10040be4:	0002      	movs	r2, r0
10040be6:	18ba      	adds	r2, r7, r2
10040be8:	7812      	ldrb	r2, [r2, #0]
10040bea:	1ad3      	subs	r3, r2, r3
10040bec:	b2da      	uxtb	r2, r3
10040bee:	2127      	movs	r1, #39	@ 0x27
10040bf0:	187b      	adds	r3, r7, r1
10040bf2:	781b      	ldrb	r3, [r3, #0]
10040bf4:	1ad3      	subs	r3, r2, r3
10040bf6:	b2da      	uxtb	r2, r3
10040bf8:	211e      	movs	r1, #30
10040bfa:	187b      	adds	r3, r7, r1
10040bfc:	781b      	ldrb	r3, [r3, #0]
10040bfe:	1ad3      	subs	r3, r2, r3
10040c00:	b2da      	uxtb	r2, r3
10040c02:	2026      	movs	r0, #38	@ 0x26
10040c04:	183b      	adds	r3, r7, r0
10040c06:	781b      	ldrb	r3, [r3, #0]
10040c08:	1ad3      	subs	r3, r2, r3
10040c0a:	b2da      	uxtb	r2, r3
10040c0c:	2125      	movs	r1, #37	@ 0x25
10040c0e:	187b      	adds	r3, r7, r1
10040c10:	781b      	ldrb	r3, [r3, #0]
10040c12:	1ad3      	subs	r3, r2, r3
10040c14:	b2da      	uxtb	r2, r3
10040c16:	2124      	movs	r1, #36	@ 0x24
10040c18:	187b      	adds	r3, r7, r1
10040c1a:	781b      	ldrb	r3, [r3, #0]
10040c1c:	1ad3      	subs	r3, r2, r3
10040c1e:	b2da      	uxtb	r2, r3
10040c20:	2323      	movs	r3, #35	@ 0x23
10040c22:	18fb      	adds	r3, r7, r3
10040c24:	781b      	ldrb	r3, [r3, #0]
10040c26:	1ad3      	subs	r3, r2, r3
10040c28:	b2da      	uxtb	r2, r3
10040c2a:	2022      	movs	r0, #34	@ 0x22
10040c2c:	183b      	adds	r3, r7, r0
10040c2e:	781b      	ldrb	r3, [r3, #0]
10040c30:	1ad3      	subs	r3, r2, r3
10040c32:	b2da      	uxtb	r2, r3
10040c34:	201d      	movs	r0, #29
10040c36:	183b      	adds	r3, r7, r0
10040c38:	781b      	ldrb	r3, [r3, #0]
10040c3a:	1ad3      	subs	r3, r2, r3
10040c3c:	b2da      	uxtb	r2, r3
10040c3e:	201c      	movs	r0, #28
10040c40:	183b      	adds	r3, r7, r0
10040c42:	781b      	ldrb	r3, [r3, #0]
10040c44:	1ad3      	subs	r3, r2, r3
10040c46:	b2da      	uxtb	r2, r3
10040c48:	2121      	movs	r1, #33	@ 0x21
10040c4a:	187b      	adds	r3, r7, r1
10040c4c:	781b      	ldrb	r3, [r3, #0]
10040c4e:	1ad3      	subs	r3, r2, r3
10040c50:	b2da      	uxtb	r2, r3
10040c52:	2020      	movs	r0, #32
10040c54:	183b      	adds	r3, r7, r0
10040c56:	781b      	ldrb	r3, [r3, #0]
10040c58:	1ad3      	subs	r3, r2, r3
10040c5a:	b2da      	uxtb	r2, r3
10040c5c:	211f      	movs	r1, #31
10040c5e:	187b      	adds	r3, r7, r1
10040c60:	781b      	ldrb	r3, [r3, #0]
10040c62:	1ad3      	subs	r3, r2, r3
10040c64:	b2da      	uxtb	r2, r3
10040c66:	197b      	adds	r3, r7, r5
10040c68:	781b      	ldrb	r3, [r3, #0]
10040c6a:	18d3      	adds	r3, r2, r3
10040c6c:	b2da      	uxtb	r2, r3
10040c6e:	193b      	adds	r3, r7, r4
10040c70:	781b      	ldrb	r3, [r3, #0]
10040c72:	18d3      	adds	r3, r2, r3
10040c74:	b2da      	uxtb	r2, r3
10040c76:	19bb      	adds	r3, r7, r6
10040c78:	781b      	ldrb	r3, [r3, #0]
10040c7a:	18d3      	adds	r3, r2, r3
10040c7c:	b2da      	uxtb	r2, r3
10040c7e:	2319      	movs	r3, #25
10040c80:	18fb      	adds	r3, r7, r3
10040c82:	781b      	ldrb	r3, [r3, #0]
10040c84:	18d3      	adds	r3, r2, r3
10040c86:	b2da      	uxtb	r2, r3
10040c88:	2118      	movs	r1, #24
10040c8a:	187b      	adds	r3, r7, r1
10040c8c:	781b      	ldrb	r3, [r3, #0]
10040c8e:	18d3      	adds	r3, r2, r3
10040c90:	b2da      	uxtb	r2, r3
10040c92:	2317      	movs	r3, #23
10040c94:	18fb      	adds	r3, r7, r3
10040c96:	781b      	ldrb	r3, [r3, #0]
10040c98:	18d3      	adds	r3, r2, r3
10040c9a:	b2da      	uxtb	r2, r3
10040c9c:	2016      	movs	r0, #22
10040c9e:	183b      	adds	r3, r7, r0
10040ca0:	781b      	ldrb	r3, [r3, #0]
10040ca2:	18d3      	adds	r3, r2, r3
10040ca4:	b2da      	uxtb	r2, r3
10040ca6:	2315      	movs	r3, #21
10040ca8:	18fb      	adds	r3, r7, r3
10040caa:	781b      	ldrb	r3, [r3, #0]
10040cac:	18d3      	adds	r3, r2, r3
10040cae:	b2da      	uxtb	r2, r3
10040cb0:	2114      	movs	r1, #20
10040cb2:	187b      	adds	r3, r7, r1
10040cb4:	781b      	ldrb	r3, [r3, #0]
10040cb6:	18d3      	adds	r3, r2, r3
10040cb8:	b2da      	uxtb	r2, r3
10040cba:	2113      	movs	r1, #19
10040cbc:	187b      	adds	r3, r7, r1
10040cbe:	781b      	ldrb	r3, [r3, #0]
10040cc0:	18d3      	adds	r3, r2, r3
10040cc2:	b2da      	uxtb	r2, r3
10040cc4:	2012      	movs	r0, #18
10040cc6:	183b      	adds	r3, r7, r0
10040cc8:	781b      	ldrb	r3, [r3, #0]
10040cca:	18d3      	adds	r3, r2, r3
10040ccc:	b2da      	uxtb	r2, r3
10040cce:	200f      	movs	r0, #15
10040cd0:	183b      	adds	r3, r7, r0
10040cd2:	781b      	ldrb	r3, [r3, #0]
10040cd4:	18d3      	adds	r3, r2, r3
10040cd6:	b2d9      	uxtb	r1, r3
10040cd8:	2310      	movs	r3, #16
10040cda:	18fb      	adds	r3, r7, r3
10040cdc:	781a      	ldrb	r2, [r3, #0]
10040cde:	2032      	movs	r0, #50	@ 0x32
10040ce0:	183b      	adds	r3, r7, r0
10040ce2:	188a      	adds	r2, r1, r2
10040ce4:	701a      	strb	r2, [r3, #0]
	uint8_t newCsum = (0xFF - new_sum) & 0xFF;
10040ce6:	183b      	adds	r3, r7, r0
10040ce8:	781b      	ldrb	r3, [r3, #0]
10040cea:	43db      	mvns	r3, r3
10040cec:	b2da      	uxtb	r2, r3
10040cee:	210e      	movs	r1, #14
10040cf0:	187b      	adds	r3, r7, r1
10040cf2:	701a      	strb	r2, [r3, #0]
    gauge_write(0x60, &newCsum, 1);
10040cf4:	187b      	adds	r3, r7, r1
10040cf6:	2201      	movs	r2, #1
10040cf8:	0019      	movs	r1, r3
10040cfa:	2060      	movs	r0, #96	@ 0x60
10040cfc:	f7ff fd1c 	bl	10040738 <gauge_write>
	do { flags = BQ27427_ReadFlags(&sensor); }
10040d00:	2536      	movs	r5, #54	@ 0x36
10040d02:	197c      	adds	r4, r7, r5
10040d04:	4b12      	ldr	r3, [pc, #72]	@ (10040d50 <bq27427_set_valores_padrao.0+0x4a0>)
10040d06:	0018      	movs	r0, r3
10040d08:	f7ff fbca 	bl	100404a0 <BQ27427_ReadFlags>
10040d0c:	0003      	movs	r3, r0
10040d0e:	8023      	strh	r3, [r4, #0]
	while (!(flags & (1U<<4)));
10040d10:	197b      	adds	r3, r7, r5
10040d12:	881b      	ldrh	r3, [r3, #0]
10040d14:	2210      	movs	r2, #16
10040d16:	4013      	ands	r3, r2
10040d18:	d0f2      	beq.n	10040d00 <bq27427_set_valores_padrao.0+0x450>
    uint8_t rst[2] = {0x42, 0x00};
10040d1a:	210c      	movs	r1, #12
10040d1c:	187b      	adds	r3, r7, r1
10040d1e:	2242      	movs	r2, #66	@ 0x42
10040d20:	801a      	strh	r2, [r3, #0]
	gauge_write(0x00, rst, 2);
10040d22:	187b      	adds	r3, r7, r1
10040d24:	2202      	movs	r2, #2
10040d26:	0019      	movs	r1, r3
10040d28:	2000      	movs	r0, #0
10040d2a:	f7ff fd05 	bl	10040738 <gauge_write>
	HAL_Delay(5);
10040d2e:	2005      	movs	r0, #5
10040d30:	f000 fbdc 	bl	100414ec <HAL_Delay>
	uint8_t seal[2] = {0x20, 0x00};
10040d34:	2108      	movs	r1, #8
10040d36:	187b      	adds	r3, r7, r1
10040d38:	2220      	movs	r2, #32
10040d3a:	801a      	strh	r2, [r3, #0]
	gauge_write(0x00, seal, 2);
10040d3c:	187b      	adds	r3, r7, r1
10040d3e:	2202      	movs	r2, #2
10040d40:	0019      	movs	r1, r3
10040d42:	2000      	movs	r0, #0
10040d44:	f7ff fcf8 	bl	10040738 <gauge_write>
}
10040d48:	46c0      	nop			@ (mov r8, r8)
10040d4a:	46bd      	mov	sp, r7
10040d4c:	b00f      	add	sp, #60	@ 0x3c
10040d4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
10040d50:	20000114 	.word	0x20000114

10040d54 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
10040d54:	b580      	push	{r7, lr}
10040d56:	b082      	sub	sp, #8
10040d58:	af00      	add	r7, sp, #0
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
10040d5a:	003b      	movs	r3, r7
10040d5c:	0018      	movs	r0, r3
10040d5e:	2308      	movs	r3, #8
10040d60:	001a      	movs	r2, r3
10040d62:	2100      	movs	r1, #0
10040d64:	f001 fee1 	bl	10042b2a <memset>

  /** Configure the SYSCLKSource and SYSCLKDivider
  */
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
10040d68:	003b      	movs	r3, r7
10040d6a:	2202      	movs	r2, #2
10040d6c:	601a      	str	r2, [r3, #0]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_RC64MPLL_DIV1;
10040d6e:	003b      	movs	r3, r7
10040d70:	2200      	movs	r2, #0
10040d72:	605a      	str	r2, [r3, #4]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_WAIT_STATES_1) != HAL_OK)
10040d74:	003b      	movs	r3, r7
10040d76:	2110      	movs	r1, #16
10040d78:	0018      	movs	r0, r3
10040d7a:	f001 fd79 	bl	10042870 <HAL_RCC_ClockConfig>
10040d7e:	1e03      	subs	r3, r0, #0
10040d80:	d001      	beq.n	10040d86 <SystemClock_Config+0x32>
  {
    Error_Handler();
10040d82:	f000 f86c 	bl	10040e5e <Error_Handler>
  }
}
10040d86:	46c0      	nop			@ (mov r8, r8)
10040d88:	46bd      	mov	sp, r7
10040d8a:	b002      	add	sp, #8
10040d8c:	bd80      	pop	{r7, pc}

10040d8e <PeriphCommonClock_Config>:
/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
10040d8e:	b580      	push	{r7, lr}
10040d90:	b086      	sub	sp, #24
10040d92:	af00      	add	r7, sp, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
10040d94:	003b      	movs	r3, r7
10040d96:	0018      	movs	r0, r3
10040d98:	2318      	movs	r3, #24
10040d9a:	001a      	movs	r2, r3
10040d9c:	2100      	movs	r1, #0
10040d9e:	f001 fec4 	bl	10042b2a <memset>

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SMPS;
10040da2:	003b      	movs	r3, r7
10040da4:	2202      	movs	r2, #2
10040da6:	601a      	str	r2, [r3, #0]
  PeriphClkInitStruct.SmpsDivSelection = RCC_SMPSCLK_DIV4;
10040da8:	003b      	movs	r3, r7
10040daa:	2280      	movs	r2, #128	@ 0x80
10040dac:	0152      	lsls	r2, r2, #5
10040dae:	615a      	str	r2, [r3, #20]

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
10040db0:	003b      	movs	r3, r7
10040db2:	0018      	movs	r0, r3
10040db4:	f001 fe7e 	bl	10042ab4 <HAL_RCCEx_PeriphCLKConfig>
10040db8:	1e03      	subs	r3, r0, #0
10040dba:	d001      	beq.n	10040dc0 <PeriphCommonClock_Config+0x32>
  {
    Error_Handler();
10040dbc:	f000 f84f 	bl	10040e5e <Error_Handler>
  }
}
10040dc0:	46c0      	nop			@ (mov r8, r8)
10040dc2:	46bd      	mov	sp, r7
10040dc4:	b006      	add	sp, #24
10040dc6:	bd80      	pop	{r7, pc}

10040dc8 <MX_I2C1_Init>:
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
10040dc8:	b580      	push	{r7, lr}
10040dca:	af00      	add	r7, sp, #0
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
10040dcc:	4b1c      	ldr	r3, [pc, #112]	@ (10040e40 <MX_I2C1_Init+0x78>)
10040dce:	2282      	movs	r2, #130	@ 0x82
10040dd0:	05d2      	lsls	r2, r2, #23
10040dd2:	601a      	str	r2, [r3, #0]
  hi2c1.Init.Timing = 0x00303D5B;
10040dd4:	4b1a      	ldr	r3, [pc, #104]	@ (10040e40 <MX_I2C1_Init+0x78>)
10040dd6:	4a1b      	ldr	r2, [pc, #108]	@ (10040e44 <MX_I2C1_Init+0x7c>)
10040dd8:	605a      	str	r2, [r3, #4]
  hi2c1.Init.OwnAddress1 = 0;
10040dda:	4b19      	ldr	r3, [pc, #100]	@ (10040e40 <MX_I2C1_Init+0x78>)
10040ddc:	2200      	movs	r2, #0
10040dde:	609a      	str	r2, [r3, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
10040de0:	4b17      	ldr	r3, [pc, #92]	@ (10040e40 <MX_I2C1_Init+0x78>)
10040de2:	2201      	movs	r2, #1
10040de4:	60da      	str	r2, [r3, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
10040de6:	4b16      	ldr	r3, [pc, #88]	@ (10040e40 <MX_I2C1_Init+0x78>)
10040de8:	2200      	movs	r2, #0
10040dea:	611a      	str	r2, [r3, #16]
  hi2c1.Init.OwnAddress2 = 0;
10040dec:	4b14      	ldr	r3, [pc, #80]	@ (10040e40 <MX_I2C1_Init+0x78>)
10040dee:	2200      	movs	r2, #0
10040df0:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
10040df2:	4b13      	ldr	r3, [pc, #76]	@ (10040e40 <MX_I2C1_Init+0x78>)
10040df4:	2200      	movs	r2, #0
10040df6:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
10040df8:	4b11      	ldr	r3, [pc, #68]	@ (10040e40 <MX_I2C1_Init+0x78>)
10040dfa:	2200      	movs	r2, #0
10040dfc:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
10040dfe:	4b10      	ldr	r3, [pc, #64]	@ (10040e40 <MX_I2C1_Init+0x78>)
10040e00:	2200      	movs	r2, #0
10040e02:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
10040e04:	4b0e      	ldr	r3, [pc, #56]	@ (10040e40 <MX_I2C1_Init+0x78>)
10040e06:	0018      	movs	r0, r3
10040e08:	f000 fdee 	bl	100419e8 <HAL_I2C_Init>
10040e0c:	1e03      	subs	r3, r0, #0
10040e0e:	d001      	beq.n	10040e14 <MX_I2C1_Init+0x4c>
  {
    Error_Handler();
10040e10:	f000 f825 	bl	10040e5e <Error_Handler>
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
10040e14:	4b0a      	ldr	r3, [pc, #40]	@ (10040e40 <MX_I2C1_Init+0x78>)
10040e16:	2100      	movs	r1, #0
10040e18:	0018      	movs	r0, r3
10040e1a:	f001 fbe9 	bl	100425f0 <HAL_I2CEx_ConfigAnalogFilter>
10040e1e:	1e03      	subs	r3, r0, #0
10040e20:	d001      	beq.n	10040e26 <MX_I2C1_Init+0x5e>
  {
    Error_Handler();
10040e22:	f000 f81c 	bl	10040e5e <Error_Handler>
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
10040e26:	4b06      	ldr	r3, [pc, #24]	@ (10040e40 <MX_I2C1_Init+0x78>)
10040e28:	2100      	movs	r1, #0
10040e2a:	0018      	movs	r0, r3
10040e2c:	f001 fc2c 	bl	10042688 <HAL_I2CEx_ConfigDigitalFilter>
10040e30:	1e03      	subs	r3, r0, #0
10040e32:	d001      	beq.n	10040e38 <MX_I2C1_Init+0x70>
  {
    Error_Handler();
10040e34:	f000 f813 	bl	10040e5e <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
10040e38:	46c0      	nop			@ (mov r8, r8)
10040e3a:	46bd      	mov	sp, r7
10040e3c:	bd80      	pop	{r7, pc}
10040e3e:	46c0      	nop			@ (mov r8, r8)
10040e40:	200000c0 	.word	0x200000c0
10040e44:	00303d5b 	.word	0x00303d5b

10040e48 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
10040e48:	b580      	push	{r7, lr}
10040e4a:	af00      	add	r7, sp, #0
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
10040e4c:	2004      	movs	r0, #4
10040e4e:	f7ff fc5d 	bl	1004070c <LL_AHB1_GRP1_EnableClock>
  __HAL_RCC_GPIOB_CLK_ENABLE();
10040e52:	2008      	movs	r0, #8
10040e54:	f7ff fc5a 	bl	1004070c <LL_AHB1_GRP1_EnableClock>

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
10040e58:	46c0      	nop			@ (mov r8, r8)
10040e5a:	46bd      	mov	sp, r7
10040e5c:	bd80      	pop	{r7, pc}

10040e5e <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
10040e5e:	b580      	push	{r7, lr}
10040e60:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
10040e62:	b672      	cpsid	i
}
10040e64:	46c0      	nop			@ (mov r8, r8)
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
10040e66:	46c0      	nop			@ (mov r8, r8)
10040e68:	e7fd      	b.n	10040e66 <Error_Handler+0x8>
	...

10040e6c <LL_PWR_SetNoPullA>:
  *         @arg @ref LL_PWR_GPIO_BIT_15(*)
  *         (*) available only on STM32WB06 and STM32WB07 devices
  * @retval None
  */
__STATIC_INLINE void LL_PWR_SetNoPullA(uint32_t GPIONumber)
{
10040e6c:	b580      	push	{r7, lr}
10040e6e:	b082      	sub	sp, #8
10040e70:	af00      	add	r7, sp, #0
10040e72:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(PWR->PUCRA, GPIONumber);
10040e74:	4b08      	ldr	r3, [pc, #32]	@ (10040e98 <LL_PWR_SetNoPullA+0x2c>)
10040e76:	6a1a      	ldr	r2, [r3, #32]
10040e78:	687b      	ldr	r3, [r7, #4]
10040e7a:	43d9      	mvns	r1, r3
10040e7c:	4b06      	ldr	r3, [pc, #24]	@ (10040e98 <LL_PWR_SetNoPullA+0x2c>)
10040e7e:	400a      	ands	r2, r1
10040e80:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(PWR->PDCRA, GPIONumber);
10040e82:	4b05      	ldr	r3, [pc, #20]	@ (10040e98 <LL_PWR_SetNoPullA+0x2c>)
10040e84:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10040e86:	687b      	ldr	r3, [r7, #4]
10040e88:	43d9      	mvns	r1, r3
10040e8a:	4b03      	ldr	r3, [pc, #12]	@ (10040e98 <LL_PWR_SetNoPullA+0x2c>)
10040e8c:	400a      	ands	r2, r1
10040e8e:	625a      	str	r2, [r3, #36]	@ 0x24
}
10040e90:	46c0      	nop			@ (mov r8, r8)
10040e92:	46bd      	mov	sp, r7
10040e94:	b002      	add	sp, #8
10040e96:	bd80      	pop	{r7, pc}
10040e98:	48500000 	.word	0x48500000

10040e9c <LL_PWR_SetNoPullB>:
  *         @arg @ref LL_PWR_GPIO_BIT_15
  *         (*) available only oon STM32WB06 and STM32WB07 devices
  * @retval None
  */
__STATIC_INLINE void LL_PWR_SetNoPullB(uint32_t GPIONumber)
{
10040e9c:	b580      	push	{r7, lr}
10040e9e:	b082      	sub	sp, #8
10040ea0:	af00      	add	r7, sp, #0
10040ea2:	6078      	str	r0, [r7, #4]
  CLEAR_BIT(PWR->PUCRB, GPIONumber);
10040ea4:	4b08      	ldr	r3, [pc, #32]	@ (10040ec8 <LL_PWR_SetNoPullB+0x2c>)
10040ea6:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
10040ea8:	687b      	ldr	r3, [r7, #4]
10040eaa:	43d9      	mvns	r1, r3
10040eac:	4b06      	ldr	r3, [pc, #24]	@ (10040ec8 <LL_PWR_SetNoPullB+0x2c>)
10040eae:	400a      	ands	r2, r1
10040eb0:	629a      	str	r2, [r3, #40]	@ 0x28
  CLEAR_BIT(PWR->PDCRB, GPIONumber);
10040eb2:	4b05      	ldr	r3, [pc, #20]	@ (10040ec8 <LL_PWR_SetNoPullB+0x2c>)
10040eb4:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
10040eb6:	687b      	ldr	r3, [r7, #4]
10040eb8:	43d9      	mvns	r1, r3
10040eba:	4b03      	ldr	r3, [pc, #12]	@ (10040ec8 <LL_PWR_SetNoPullB+0x2c>)
10040ebc:	400a      	ands	r2, r1
10040ebe:	62da      	str	r2, [r3, #44]	@ 0x2c
}
10040ec0:	46c0      	nop			@ (mov r8, r8)
10040ec2:	46bd      	mov	sp, r7
10040ec4:	b002      	add	sp, #8
10040ec6:	bd80      	pop	{r7, pc}
10040ec8:	48500000 	.word	0x48500000

10040ecc <LL_AHB1_GRP1_EnableClock>:
{
10040ecc:	b580      	push	{r7, lr}
10040ece:	b084      	sub	sp, #16
10040ed0:	af00      	add	r7, sp, #0
10040ed2:	6078      	str	r0, [r7, #4]
  SET_BIT(RCC->AHBENR, Periphs);
10040ed4:	4b07      	ldr	r3, [pc, #28]	@ (10040ef4 <LL_AHB1_GRP1_EnableClock+0x28>)
10040ed6:	6d19      	ldr	r1, [r3, #80]	@ 0x50
10040ed8:	4b06      	ldr	r3, [pc, #24]	@ (10040ef4 <LL_AHB1_GRP1_EnableClock+0x28>)
10040eda:	687a      	ldr	r2, [r7, #4]
10040edc:	430a      	orrs	r2, r1
10040ede:	651a      	str	r2, [r3, #80]	@ 0x50
  tmpreg = READ_BIT(RCC->AHBENR, Periphs);
10040ee0:	4b04      	ldr	r3, [pc, #16]	@ (10040ef4 <LL_AHB1_GRP1_EnableClock+0x28>)
10040ee2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
10040ee4:	687a      	ldr	r2, [r7, #4]
10040ee6:	4013      	ands	r3, r2
10040ee8:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040eea:	68fb      	ldr	r3, [r7, #12]
}
10040eec:	46c0      	nop			@ (mov r8, r8)
10040eee:	46bd      	mov	sp, r7
10040ef0:	b004      	add	sp, #16
10040ef2:	bd80      	pop	{r7, pc}
10040ef4:	48400000 	.word	0x48400000

10040ef8 <LL_APB0_GRP1_EnableClock>:
  * @retval None
  * @note   LL_APB0_GRP1_PERIPH_TIM1 is valid only for STM32WB06 and STM32WB07
  * @note   LL_APB0_GRP1_PERIPH_TIM2, LL_APB0_GRP1_PERIPH_TIM16 and LL_APB0_GRP1_PERIPH_TIM17 are valid for STM32WB05 and STM32WB09
  */
__STATIC_INLINE void LL_APB0_GRP1_EnableClock(uint32_t Periphs)
{
10040ef8:	b580      	push	{r7, lr}
10040efa:	b084      	sub	sp, #16
10040efc:	af00      	add	r7, sp, #0
10040efe:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB0ENR, Periphs);
10040f00:	4b07      	ldr	r3, [pc, #28]	@ (10040f20 <LL_APB0_GRP1_EnableClock+0x28>)
10040f02:	6d59      	ldr	r1, [r3, #84]	@ 0x54
10040f04:	4b06      	ldr	r3, [pc, #24]	@ (10040f20 <LL_APB0_GRP1_EnableClock+0x28>)
10040f06:	687a      	ldr	r2, [r7, #4]
10040f08:	430a      	orrs	r2, r1
10040f0a:	655a      	str	r2, [r3, #84]	@ 0x54
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB0ENR, Periphs);
10040f0c:	4b04      	ldr	r3, [pc, #16]	@ (10040f20 <LL_APB0_GRP1_EnableClock+0x28>)
10040f0e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
10040f10:	687a      	ldr	r2, [r7, #4]
10040f12:	4013      	ands	r3, r2
10040f14:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040f16:	68fb      	ldr	r3, [r7, #12]
}
10040f18:	46c0      	nop			@ (mov r8, r8)
10040f1a:	46bd      	mov	sp, r7
10040f1c:	b004      	add	sp, #16
10040f1e:	bd80      	pop	{r7, pc}
10040f20:	48400000 	.word	0x48400000

10040f24 <LL_APB1_GRP1_EnableClock>:
  * @arg LL_APB1_GRP1_PERIPH_I2C2
  * @retval None
  * @note   LL_APB1_GRP1_PERIPH_SPI1, LL_APB1_GRP1_PERIPH_SPI2 and LL_APB1_GRP1_PERIPH_I2C2 are valid for STM32WB06 and STM32WB07
  */
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
10040f24:	b580      	push	{r7, lr}
10040f26:	b084      	sub	sp, #16
10040f28:	af00      	add	r7, sp, #0
10040f2a:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR, Periphs);
10040f2c:	4b07      	ldr	r3, [pc, #28]	@ (10040f4c <LL_APB1_GRP1_EnableClock+0x28>)
10040f2e:	6d99      	ldr	r1, [r3, #88]	@ 0x58
10040f30:	4b06      	ldr	r3, [pc, #24]	@ (10040f4c <LL_APB1_GRP1_EnableClock+0x28>)
10040f32:	687a      	ldr	r2, [r7, #4]
10040f34:	430a      	orrs	r2, r1
10040f36:	659a      	str	r2, [r3, #88]	@ 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
10040f38:	4b04      	ldr	r3, [pc, #16]	@ (10040f4c <LL_APB1_GRP1_EnableClock+0x28>)
10040f3a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
10040f3c:	687a      	ldr	r2, [r7, #4]
10040f3e:	4013      	ands	r3, r2
10040f40:	60fb      	str	r3, [r7, #12]
  (void)tmpreg;
10040f42:	68fb      	ldr	r3, [r7, #12]
}
10040f44:	46c0      	nop			@ (mov r8, r8)
10040f46:	46bd      	mov	sp, r7
10040f48:	b004      	add	sp, #16
10040f4a:	bd80      	pop	{r7, pc}
10040f4c:	48400000 	.word	0x48400000

10040f50 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
10040f50:	b580      	push	{r7, lr}
10040f52:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
10040f54:	2380      	movs	r3, #128	@ 0x80
10040f56:	005b      	lsls	r3, r3, #1
10040f58:	0018      	movs	r0, r3
10040f5a:	f7ff ffcd 	bl	10040ef8 <LL_APB0_GRP1_EnableClock>
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
10040f5e:	46c0      	nop			@ (mov r8, r8)
10040f60:	46bd      	mov	sp, r7
10040f62:	bd80      	pop	{r7, pc}

10040f64 <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
10040f64:	b590      	push	{r4, r7, lr}
10040f66:	b089      	sub	sp, #36	@ 0x24
10040f68:	af00      	add	r7, sp, #0
10040f6a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
10040f6c:	240c      	movs	r4, #12
10040f6e:	193b      	adds	r3, r7, r4
10040f70:	0018      	movs	r0, r3
10040f72:	2314      	movs	r3, #20
10040f74:	001a      	movs	r2, r3
10040f76:	2100      	movs	r1, #0
10040f78:	f001 fdd7 	bl	10042b2a <memset>
  if(hi2c->Instance==I2C1)
10040f7c:	687b      	ldr	r3, [r7, #4]
10040f7e:	681a      	ldr	r2, [r3, #0]
10040f80:	2382      	movs	r3, #130	@ 0x82
10040f82:	05db      	lsls	r3, r3, #23
10040f84:	429a      	cmp	r2, r3
10040f86:	d13c      	bne.n	10041002 <HAL_I2C_MspInit+0x9e>
  {
  /* USER CODE BEGIN I2C1_MspInit 0 */

  /* USER CODE END I2C1_MspInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
10040f88:	2004      	movs	r0, #4
10040f8a:	f7ff ff9f 	bl	10040ecc <LL_AHB1_GRP1_EnableClock>
    __HAL_RCC_GPIOB_CLK_ENABLE();
10040f8e:	2008      	movs	r0, #8
10040f90:	f7ff ff9c 	bl	10040ecc <LL_AHB1_GRP1_EnableClock>
    /**I2C1 GPIO Configuration
    PA0     ------> I2C1_SCL
    PB7     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0;
10040f94:	193b      	adds	r3, r7, r4
10040f96:	2201      	movs	r2, #1
10040f98:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
10040f9a:	193b      	adds	r3, r7, r4
10040f9c:	2212      	movs	r2, #18
10040f9e:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
10040fa0:	193b      	adds	r3, r7, r4
10040fa2:	2200      	movs	r2, #0
10040fa4:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
10040fa6:	193b      	adds	r3, r7, r4
10040fa8:	2200      	movs	r2, #0
10040faa:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF0_I2C1;
10040fac:	193b      	adds	r3, r7, r4
10040fae:	2200      	movs	r2, #0
10040fb0:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
10040fb2:	193a      	adds	r2, r7, r4
10040fb4:	2390      	movs	r3, #144	@ 0x90
10040fb6:	05db      	lsls	r3, r3, #23
10040fb8:	0011      	movs	r1, r2
10040fba:	0018      	movs	r0, r3
10040fbc:	f000 fb6e 	bl	1004169c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_7;
10040fc0:	0021      	movs	r1, r4
10040fc2:	187b      	adds	r3, r7, r1
10040fc4:	2280      	movs	r2, #128	@ 0x80
10040fc6:	601a      	str	r2, [r3, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
10040fc8:	187b      	adds	r3, r7, r1
10040fca:	2212      	movs	r2, #18
10040fcc:	605a      	str	r2, [r3, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
10040fce:	187b      	adds	r3, r7, r1
10040fd0:	2200      	movs	r2, #0
10040fd2:	609a      	str	r2, [r3, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
10040fd4:	187b      	adds	r3, r7, r1
10040fd6:	2200      	movs	r2, #0
10040fd8:	60da      	str	r2, [r3, #12]
    GPIO_InitStruct.Alternate = GPIO_AF0_I2C1;
10040fda:	187b      	adds	r3, r7, r1
10040fdc:	2200      	movs	r2, #0
10040fde:	611a      	str	r2, [r3, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
10040fe0:	187b      	adds	r3, r7, r1
10040fe2:	4a0a      	ldr	r2, [pc, #40]	@ (1004100c <HAL_I2C_MspInit+0xa8>)
10040fe4:	0019      	movs	r1, r3
10040fe6:	0010      	movs	r0, r2
10040fe8:	f000 fb58 	bl	1004169c <HAL_GPIO_Init>

    LL_PWR_SetNoPullA(LL_PWR_GPIO_BIT_0);
10040fec:	2001      	movs	r0, #1
10040fee:	f7ff ff3d 	bl	10040e6c <LL_PWR_SetNoPullA>

    LL_PWR_SetNoPullB(LL_PWR_GPIO_BIT_7);
10040ff2:	2080      	movs	r0, #128	@ 0x80
10040ff4:	f7ff ff52 	bl	10040e9c <LL_PWR_SetNoPullB>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
10040ff8:	2380      	movs	r3, #128	@ 0x80
10040ffa:	039b      	lsls	r3, r3, #14
10040ffc:	0018      	movs	r0, r3
10040ffe:	f7ff ff91 	bl	10040f24 <LL_APB1_GRP1_EnableClock>

  /* USER CODE END I2C1_MspInit 1 */

  }

}
10041002:	46c0      	nop			@ (mov r8, r8)
10041004:	46bd      	mov	sp, r7
10041006:	b009      	add	sp, #36	@ 0x24
10041008:	bd90      	pop	{r4, r7, pc}
1004100a:	46c0      	nop			@ (mov r8, r8)
1004100c:	48100000 	.word	0x48100000

10041010 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
10041010:	b580      	push	{r7, lr}
10041012:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
10041014:	46c0      	nop			@ (mov r8, r8)
10041016:	e7fd      	b.n	10041014 <NMI_Handler+0x4>

10041018 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
10041018:	b580      	push	{r7, lr}
1004101a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
1004101c:	46c0      	nop			@ (mov r8, r8)
1004101e:	e7fd      	b.n	1004101c <HardFault_Handler+0x4>

10041020 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
10041020:	b580      	push	{r7, lr}
10041022:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
10041024:	46c0      	nop			@ (mov r8, r8)
10041026:	46bd      	mov	sp, r7
10041028:	bd80      	pop	{r7, pc}

1004102a <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
1004102a:	b580      	push	{r7, lr}
1004102c:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
1004102e:	46c0      	nop			@ (mov r8, r8)
10041030:	46bd      	mov	sp, r7
10041032:	bd80      	pop	{r7, pc}

10041034 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
10041034:	b580      	push	{r7, lr}
10041036:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
10041038:	f000 fa32 	bl	100414a0 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
1004103c:	46c0      	nop			@ (mov r8, r8)
1004103e:	46bd      	mov	sp, r7
10041040:	bd80      	pop	{r7, pc}
	...

10041044 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
10041044:	b590      	push	{r4, r7, lr}
10041046:	b083      	sub	sp, #12
10041048:	af00      	add	r7, sp, #0
1004104a:	0002      	movs	r2, r0
1004104c:	6039      	str	r1, [r7, #0]
1004104e:	1dfb      	adds	r3, r7, #7
10041050:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10041052:	1dfb      	adds	r3, r7, #7
10041054:	781b      	ldrb	r3, [r3, #0]
10041056:	2b7f      	cmp	r3, #127	@ 0x7f
10041058:	d828      	bhi.n	100410ac <__NVIC_SetPriority+0x68>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1004105a:	4a2f      	ldr	r2, [pc, #188]	@ (10041118 <__NVIC_SetPriority+0xd4>)
1004105c:	1dfb      	adds	r3, r7, #7
1004105e:	781b      	ldrb	r3, [r3, #0]
10041060:	b25b      	sxtb	r3, r3
10041062:	089b      	lsrs	r3, r3, #2
10041064:	33c0      	adds	r3, #192	@ 0xc0
10041066:	009b      	lsls	r3, r3, #2
10041068:	589b      	ldr	r3, [r3, r2]
1004106a:	1dfa      	adds	r2, r7, #7
1004106c:	7812      	ldrb	r2, [r2, #0]
1004106e:	0011      	movs	r1, r2
10041070:	2203      	movs	r2, #3
10041072:	400a      	ands	r2, r1
10041074:	00d2      	lsls	r2, r2, #3
10041076:	21ff      	movs	r1, #255	@ 0xff
10041078:	4091      	lsls	r1, r2
1004107a:	000a      	movs	r2, r1
1004107c:	43d2      	mvns	r2, r2
1004107e:	401a      	ands	r2, r3
10041080:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10041082:	683b      	ldr	r3, [r7, #0]
10041084:	019b      	lsls	r3, r3, #6
10041086:	22ff      	movs	r2, #255	@ 0xff
10041088:	401a      	ands	r2, r3
1004108a:	1dfb      	adds	r3, r7, #7
1004108c:	781b      	ldrb	r3, [r3, #0]
1004108e:	0018      	movs	r0, r3
10041090:	2303      	movs	r3, #3
10041092:	4003      	ands	r3, r0
10041094:	00db      	lsls	r3, r3, #3
10041096:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10041098:	481f      	ldr	r0, [pc, #124]	@ (10041118 <__NVIC_SetPriority+0xd4>)
1004109a:	1dfb      	adds	r3, r7, #7
1004109c:	781b      	ldrb	r3, [r3, #0]
1004109e:	b25b      	sxtb	r3, r3
100410a0:	089b      	lsrs	r3, r3, #2
100410a2:	430a      	orrs	r2, r1
100410a4:	33c0      	adds	r3, #192	@ 0xc0
100410a6:	009b      	lsls	r3, r3, #2
100410a8:	501a      	str	r2, [r3, r0]
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
}
100410aa:	e031      	b.n	10041110 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100410ac:	4a1b      	ldr	r2, [pc, #108]	@ (1004111c <__NVIC_SetPriority+0xd8>)
100410ae:	1dfb      	adds	r3, r7, #7
100410b0:	781b      	ldrb	r3, [r3, #0]
100410b2:	0019      	movs	r1, r3
100410b4:	230f      	movs	r3, #15
100410b6:	400b      	ands	r3, r1
100410b8:	3b08      	subs	r3, #8
100410ba:	089b      	lsrs	r3, r3, #2
100410bc:	3306      	adds	r3, #6
100410be:	009b      	lsls	r3, r3, #2
100410c0:	18d3      	adds	r3, r2, r3
100410c2:	3304      	adds	r3, #4
100410c4:	681b      	ldr	r3, [r3, #0]
100410c6:	1dfa      	adds	r2, r7, #7
100410c8:	7812      	ldrb	r2, [r2, #0]
100410ca:	0011      	movs	r1, r2
100410cc:	2203      	movs	r2, #3
100410ce:	400a      	ands	r2, r1
100410d0:	00d2      	lsls	r2, r2, #3
100410d2:	21ff      	movs	r1, #255	@ 0xff
100410d4:	4091      	lsls	r1, r2
100410d6:	000a      	movs	r2, r1
100410d8:	43d2      	mvns	r2, r2
100410da:	401a      	ands	r2, r3
100410dc:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
100410de:	683b      	ldr	r3, [r7, #0]
100410e0:	019b      	lsls	r3, r3, #6
100410e2:	22ff      	movs	r2, #255	@ 0xff
100410e4:	401a      	ands	r2, r3
100410e6:	1dfb      	adds	r3, r7, #7
100410e8:	781b      	ldrb	r3, [r3, #0]
100410ea:	0018      	movs	r0, r3
100410ec:	2303      	movs	r3, #3
100410ee:	4003      	ands	r3, r0
100410f0:	00db      	lsls	r3, r3, #3
100410f2:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100410f4:	4809      	ldr	r0, [pc, #36]	@ (1004111c <__NVIC_SetPriority+0xd8>)
100410f6:	1dfb      	adds	r3, r7, #7
100410f8:	781b      	ldrb	r3, [r3, #0]
100410fa:	001c      	movs	r4, r3
100410fc:	230f      	movs	r3, #15
100410fe:	4023      	ands	r3, r4
10041100:	3b08      	subs	r3, #8
10041102:	089b      	lsrs	r3, r3, #2
10041104:	430a      	orrs	r2, r1
10041106:	3306      	adds	r3, #6
10041108:	009b      	lsls	r3, r3, #2
1004110a:	18c3      	adds	r3, r0, r3
1004110c:	3304      	adds	r3, #4
1004110e:	601a      	str	r2, [r3, #0]
}
10041110:	46c0      	nop			@ (mov r8, r8)
10041112:	46bd      	mov	sp, r7
10041114:	b003      	add	sp, #12
10041116:	bd90      	pop	{r4, r7, pc}
10041118:	e000e100 	.word	0xe000e100
1004111c:	e000ed00 	.word	0xe000ed00

10041120 <__NVIC_SystemReset>:
/**
  \brief   System Reset
  \details Initiates a system reset request to reset the MCU.
 */
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
10041120:	b580      	push	{r7, lr}
10041122:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
10041124:	f3bf 8f4f 	dsb	sy
}
10041128:	46c0      	nop			@ (mov r8, r8)
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
1004112a:	4b04      	ldr	r3, [pc, #16]	@ (1004113c <__NVIC_SystemReset+0x1c>)
1004112c:	4a04      	ldr	r2, [pc, #16]	@ (10041140 <__NVIC_SystemReset+0x20>)
1004112e:	60da      	str	r2, [r3, #12]
  __ASM volatile ("dsb 0xF":::"memory");
10041130:	f3bf 8f4f 	dsb	sy
}
10041134:	46c0      	nop			@ (mov r8, r8)
                 SCB_AIRCR_SYSRESETREQ_Msk);
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
10041136:	46c0      	nop			@ (mov r8, r8)
10041138:	e7fd      	b.n	10041136 <__NVIC_SystemReset+0x16>
1004113a:	46c0      	nop			@ (mov r8, r8)
1004113c:	e000ed00 	.word	0xe000ed00
10041140:	05fa0004 	.word	0x05fa0004

10041144 <SystemInit>:
  * @param  None
  * @retval None
  */

void SystemInit(void)
{
10041144:	b590      	push	{r4, r7, lr}
10041146:	b087      	sub	sp, #28
10041148:	af00      	add	r7, sp, #0
  uint32_t lsiBw;
#endif
  uint8_t i;
  
  /* If the reset reason is a wakeup from power save restore the context */
  if ((RCC->CSR == 0) && ((PWR->SR1 != 0)||(PWR->SR3 != 0))) {
1004114a:	4a64      	ldr	r2, [pc, #400]	@ (100412dc <SystemInit+0x198>)
1004114c:	2394      	movs	r3, #148	@ 0x94
1004114e:	58d3      	ldr	r3, [r2, r3]
10041150:	2b00      	cmp	r3, #0
10041152:	d10e      	bne.n	10041172 <SystemInit+0x2e>
10041154:	4b62      	ldr	r3, [pc, #392]	@ (100412e0 <SystemInit+0x19c>)
10041156:	691b      	ldr	r3, [r3, #16]
10041158:	2b00      	cmp	r3, #0
1004115a:	d103      	bne.n	10041164 <SystemInit+0x20>
1004115c:	4b60      	ldr	r3, [pc, #384]	@ (100412e0 <SystemInit+0x19c>)
1004115e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
10041160:	2b00      	cmp	r3, #0
10041162:	d006      	beq.n	10041172 <SystemInit+0x2e>
    RAM_VR.WakeupFromSleepFlag = 1; /* A wakeup from power save occurred */
10041164:	4b5f      	ldr	r3, [pc, #380]	@ (100412e4 <SystemInit+0x1a0>)
10041166:	2201      	movs	r2, #1
10041168:	609a      	str	r2, [r3, #8]
    CPUcontextRestore();            /* Restore the context */
1004116a:	f000 f901 	bl	10041370 <CPUcontextRestore>
    /* if the context restore worked properly, we should never return here */
    while(1) { 
      NVIC_SystemReset(); 
1004116e:	f7ff ffd7 	bl	10041120 <__NVIC_SystemReset>

  /* Configure the Vector Table location */
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation */
#else
  SCB->VTOR = (uint32_t) (__vector_table);
10041172:	4b5d      	ldr	r3, [pc, #372]	@ (100412e8 <SystemInit+0x1a4>)
10041174:	4a5d      	ldr	r2, [pc, #372]	@ (100412ec <SystemInit+0x1a8>)
10041176:	609a      	str	r2, [r3, #8]
#endif /* USER_VECT_TAB_ADDRESS */

  /* Store in RAM the AppBase information */
  RAM_VR.AppBase = (uint32_t) SCB->VTOR;
10041178:	4b5b      	ldr	r3, [pc, #364]	@ (100412e8 <SystemInit+0x1a4>)
1004117a:	689a      	ldr	r2, [r3, #8]
1004117c:	4b59      	ldr	r3, [pc, #356]	@ (100412e4 <SystemInit+0x1a0>)
1004117e:	611a      	str	r2, [r3, #16]

  /* Enable all the RAM banks in retention during power save */
#if defined(PWR_CR2_RAMRET1)
  SET_BIT(PWR->CR2, PWR_CR2_RAMRET1);
10041180:	4b57      	ldr	r3, [pc, #348]	@ (100412e0 <SystemInit+0x19c>)
10041182:	685a      	ldr	r2, [r3, #4]
10041184:	4b56      	ldr	r3, [pc, #344]	@ (100412e0 <SystemInit+0x19c>)
10041186:	2120      	movs	r1, #32
10041188:	430a      	orrs	r2, r1
1004118a:	605a      	str	r2, [r3, #4]
#endif /* PWR_CR2_RAMRET1 */
  
#if defined(PWR_CR2_RAMRET2)
  SET_BIT(PWR->CR2, PWR_CR2_RAMRET2);
1004118c:	4b54      	ldr	r3, [pc, #336]	@ (100412e0 <SystemInit+0x19c>)
1004118e:	685a      	ldr	r2, [r3, #4]
10041190:	4b53      	ldr	r3, [pc, #332]	@ (100412e0 <SystemInit+0x19c>)
10041192:	2140      	movs	r1, #64	@ 0x40
10041194:	430a      	orrs	r2, r1
10041196:	605a      	str	r2, [r3, #4]
#endif /* PWR_CR2_RAMRET2 */
  
#if defined(PWR_CR2_RAMRET3)
  SET_BIT(PWR->CR2, PWR_CR2_RAMRET3);
10041198:	4b51      	ldr	r3, [pc, #324]	@ (100412e0 <SystemInit+0x19c>)
1004119a:	685a      	ldr	r2, [r3, #4]
1004119c:	4b50      	ldr	r3, [pc, #320]	@ (100412e0 <SystemInit+0x19c>)
1004119e:	2180      	movs	r1, #128	@ 0x80
100411a0:	430a      	orrs	r2, r1
100411a2:	605a      	str	r2, [r3, #4]
#endif /* PWR_CR2_RAMRET3 */

  /* Disable the GPIO retention in power save configuration */
#if defined(PWR_CR2_GPIORET)
  CLEAR_BIT(PWR->CR2, PWR_CR2_GPIORET);
100411a4:	4b4e      	ldr	r3, [pc, #312]	@ (100412e0 <SystemInit+0x19c>)
100411a6:	685a      	ldr	r2, [r3, #4]
100411a8:	4b4d      	ldr	r3, [pc, #308]	@ (100412e0 <SystemInit+0x19c>)
100411aa:	4951      	ldr	r1, [pc, #324]	@ (100412f0 <SystemInit+0x1ac>)
100411ac:	400a      	ands	r2, r1
100411ae:	605a      	str	r2, [r3, #4]
#endif /* PWR_CR2_GPIORET */
   
  /* SMPS setup */
  if ((CFG_HW_SMPS == SMPS_ON) || (CFG_HW_SMPS == SMPS_BYPAPSS))
  {
    while(READ_BIT(PWR->SR2, PWR_SR2_SMPSRDY) != PWR_SR2_SMPSRDY); // Wait until SMPS is ready
100411b0:	46c0      	nop			@ (mov r8, r8)
100411b2:	4b4b      	ldr	r3, [pc, #300]	@ (100412e0 <SystemInit+0x19c>)
100411b4:	695b      	ldr	r3, [r3, #20]
100411b6:	2204      	movs	r2, #4
100411b8:	4013      	ands	r3, r2
100411ba:	2b04      	cmp	r3, #4
100411bc:	d1f9      	bne.n	100411b2 <SystemInit+0x6e>
    MODIFY_REG(PWR->CR5, PWR_CR5_SMPSBOMSEL, (CFG_HW_SMPS_BOM<<PWR_CR5_SMPSBOMSEL_Pos)); // Configure the SMPS BOM
100411be:	4b48      	ldr	r3, [pc, #288]	@ (100412e0 <SystemInit+0x19c>)
100411c0:	69db      	ldr	r3, [r3, #28]
100411c2:	2230      	movs	r2, #48	@ 0x30
100411c4:	4393      	bics	r3, r2
100411c6:	001a      	movs	r2, r3
100411c8:	4b45      	ldr	r3, [pc, #276]	@ (100412e0 <SystemInit+0x19c>)
100411ca:	2120      	movs	r1, #32
100411cc:	430a      	orrs	r2, r1
100411ce:	61da      	str	r2, [r3, #28]
  }
  if ((CFG_HW_SMPS == SMPS_ON) || (CFG_HW_SMPS == SMPS_OFF))
  {
    MODIFY_REG(PWR->CR5, PWR_CR5_NOSMPS, (CFG_HW_SMPS<<PWR_CR5_NOSMPS_Pos)); // SMPS ON/OFF Configuration
100411d0:	4b43      	ldr	r3, [pc, #268]	@ (100412e0 <SystemInit+0x19c>)
100411d2:	69da      	ldr	r2, [r3, #28]
100411d4:	4b42      	ldr	r3, [pc, #264]	@ (100412e0 <SystemInit+0x19c>)
100411d6:	4947      	ldr	r1, [pc, #284]	@ (100412f4 <SystemInit+0x1b0>)
100411d8:	400a      	ands	r2, r1
100411da:	61da      	str	r2, [r3, #28]
  }
  else
  {
    MODIFY_REG(PWR->CR5, PWR_CR5_SMPSFBYP, (1<<PWR_CR5_SMPSFBYP_Pos)); // SMPS BYPASS Configuration
  }
  MODIFY_REG(PWR->CR5, PWR_CR5_SMPSLPOPEN, (CFG_HW_SMPS_LOW_POWER<<PWR_CR5_SMPSLPOPEN_Pos)); // SMPS configuration during power save
100411dc:	4b40      	ldr	r3, [pc, #256]	@ (100412e0 <SystemInit+0x19c>)
100411de:	69da      	ldr	r2, [r3, #28]
100411e0:	4b3f      	ldr	r3, [pc, #252]	@ (100412e0 <SystemInit+0x19c>)
100411e2:	2180      	movs	r1, #128	@ 0x80
100411e4:	0049      	lsls	r1, r1, #1
100411e6:	430a      	orrs	r2, r1
100411e8:	61da      	str	r2, [r3, #28]
  
  /* If Trimming values from engineering in flash locations are not present load default values */
  if (*(volatile uint32_t*)VALIDITY_LOCATION != VALIDITY_TAG)
100411ea:	4b43      	ldr	r3, [pc, #268]	@ (100412f8 <SystemInit+0x1b4>)
100411ec:	681b      	ldr	r3, [r3, #0]
100411ee:	4a43      	ldr	r2, [pc, #268]	@ (100412fc <SystemInit+0x1b8>)
100411f0:	4293      	cmp	r3, r2
100411f2:	d055      	beq.n	100412a0 <SystemInit+0x15c>

    /* Set Low Speed Internal oscillator LPMU trimming value. */
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_TRIM_LSI_LPMU, ((lsiLpmu << PWR_ENGTRIM_TRIM_LSI_LPMU_Pos) & PWR_ENGTRIM_TRIM_LSI_LPMU));
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_TRIMLSILPMUEN);
#else
    hsiCalib       = 0x1F;
100411f4:	231f      	movs	r3, #31
100411f6:	613b      	str	r3, [r7, #16]
    lsiBw          = 8;
100411f8:	2308      	movs	r3, #8
100411fa:	60fb      	str	r3, [r7, #12]
    mainRegulator  = 0x0A;
100411fc:	230a      	movs	r3, #10
100411fe:	60bb      	str	r3, [r7, #8]
    smpsOutVoltage = 0x03;
10041200:	2303      	movs	r3, #3
10041202:	607b      	str	r3, [r7, #4]

    /* Low speed internal RC trimming value set by software */
    MODIFY_REG(RCC->CSSWCR, RCC_CSSWCR_LSISWBW, lsiBw << RCC_CSSWCR_LSISWBW_Pos);
10041204:	4b35      	ldr	r3, [pc, #212]	@ (100412dc <SystemInit+0x198>)
10041206:	68db      	ldr	r3, [r3, #12]
10041208:	221e      	movs	r2, #30
1004120a:	4393      	bics	r3, r2
1004120c:	0019      	movs	r1, r3
1004120e:	68fb      	ldr	r3, [r7, #12]
10041210:	005a      	lsls	r2, r3, #1
10041212:	4b32      	ldr	r3, [pc, #200]	@ (100412dc <SystemInit+0x198>)
10041214:	430a      	orrs	r2, r1
10041216:	60da      	str	r2, [r3, #12]
    SET_BIT(RCC->CSSWCR, RCC_CSSWCR_LSISWTRIMEN);
10041218:	4b30      	ldr	r3, [pc, #192]	@ (100412dc <SystemInit+0x198>)
1004121a:	68da      	ldr	r2, [r3, #12]
1004121c:	4b2f      	ldr	r3, [pc, #188]	@ (100412dc <SystemInit+0x198>)
1004121e:	2101      	movs	r1, #1
10041220:	430a      	orrs	r2, r1
10041222:	60da      	str	r2, [r3, #12]
#endif
    
    /* Set HSI Calibration Trimming value */
    MODIFY_REG(RCC->CSSWCR, RCC_CSSWCR_HSITRIMSW, hsiCalib << RCC_CSSWCR_HSITRIMSW_Pos);
10041224:	4b2d      	ldr	r3, [pc, #180]	@ (100412dc <SystemInit+0x198>)
10041226:	68db      	ldr	r3, [r3, #12]
10041228:	4a35      	ldr	r2, [pc, #212]	@ (10041300 <SystemInit+0x1bc>)
1004122a:	4013      	ands	r3, r2
1004122c:	0019      	movs	r1, r3
1004122e:	693b      	ldr	r3, [r7, #16]
10041230:	061a      	lsls	r2, r3, #24
10041232:	4b2a      	ldr	r3, [pc, #168]	@ (100412dc <SystemInit+0x198>)
10041234:	430a      	orrs	r2, r1
10041236:	60da      	str	r2, [r3, #12]
    SET_BIT(RCC->CSSWCR, RCC_CSSWCR_HSISWTRIMEN);
10041238:	4b28      	ldr	r3, [pc, #160]	@ (100412dc <SystemInit+0x198>)
1004123a:	68da      	ldr	r2, [r3, #12]
1004123c:	4b27      	ldr	r3, [pc, #156]	@ (100412dc <SystemInit+0x198>)
1004123e:	2180      	movs	r1, #128	@ 0x80
10041240:	0409      	lsls	r1, r1, #16
10041242:	430a      	orrs	r2, r1
10041244:	60da      	str	r2, [r3, #12]
              
    /* Set Main Regulator voltage Trimming value */ 
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_TRIM_MR, ((mainRegulator << PWR_ENGTRIM_TRIM_MR_Pos) & PWR_ENGTRIM_TRIM_MR));
10041246:	4a26      	ldr	r2, [pc, #152]	@ (100412e0 <SystemInit+0x19c>)
10041248:	2394      	movs	r3, #148	@ 0x94
1004124a:	58d3      	ldr	r3, [r2, r3]
1004124c:	4a2d      	ldr	r2, [pc, #180]	@ (10041304 <SystemInit+0x1c0>)
1004124e:	401a      	ands	r2, r3
10041250:	68bb      	ldr	r3, [r7, #8]
10041252:	0199      	lsls	r1, r3, #6
10041254:	23f0      	movs	r3, #240	@ 0xf0
10041256:	009b      	lsls	r3, r3, #2
10041258:	400b      	ands	r3, r1
1004125a:	4921      	ldr	r1, [pc, #132]	@ (100412e0 <SystemInit+0x19c>)
1004125c:	4313      	orrs	r3, r2
1004125e:	2294      	movs	r2, #148	@ 0x94
10041260:	508b      	str	r3, [r1, r2]
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_TRIMMREN);
10041262:	4a1f      	ldr	r2, [pc, #124]	@ (100412e0 <SystemInit+0x19c>)
10041264:	2394      	movs	r3, #148	@ 0x94
10041266:	58d3      	ldr	r3, [r2, r3]
10041268:	491d      	ldr	r1, [pc, #116]	@ (100412e0 <SystemInit+0x19c>)
1004126a:	2220      	movs	r2, #32
1004126c:	4313      	orrs	r3, r2
1004126e:	2294      	movs	r2, #148	@ 0x94
10041270:	508b      	str	r3, [r1, r2]

    /* Set SMPS output voltage Trimming value */
    MODIFY_REG(PWR->ENGTRIM, PWR_ENGTRIM_SMPS_TRIM, ((smpsOutVoltage << PWR_ENGTRIM_SMPS_TRIM_Pos) & PWR_ENGTRIM_SMPS_TRIM));
10041272:	4a1b      	ldr	r2, [pc, #108]	@ (100412e0 <SystemInit+0x19c>)
10041274:	2394      	movs	r3, #148	@ 0x94
10041276:	58d3      	ldr	r3, [r2, r3]
10041278:	4a23      	ldr	r2, [pc, #140]	@ (10041308 <SystemInit+0x1c4>)
1004127a:	401a      	ands	r2, r3
1004127c:	687b      	ldr	r3, [r7, #4]
1004127e:	02d9      	lsls	r1, r3, #11
10041280:	23e0      	movs	r3, #224	@ 0xe0
10041282:	019b      	lsls	r3, r3, #6
10041284:	400b      	ands	r3, r1
10041286:	4916      	ldr	r1, [pc, #88]	@ (100412e0 <SystemInit+0x19c>)
10041288:	4313      	orrs	r3, r2
1004128a:	2294      	movs	r2, #148	@ 0x94
1004128c:	508b      	str	r3, [r1, r2]
    SET_BIT(PWR->ENGTRIM, PWR_ENGTRIM_SMPSTRIMEN);    
1004128e:	4a14      	ldr	r2, [pc, #80]	@ (100412e0 <SystemInit+0x19c>)
10041290:	2394      	movs	r3, #148	@ 0x94
10041292:	58d3      	ldr	r3, [r2, r3]
10041294:	4912      	ldr	r1, [pc, #72]	@ (100412e0 <SystemInit+0x19c>)
10041296:	2280      	movs	r2, #128	@ 0x80
10041298:	00d2      	lsls	r2, r2, #3
1004129a:	4313      	orrs	r3, r2
1004129c:	2294      	movs	r2, #148	@ 0x94
1004129e:	508b      	str	r3, [r1, r2]
  }

  /* Set all the interrupt with low priprity */
  for (i=0; i<32; i++)
100412a0:	2317      	movs	r3, #23
100412a2:	18fb      	adds	r3, r7, r3
100412a4:	2200      	movs	r2, #0
100412a6:	701a      	strb	r2, [r3, #0]
100412a8:	e00d      	b.n	100412c6 <SystemInit+0x182>
  {
    NVIC_SetPriority((IRQn_Type)i, IRQ_LOW_PRIORITY);
100412aa:	2417      	movs	r4, #23
100412ac:	193b      	adds	r3, r7, r4
100412ae:	781b      	ldrb	r3, [r3, #0]
100412b0:	b25b      	sxtb	r3, r3
100412b2:	2103      	movs	r1, #3
100412b4:	0018      	movs	r0, r3
100412b6:	f7ff fec5 	bl	10041044 <__NVIC_SetPriority>
  for (i=0; i<32; i++)
100412ba:	0021      	movs	r1, r4
100412bc:	187b      	adds	r3, r7, r1
100412be:	781a      	ldrb	r2, [r3, #0]
100412c0:	187b      	adds	r3, r7, r1
100412c2:	3201      	adds	r2, #1
100412c4:	701a      	strb	r2, [r3, #0]
100412c6:	2317      	movs	r3, #23
100412c8:	18fb      	adds	r3, r7, r3
100412ca:	781b      	ldrb	r3, [r3, #0]
100412cc:	2b1f      	cmp	r3, #31
100412ce:	d9ec      	bls.n	100412aa <SystemInit+0x166>
  __ASM volatile ("cpsie i" : : : "memory");
100412d0:	b662      	cpsie	i
}
100412d2:	46c0      	nop			@ (mov r8, r8)
  }
  
  /* Enable all the irqs */
  __enable_irq();
}
100412d4:	46c0      	nop			@ (mov r8, r8)
100412d6:	46bd      	mov	sp, r7
100412d8:	b007      	add	sp, #28
100412da:	bd90      	pop	{r4, r7, pc}
100412dc:	48400000 	.word	0x48400000
100412e0:	48500000 	.word	0x48500000
100412e4:	20000004 	.word	0x20000004
100412e8:	e000ed00 	.word	0xe000ed00
100412ec:	10040000 	.word	0x10040000
100412f0:	fffffeff 	.word	0xfffffeff
100412f4:	fffffbff 	.word	0xfffffbff
100412f8:	10001ef8 	.word	0x10001ef8
100412fc:	fcbceccc 	.word	0xfcbceccc
10041300:	c0ffffff 	.word	0xc0ffffff
10041304:	fffffc3f 	.word	0xfffffc3f
10041308:	ffffc7ff 	.word	0xffffc7ff

1004130c <SystemCoreClockUpdate>:
  *
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
1004130c:	b580      	push	{r7, lr}
1004130e:	b082      	sub	sp, #8
10041310:	af00      	add	r7, sp, #0
  uint8_t directHSE_enabled;
  uint8_t divPrescaler;

  /* Get SYSCLK source HSE or HSI+PLL64MHz */
  directHSE_enabled = (RCC->CFGR & RCC_CFGR_HSESEL) >> RCC_CFGR_HSESEL_Pos;
10041312:	4b13      	ldr	r3, [pc, #76]	@ (10041360 <SystemCoreClockUpdate+0x54>)
10041314:	689b      	ldr	r3, [r3, #8]
10041316:	085b      	lsrs	r3, r3, #1
10041318:	b2da      	uxtb	r2, r3
1004131a:	1dfb      	adds	r3, r7, #7
1004131c:	2101      	movs	r1, #1
1004131e:	400a      	ands	r2, r1
10041320:	701a      	strb	r2, [r3, #0]
#if defined(STM32WB06) || defined(STM32WB07)
  /* Get the clock divider */
    divPrescaler = (RCC->CFGR & RCC_CFGR_CLKSYSDIV) >> RCC_CFGR_CLKSYSDIV_Pos;
#else
  /* Get the clock divider */
  divPrescaler = (RCC->CFGR & RCC_CFGR_CLKSYSDIV_STATUS) >> RCC_CFGR_CLKSYSDIV_STATUS_Pos;
10041322:	4b0f      	ldr	r3, [pc, #60]	@ (10041360 <SystemCoreClockUpdate+0x54>)
10041324:	689b      	ldr	r3, [r3, #8]
10041326:	0a1b      	lsrs	r3, r3, #8
10041328:	b2da      	uxtb	r2, r3
1004132a:	1dbb      	adds	r3, r7, #6
1004132c:	2107      	movs	r1, #7
1004132e:	400a      	ands	r2, r1
10041330:	701a      	strb	r2, [r3, #0]
#endif

  if (directHSE_enabled)
10041332:	1dfb      	adds	r3, r7, #7
10041334:	781b      	ldrb	r3, [r3, #0]
10041336:	2b00      	cmp	r3, #0
10041338:	d007      	beq.n	1004134a <SystemCoreClockUpdate+0x3e>
  {
    SystemCoreClock = HSE_VALUE >> (divPrescaler - 1U);
1004133a:	1dbb      	adds	r3, r7, #6
1004133c:	781b      	ldrb	r3, [r3, #0]
1004133e:	3b01      	subs	r3, #1
10041340:	4a08      	ldr	r2, [pc, #32]	@ (10041364 <SystemCoreClockUpdate+0x58>)
10041342:	40da      	lsrs	r2, r3
10041344:	4b08      	ldr	r3, [pc, #32]	@ (10041368 <SystemCoreClockUpdate+0x5c>)
10041346:	601a      	str	r2, [r3, #0]
  }
  else
  {
    SystemCoreClock = HSI_VALUE >> divPrescaler;
  }  
}
10041348:	e005      	b.n	10041356 <SystemCoreClockUpdate+0x4a>
    SystemCoreClock = HSI_VALUE >> divPrescaler;
1004134a:	1dbb      	adds	r3, r7, #6
1004134c:	781b      	ldrb	r3, [r3, #0]
1004134e:	4a07      	ldr	r2, [pc, #28]	@ (1004136c <SystemCoreClockUpdate+0x60>)
10041350:	40da      	lsrs	r2, r3
10041352:	4b05      	ldr	r3, [pc, #20]	@ (10041368 <SystemCoreClockUpdate+0x5c>)
10041354:	601a      	str	r2, [r3, #0]
}
10041356:	46c0      	nop			@ (mov r8, r8)
10041358:	46bd      	mov	sp, r7
1004135a:	b002      	add	sp, #8
1004135c:	bd80      	pop	{r7, pc}
1004135e:	46c0      	nop			@ (mov r8, r8)
10041360:	48400000 	.word	0x48400000
10041364:	01e84800 	.word	0x01e84800
10041368:	2000011c 	.word	0x2000011c
1004136c:	03d09000 	.word	0x03d09000

10041370 <CPUcontextRestore>:
  *         by popping it from the stack 
  * @param  None
  * @retval None
  */
__WEAK void CPUcontextRestore(void)
{
10041370:	b580      	push	{r7, lr}
10041372:	af00      	add	r7, sp, #0
}
10041374:	46c0      	nop			@ (mov r8, r8)
10041376:	46bd      	mov	sp, r7
10041378:	bd80      	pop	{r7, pc}
	...

1004137c <Reset_Handler>:

	.section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
   ldr   r0, =_estack
1004137c:	4810      	ldr	r0, [pc, #64]	@ (100413c0 <LoopForever+0x2>)
   mov   sp, r0          /* set stack pointer */
1004137e:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
10041380:	f7ff fee0 	bl	10041144 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs  r1, #0
10041384:	2100      	movs	r1, #0
  b  LoopCopyDataInit
10041386:	e003      	b.n	10041390 <LoopCopyDataInit>

10041388 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
10041388:	4b0e      	ldr	r3, [pc, #56]	@ (100413c4 <LoopForever+0x6>)
  ldr  r3, [r3, r1]
1004138a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
1004138c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
1004138e:	3104      	adds	r1, #4

10041390 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr  r0, =_sdata
10041390:	480d      	ldr	r0, [pc, #52]	@ (100413c8 <LoopForever+0xa>)
  ldr  r3, =_edata
10041392:	4b0e      	ldr	r3, [pc, #56]	@ (100413cc <LoopForever+0xe>)
  adds  r2, r0, r1
10041394:	1842      	adds	r2, r0, r1
  cmp  r2, r3
10041396:	429a      	cmp	r2, r3
  bcc  CopyDataInit
10041398:	d3f6      	bcc.n	10041388 <CopyDataInit>
  ldr  r2, =_sbss
1004139a:	4a0d      	ldr	r2, [pc, #52]	@ (100413d0 <LoopForever+0x12>)
  b  LoopFillZerobss
1004139c:	e002      	b.n	100413a4 <LoopFillZerobss>

1004139e <FillZerobss>:

/* Zero fill the bss segment. */
FillZerobss:
  movs  r3, #0
1004139e:	2300      	movs	r3, #0
  str  r3, [r2]
100413a0:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
100413a2:	3204      	adds	r2, #4

100413a4 <LoopFillZerobss>:

LoopFillZerobss:
  ldr  r3, = _ebss
100413a4:	4b0b      	ldr	r3, [pc, #44]	@ (100413d4 <LoopForever+0x16>)
  cmp  r2, r3
100413a6:	429a      	cmp	r2, r3
  bcc  FillZerobss
100413a8:	d3f9      	bcc.n	1004139e <FillZerobss>
  ldr  r2, =_sbssblue
100413aa:	4a0b      	ldr	r2, [pc, #44]	@ (100413d8 <LoopForever+0x1a>)
  b  LoopFillZeroBlueRam
100413ac:	e002      	b.n	100413b4 <LoopFillZeroBlueRam>

100413ae <FillZerobssram>:


FillZerobssram:
  movs  r3, #0
100413ae:	2300      	movs	r3, #0
  str  r3, [r2]
100413b0:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
100413b2:	3204      	adds	r2, #4

100413b4 <LoopFillZeroBlueRam>:

LoopFillZeroBlueRam:
  ldr  r3, = _ebssblue
100413b4:	4b09      	ldr	r3, [pc, #36]	@ (100413dc <LoopForever+0x1e>)
  cmp  r2, r3
100413b6:	429a      	cmp	r2, r3
  bcc  FillZerobssram
100413b8:	d3f9      	bcc.n	100413ae <FillZerobssram>

/* Call the application's entry point.*/
  bl  main
100413ba:	f7ff fa05 	bl	100407c8 <main>

100413be <LoopForever>:

LoopForever:
    b LoopForever
100413be:	e7fe      	b.n	100413be <LoopForever>
   ldr   r0, =_estack
100413c0:	20010000 	.word	0x20010000
  ldr  r3, =_sidata
100413c4:	10042b44 	.word	0x10042b44
  ldr  r0, =_sdata
100413c8:	2000011c 	.word	0x2000011c
  ldr  r3, =_edata
100413cc:	20000128 	.word	0x20000128
  ldr  r2, =_sbss
100413d0:	200000c0 	.word	0x200000c0
  ldr  r3, = _ebss
100413d4:	2000011c 	.word	0x2000011c
  ldr  r2, =_sbssblue
100413d8:	200000c0 	.word	0x200000c0
  ldr  r3, = _ebssblue
100413dc:	200000c0 	.word	0x200000c0

100413e0 <ADC_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
100413e0:	e7fe      	b.n	100413e0 <ADC_IRQHandler>

100413e2 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
100413e2:	b580      	push	{r7, lr}
100413e4:	b082      	sub	sp, #8
100413e6:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
100413e8:	1dfb      	adds	r3, r7, #7
100413ea:	2200      	movs	r2, #0
100413ec:	701a      	strb	r2, [r3, #0]

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
100413ee:	2003      	movs	r0, #3
100413f0:	f000 f80e 	bl	10041410 <HAL_InitTick>
100413f4:	1e03      	subs	r3, r0, #0
100413f6:	d003      	beq.n	10041400 <HAL_Init+0x1e>
  {
    status = HAL_ERROR;
100413f8:	1dfb      	adds	r3, r7, #7
100413fa:	2201      	movs	r2, #1
100413fc:	701a      	strb	r2, [r3, #0]
100413fe:	e001      	b.n	10041404 <HAL_Init+0x22>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
10041400:	f7ff fda6 	bl	10040f50 <HAL_MspInit>
  }

  /* Return function status */
  return status;
10041404:	1dfb      	adds	r3, r7, #7
10041406:	781b      	ldrb	r3, [r3, #0]
}
10041408:	0018      	movs	r0, r3
1004140a:	46bd      	mov	sp, r7
1004140c:	b002      	add	sp, #8
1004140e:	bd80      	pop	{r7, pc}

10041410 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
10041410:	b590      	push	{r4, r7, lr}
10041412:	b085      	sub	sp, #20
10041414:	af00      	add	r7, sp, #0
10041416:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
10041418:	230f      	movs	r3, #15
1004141a:	18fb      	adds	r3, r7, r3
1004141c:	2200      	movs	r2, #0
1004141e:	701a      	strb	r2, [r3, #0]

  if (uwTickFreq != 0U)
10041420:	4b1d      	ldr	r3, [pc, #116]	@ (10041498 <HAL_InitTick+0x88>)
10041422:	781b      	ldrb	r3, [r3, #0]
10041424:	2b00      	cmp	r3, #0
10041426:	d02c      	beq.n	10041482 <HAL_InitTick+0x72>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(HAL_RCC_GetSysClockFreq() / (1000U / uwTickFreq)) == 0U)
10041428:	f001 face 	bl	100429c8 <HAL_RCC_GetSysClockFreq>
1004142c:	0004      	movs	r4, r0
1004142e:	4b1a      	ldr	r3, [pc, #104]	@ (10041498 <HAL_InitTick+0x88>)
10041430:	781b      	ldrb	r3, [r3, #0]
10041432:	0019      	movs	r1, r3
10041434:	23fa      	movs	r3, #250	@ 0xfa
10041436:	0098      	lsls	r0, r3, #2
10041438:	f7fe fe42 	bl	100400c0 <__udivsi3>
1004143c:	0003      	movs	r3, r0
1004143e:	0019      	movs	r1, r3
10041440:	0020      	movs	r0, r4
10041442:	f7fe fe3d 	bl	100400c0 <__udivsi3>
10041446:	0003      	movs	r3, r0
10041448:	0018      	movs	r0, r3
1004144a:	f000 f91a 	bl	10041682 <HAL_SYSTICK_Config>
1004144e:	1e03      	subs	r3, r0, #0
10041450:	d112      	bne.n	10041478 <HAL_InitTick+0x68>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
10041452:	687b      	ldr	r3, [r7, #4]
10041454:	2b03      	cmp	r3, #3
10041456:	d80a      	bhi.n	1004146e <HAL_InitTick+0x5e>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0);
10041458:	6879      	ldr	r1, [r7, #4]
1004145a:	2301      	movs	r3, #1
1004145c:	425b      	negs	r3, r3
1004145e:	2200      	movs	r2, #0
10041460:	0018      	movs	r0, r3
10041462:	f000 f8f9 	bl	10041658 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
10041466:	4b0d      	ldr	r3, [pc, #52]	@ (1004149c <HAL_InitTick+0x8c>)
10041468:	687a      	ldr	r2, [r7, #4]
1004146a:	601a      	str	r2, [r3, #0]
1004146c:	e00d      	b.n	1004148a <HAL_InitTick+0x7a>
      }
      else
      {
        status = HAL_ERROR;
1004146e:	230f      	movs	r3, #15
10041470:	18fb      	adds	r3, r7, r3
10041472:	2201      	movs	r2, #1
10041474:	701a      	strb	r2, [r3, #0]
10041476:	e008      	b.n	1004148a <HAL_InitTick+0x7a>
      }
    }
    else
    {
      status = HAL_ERROR;
10041478:	230f      	movs	r3, #15
1004147a:	18fb      	adds	r3, r7, r3
1004147c:	2201      	movs	r2, #1
1004147e:	701a      	strb	r2, [r3, #0]
10041480:	e003      	b.n	1004148a <HAL_InitTick+0x7a>
    }
  }
  else
  {
    status = HAL_ERROR;
10041482:	230f      	movs	r3, #15
10041484:	18fb      	adds	r3, r7, r3
10041486:	2201      	movs	r2, #1
10041488:	701a      	strb	r2, [r3, #0]
  }

  /* Return function status */
  return status;
1004148a:	230f      	movs	r3, #15
1004148c:	18fb      	adds	r3, r7, r3
1004148e:	781b      	ldrb	r3, [r3, #0]
}
10041490:	0018      	movs	r0, r3
10041492:	46bd      	mov	sp, r7
10041494:	b005      	add	sp, #20
10041496:	bd90      	pop	{r4, r7, pc}
10041498:	20000124 	.word	0x20000124
1004149c:	20000120 	.word	0x20000120

100414a0 <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
100414a0:	b580      	push	{r7, lr}
100414a2:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
100414a4:	4b05      	ldr	r3, [pc, #20]	@ (100414bc <HAL_IncTick+0x1c>)
100414a6:	781b      	ldrb	r3, [r3, #0]
100414a8:	001a      	movs	r2, r3
100414aa:	4b05      	ldr	r3, [pc, #20]	@ (100414c0 <HAL_IncTick+0x20>)
100414ac:	681b      	ldr	r3, [r3, #0]
100414ae:	18d2      	adds	r2, r2, r3
100414b0:	4b03      	ldr	r3, [pc, #12]	@ (100414c0 <HAL_IncTick+0x20>)
100414b2:	601a      	str	r2, [r3, #0]
}
100414b4:	46c0      	nop			@ (mov r8, r8)
100414b6:	46bd      	mov	sp, r7
100414b8:	bd80      	pop	{r7, pc}
100414ba:	46c0      	nop			@ (mov r8, r8)
100414bc:	20000124 	.word	0x20000124
100414c0:	20000118 	.word	0x20000118

100414c4 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
100414c4:	b580      	push	{r7, lr}
100414c6:	af00      	add	r7, sp, #0
  return uwTick;
100414c8:	4b02      	ldr	r3, [pc, #8]	@ (100414d4 <HAL_GetTick+0x10>)
100414ca:	681b      	ldr	r3, [r3, #0]
}
100414cc:	0018      	movs	r0, r3
100414ce:	46bd      	mov	sp, r7
100414d0:	bd80      	pop	{r7, pc}
100414d2:	46c0      	nop			@ (mov r8, r8)
100414d4:	20000118 	.word	0x20000118

100414d8 <HAL_GetTickPrio>:
/**
  * @brief This function returns a tick priority.
  * @retval tick priority
  */
uint32_t HAL_GetTickPrio(void)
{
100414d8:	b580      	push	{r7, lr}
100414da:	af00      	add	r7, sp, #0
  return uwTickPrio;
100414dc:	4b02      	ldr	r3, [pc, #8]	@ (100414e8 <HAL_GetTickPrio+0x10>)
100414de:	681b      	ldr	r3, [r3, #0]
}
100414e0:	0018      	movs	r0, r3
100414e2:	46bd      	mov	sp, r7
100414e4:	bd80      	pop	{r7, pc}
100414e6:	46c0      	nop			@ (mov r8, r8)
100414e8:	20000120 	.word	0x20000120

100414ec <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
100414ec:	b580      	push	{r7, lr}
100414ee:	b084      	sub	sp, #16
100414f0:	af00      	add	r7, sp, #0
100414f2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
100414f4:	f7ff ffe6 	bl	100414c4 <HAL_GetTick>
100414f8:	0003      	movs	r3, r0
100414fa:	60bb      	str	r3, [r7, #8]
  uint32_t wait = Delay;
100414fc:	687b      	ldr	r3, [r7, #4]
100414fe:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
10041500:	68fb      	ldr	r3, [r7, #12]
10041502:	3301      	adds	r3, #1
10041504:	d005      	beq.n	10041512 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
10041506:	4b0a      	ldr	r3, [pc, #40]	@ (10041530 <HAL_Delay+0x44>)
10041508:	781b      	ldrb	r3, [r3, #0]
1004150a:	001a      	movs	r2, r3
1004150c:	68fb      	ldr	r3, [r7, #12]
1004150e:	189b      	adds	r3, r3, r2
10041510:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
10041512:	46c0      	nop			@ (mov r8, r8)
10041514:	f7ff ffd6 	bl	100414c4 <HAL_GetTick>
10041518:	0002      	movs	r2, r0
1004151a:	68bb      	ldr	r3, [r7, #8]
1004151c:	1ad3      	subs	r3, r2, r3
1004151e:	68fa      	ldr	r2, [r7, #12]
10041520:	429a      	cmp	r2, r3
10041522:	d8f7      	bhi.n	10041514 <HAL_Delay+0x28>
  {
  }
}
10041524:	46c0      	nop			@ (mov r8, r8)
10041526:	46c0      	nop			@ (mov r8, r8)
10041528:	46bd      	mov	sp, r7
1004152a:	b004      	add	sp, #16
1004152c:	bd80      	pop	{r7, pc}
1004152e:	46c0      	nop			@ (mov r8, r8)
10041530:	20000124 	.word	0x20000124

10041534 <__NVIC_SetPriority>:
{
10041534:	b590      	push	{r4, r7, lr}
10041536:	b083      	sub	sp, #12
10041538:	af00      	add	r7, sp, #0
1004153a:	0002      	movs	r2, r0
1004153c:	6039      	str	r1, [r7, #0]
1004153e:	1dfb      	adds	r3, r7, #7
10041540:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
10041542:	1dfb      	adds	r3, r7, #7
10041544:	781b      	ldrb	r3, [r3, #0]
10041546:	2b7f      	cmp	r3, #127	@ 0x7f
10041548:	d828      	bhi.n	1004159c <__NVIC_SetPriority+0x68>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1004154a:	4a2f      	ldr	r2, [pc, #188]	@ (10041608 <__NVIC_SetPriority+0xd4>)
1004154c:	1dfb      	adds	r3, r7, #7
1004154e:	781b      	ldrb	r3, [r3, #0]
10041550:	b25b      	sxtb	r3, r3
10041552:	089b      	lsrs	r3, r3, #2
10041554:	33c0      	adds	r3, #192	@ 0xc0
10041556:	009b      	lsls	r3, r3, #2
10041558:	589b      	ldr	r3, [r3, r2]
1004155a:	1dfa      	adds	r2, r7, #7
1004155c:	7812      	ldrb	r2, [r2, #0]
1004155e:	0011      	movs	r1, r2
10041560:	2203      	movs	r2, #3
10041562:	400a      	ands	r2, r1
10041564:	00d2      	lsls	r2, r2, #3
10041566:	21ff      	movs	r1, #255	@ 0xff
10041568:	4091      	lsls	r1, r2
1004156a:	000a      	movs	r2, r1
1004156c:	43d2      	mvns	r2, r2
1004156e:	401a      	ands	r2, r3
10041570:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
10041572:	683b      	ldr	r3, [r7, #0]
10041574:	019b      	lsls	r3, r3, #6
10041576:	22ff      	movs	r2, #255	@ 0xff
10041578:	401a      	ands	r2, r3
1004157a:	1dfb      	adds	r3, r7, #7
1004157c:	781b      	ldrb	r3, [r3, #0]
1004157e:	0018      	movs	r0, r3
10041580:	2303      	movs	r3, #3
10041582:	4003      	ands	r3, r0
10041584:	00db      	lsls	r3, r3, #3
10041586:	409a      	lsls	r2, r3
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10041588:	481f      	ldr	r0, [pc, #124]	@ (10041608 <__NVIC_SetPriority+0xd4>)
1004158a:	1dfb      	adds	r3, r7, #7
1004158c:	781b      	ldrb	r3, [r3, #0]
1004158e:	b25b      	sxtb	r3, r3
10041590:	089b      	lsrs	r3, r3, #2
10041592:	430a      	orrs	r2, r1
10041594:	33c0      	adds	r3, #192	@ 0xc0
10041596:	009b      	lsls	r3, r3, #2
10041598:	501a      	str	r2, [r3, r0]
}
1004159a:	e031      	b.n	10041600 <__NVIC_SetPriority+0xcc>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1004159c:	4a1b      	ldr	r2, [pc, #108]	@ (1004160c <__NVIC_SetPriority+0xd8>)
1004159e:	1dfb      	adds	r3, r7, #7
100415a0:	781b      	ldrb	r3, [r3, #0]
100415a2:	0019      	movs	r1, r3
100415a4:	230f      	movs	r3, #15
100415a6:	400b      	ands	r3, r1
100415a8:	3b08      	subs	r3, #8
100415aa:	089b      	lsrs	r3, r3, #2
100415ac:	3306      	adds	r3, #6
100415ae:	009b      	lsls	r3, r3, #2
100415b0:	18d3      	adds	r3, r2, r3
100415b2:	3304      	adds	r3, #4
100415b4:	681b      	ldr	r3, [r3, #0]
100415b6:	1dfa      	adds	r2, r7, #7
100415b8:	7812      	ldrb	r2, [r2, #0]
100415ba:	0011      	movs	r1, r2
100415bc:	2203      	movs	r2, #3
100415be:	400a      	ands	r2, r1
100415c0:	00d2      	lsls	r2, r2, #3
100415c2:	21ff      	movs	r1, #255	@ 0xff
100415c4:	4091      	lsls	r1, r2
100415c6:	000a      	movs	r2, r1
100415c8:	43d2      	mvns	r2, r2
100415ca:	401a      	ands	r2, r3
100415cc:	0011      	movs	r1, r2
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
100415ce:	683b      	ldr	r3, [r7, #0]
100415d0:	019b      	lsls	r3, r3, #6
100415d2:	22ff      	movs	r2, #255	@ 0xff
100415d4:	401a      	ands	r2, r3
100415d6:	1dfb      	adds	r3, r7, #7
100415d8:	781b      	ldrb	r3, [r3, #0]
100415da:	0018      	movs	r0, r3
100415dc:	2303      	movs	r3, #3
100415de:	4003      	ands	r3, r0
100415e0:	00db      	lsls	r3, r3, #3
100415e2:	409a      	lsls	r2, r3
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100415e4:	4809      	ldr	r0, [pc, #36]	@ (1004160c <__NVIC_SetPriority+0xd8>)
100415e6:	1dfb      	adds	r3, r7, #7
100415e8:	781b      	ldrb	r3, [r3, #0]
100415ea:	001c      	movs	r4, r3
100415ec:	230f      	movs	r3, #15
100415ee:	4023      	ands	r3, r4
100415f0:	3b08      	subs	r3, #8
100415f2:	089b      	lsrs	r3, r3, #2
100415f4:	430a      	orrs	r2, r1
100415f6:	3306      	adds	r3, #6
100415f8:	009b      	lsls	r3, r3, #2
100415fa:	18c3      	adds	r3, r0, r3
100415fc:	3304      	adds	r3, #4
100415fe:	601a      	str	r2, [r3, #0]
}
10041600:	46c0      	nop			@ (mov r8, r8)
10041602:	46bd      	mov	sp, r7
10041604:	b003      	add	sp, #12
10041606:	bd90      	pop	{r4, r7, pc}
10041608:	e000e100 	.word	0xe000e100
1004160c:	e000ed00 	.word	0xe000ed00

10041610 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
10041610:	b580      	push	{r7, lr}
10041612:	b082      	sub	sp, #8
10041614:	af00      	add	r7, sp, #0
10041616:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
10041618:	687b      	ldr	r3, [r7, #4]
1004161a:	1e5a      	subs	r2, r3, #1
1004161c:	2380      	movs	r3, #128	@ 0x80
1004161e:	045b      	lsls	r3, r3, #17
10041620:	429a      	cmp	r2, r3
10041622:	d301      	bcc.n	10041628 <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
10041624:	2301      	movs	r3, #1
10041626:	e010      	b.n	1004164a <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
10041628:	4b0a      	ldr	r3, [pc, #40]	@ (10041654 <SysTick_Config+0x44>)
1004162a:	687a      	ldr	r2, [r7, #4]
1004162c:	3a01      	subs	r2, #1
1004162e:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
10041630:	2301      	movs	r3, #1
10041632:	425b      	negs	r3, r3
10041634:	2103      	movs	r1, #3
10041636:	0018      	movs	r0, r3
10041638:	f7ff ff7c 	bl	10041534 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
1004163c:	4b05      	ldr	r3, [pc, #20]	@ (10041654 <SysTick_Config+0x44>)
1004163e:	2200      	movs	r2, #0
10041640:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
10041642:	4b04      	ldr	r3, [pc, #16]	@ (10041654 <SysTick_Config+0x44>)
10041644:	2207      	movs	r2, #7
10041646:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
10041648:	2300      	movs	r3, #0
}
1004164a:	0018      	movs	r0, r3
1004164c:	46bd      	mov	sp, r7
1004164e:	b002      	add	sp, #8
10041650:	bd80      	pop	{r7, pc}
10041652:	46c0      	nop			@ (mov r8, r8)
10041654:	e000e010 	.word	0xe000e010

10041658 <HAL_NVIC_SetPriority>:
  *         with stm32wb0x devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
10041658:	b580      	push	{r7, lr}
1004165a:	b084      	sub	sp, #16
1004165c:	af00      	add	r7, sp, #0
1004165e:	60b9      	str	r1, [r7, #8]
10041660:	607a      	str	r2, [r7, #4]
10041662:	210f      	movs	r1, #15
10041664:	187b      	adds	r3, r7, r1
10041666:	1c02      	adds	r2, r0, #0
10041668:	701a      	strb	r2, [r3, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn, PreemptPriority);
1004166a:	68ba      	ldr	r2, [r7, #8]
1004166c:	187b      	adds	r3, r7, r1
1004166e:	781b      	ldrb	r3, [r3, #0]
10041670:	b25b      	sxtb	r3, r3
10041672:	0011      	movs	r1, r2
10041674:	0018      	movs	r0, r3
10041676:	f7ff ff5d 	bl	10041534 <__NVIC_SetPriority>
}
1004167a:	46c0      	nop			@ (mov r8, r8)
1004167c:	46bd      	mov	sp, r7
1004167e:	b004      	add	sp, #16
10041680:	bd80      	pop	{r7, pc}

10041682 <HAL_SYSTICK_Config>:
  * @param TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
10041682:	b580      	push	{r7, lr}
10041684:	b082      	sub	sp, #8
10041686:	af00      	add	r7, sp, #0
10041688:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
1004168a:	687b      	ldr	r3, [r7, #4]
1004168c:	0018      	movs	r0, r3
1004168e:	f7ff ffbf 	bl	10041610 <SysTick_Config>
10041692:	0003      	movs	r3, r0
}
10041694:	0018      	movs	r0, r3
10041696:	46bd      	mov	sp, r7
10041698:	b002      	add	sp, #8
1004169a:	bd80      	pop	{r7, pc}

1004169c <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
1004169c:	b580      	push	{r7, lr}
1004169e:	b086      	sub	sp, #24
100416a0:	af00      	add	r7, sp, #0
100416a2:	6078      	str	r0, [r7, #4]
100416a4:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
100416a6:	2300      	movs	r3, #0
100416a8:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
100416aa:	e190      	b.n	100419ce <HAL_GPIO_Init+0x332>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
100416ac:	683b      	ldr	r3, [r7, #0]
100416ae:	681b      	ldr	r3, [r3, #0]
100416b0:	2101      	movs	r1, #1
100416b2:	697a      	ldr	r2, [r7, #20]
100416b4:	4091      	lsls	r1, r2
100416b6:	000a      	movs	r2, r1
100416b8:	4013      	ands	r3, r2
100416ba:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00u)
100416bc:	68fb      	ldr	r3, [r7, #12]
100416be:	2b00      	cmp	r3, #0
100416c0:	d100      	bne.n	100416c4 <HAL_GPIO_Init+0x28>
100416c2:	e181      	b.n	100419c8 <HAL_GPIO_Init+0x32c>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
100416c4:	683b      	ldr	r3, [r7, #0]
100416c6:	685b      	ldr	r3, [r3, #4]
100416c8:	2203      	movs	r2, #3
100416ca:	4013      	ands	r3, r2
100416cc:	2b01      	cmp	r3, #1
100416ce:	d005      	beq.n	100416dc <HAL_GPIO_Init+0x40>
100416d0:	683b      	ldr	r3, [r7, #0]
100416d2:	685b      	ldr	r3, [r3, #4]
100416d4:	2203      	movs	r2, #3
100416d6:	4013      	ands	r3, r2
100416d8:	2b02      	cmp	r3, #2
100416da:	d130      	bne.n	1004173e <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
100416dc:	687b      	ldr	r3, [r7, #4]
100416de:	689b      	ldr	r3, [r3, #8]
100416e0:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
100416e2:	697b      	ldr	r3, [r7, #20]
100416e4:	005b      	lsls	r3, r3, #1
100416e6:	2203      	movs	r2, #3
100416e8:	409a      	lsls	r2, r3
100416ea:	0013      	movs	r3, r2
100416ec:	43da      	mvns	r2, r3
100416ee:	693b      	ldr	r3, [r7, #16]
100416f0:	4013      	ands	r3, r2
100416f2:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * 2u));
100416f4:	683b      	ldr	r3, [r7, #0]
100416f6:	68da      	ldr	r2, [r3, #12]
100416f8:	697b      	ldr	r3, [r7, #20]
100416fa:	005b      	lsls	r3, r3, #1
100416fc:	409a      	lsls	r2, r3
100416fe:	0013      	movs	r3, r2
10041700:	693a      	ldr	r2, [r7, #16]
10041702:	4313      	orrs	r3, r2
10041704:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
10041706:	687b      	ldr	r3, [r7, #4]
10041708:	693a      	ldr	r2, [r7, #16]
1004170a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
1004170c:	687b      	ldr	r3, [r7, #4]
1004170e:	685b      	ldr	r3, [r3, #4]
10041710:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
10041712:	2201      	movs	r2, #1
10041714:	697b      	ldr	r3, [r7, #20]
10041716:	409a      	lsls	r2, r3
10041718:	0013      	movs	r3, r2
1004171a:	43da      	mvns	r2, r3
1004171c:	693b      	ldr	r3, [r7, #16]
1004171e:	4013      	ands	r3, r2
10041720:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
10041722:	683b      	ldr	r3, [r7, #0]
10041724:	685b      	ldr	r3, [r3, #4]
10041726:	091b      	lsrs	r3, r3, #4
10041728:	2201      	movs	r2, #1
1004172a:	401a      	ands	r2, r3
1004172c:	697b      	ldr	r3, [r7, #20]
1004172e:	409a      	lsls	r2, r3
10041730:	0013      	movs	r3, r2
10041732:	693a      	ldr	r2, [r7, #16]
10041734:	4313      	orrs	r3, r2
10041736:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
10041738:	687b      	ldr	r3, [r7, #4]
1004173a:	693a      	ldr	r2, [r7, #16]
1004173c:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
1004173e:	683b      	ldr	r3, [r7, #0]
10041740:	685b      	ldr	r3, [r3, #4]
10041742:	2203      	movs	r2, #3
10041744:	4013      	ands	r3, r2
10041746:	2b03      	cmp	r3, #3
10041748:	d017      	beq.n	1004177a <HAL_GPIO_Init+0xde>
      {
        temp = GPIOx->PUPDR;
1004174a:	687b      	ldr	r3, [r7, #4]
1004174c:	68db      	ldr	r3, [r3, #12]
1004174e:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
10041750:	697b      	ldr	r3, [r7, #20]
10041752:	005b      	lsls	r3, r3, #1
10041754:	2203      	movs	r2, #3
10041756:	409a      	lsls	r2, r3
10041758:	0013      	movs	r3, r2
1004175a:	43da      	mvns	r2, r3
1004175c:	693b      	ldr	r3, [r7, #16]
1004175e:	4013      	ands	r3, r2
10041760:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
10041762:	683b      	ldr	r3, [r7, #0]
10041764:	689a      	ldr	r2, [r3, #8]
10041766:	697b      	ldr	r3, [r7, #20]
10041768:	005b      	lsls	r3, r3, #1
1004176a:	409a      	lsls	r2, r3
1004176c:	0013      	movs	r3, r2
1004176e:	693a      	ldr	r2, [r7, #16]
10041770:	4313      	orrs	r3, r2
10041772:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
10041774:	687b      	ldr	r3, [r7, #4]
10041776:	693a      	ldr	r2, [r7, #16]
10041778:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
1004177a:	683b      	ldr	r3, [r7, #0]
1004177c:	685b      	ldr	r3, [r3, #4]
1004177e:	2203      	movs	r2, #3
10041780:	4013      	ands	r3, r2
10041782:	2b02      	cmp	r3, #2
10041784:	d123      	bne.n	100417ce <HAL_GPIO_Init+0x132>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3u];
10041786:	697b      	ldr	r3, [r7, #20]
10041788:	08da      	lsrs	r2, r3, #3
1004178a:	687b      	ldr	r3, [r7, #4]
1004178c:	3208      	adds	r2, #8
1004178e:	0092      	lsls	r2, r2, #2
10041790:	58d3      	ldr	r3, [r2, r3]
10041792:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
10041794:	697b      	ldr	r3, [r7, #20]
10041796:	2207      	movs	r2, #7
10041798:	4013      	ands	r3, r2
1004179a:	009b      	lsls	r3, r3, #2
1004179c:	220f      	movs	r2, #15
1004179e:	409a      	lsls	r2, r3
100417a0:	0013      	movs	r3, r2
100417a2:	43da      	mvns	r2, r3
100417a4:	693b      	ldr	r3, [r7, #16]
100417a6:	4013      	ands	r3, r2
100417a8:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
100417aa:	683b      	ldr	r3, [r7, #0]
100417ac:	691a      	ldr	r2, [r3, #16]
100417ae:	697b      	ldr	r3, [r7, #20]
100417b0:	2107      	movs	r1, #7
100417b2:	400b      	ands	r3, r1
100417b4:	009b      	lsls	r3, r3, #2
100417b6:	409a      	lsls	r2, r3
100417b8:	0013      	movs	r3, r2
100417ba:	693a      	ldr	r2, [r7, #16]
100417bc:	4313      	orrs	r3, r2
100417be:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3u] = temp;
100417c0:	697b      	ldr	r3, [r7, #20]
100417c2:	08da      	lsrs	r2, r3, #3
100417c4:	687b      	ldr	r3, [r7, #4]
100417c6:	3208      	adds	r2, #8
100417c8:	0092      	lsls	r2, r2, #2
100417ca:	6939      	ldr	r1, [r7, #16]
100417cc:	50d1      	str	r1, [r2, r3]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
100417ce:	687b      	ldr	r3, [r7, #4]
100417d0:	681b      	ldr	r3, [r3, #0]
100417d2:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
100417d4:	697b      	ldr	r3, [r7, #20]
100417d6:	005b      	lsls	r3, r3, #1
100417d8:	2203      	movs	r2, #3
100417da:	409a      	lsls	r2, r3
100417dc:	0013      	movs	r3, r2
100417de:	43da      	mvns	r2, r3
100417e0:	693b      	ldr	r3, [r7, #16]
100417e2:	4013      	ands	r3, r2
100417e4:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
100417e6:	683b      	ldr	r3, [r7, #0]
100417e8:	685b      	ldr	r3, [r3, #4]
100417ea:	2203      	movs	r2, #3
100417ec:	401a      	ands	r2, r3
100417ee:	697b      	ldr	r3, [r7, #20]
100417f0:	005b      	lsls	r3, r3, #1
100417f2:	409a      	lsls	r2, r3
100417f4:	0013      	movs	r3, r2
100417f6:	693a      	ldr	r2, [r7, #16]
100417f8:	4313      	orrs	r3, r2
100417fa:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
100417fc:	687b      	ldr	r3, [r7, #4]
100417fe:	693a      	ldr	r2, [r7, #16]
10041800:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
10041802:	683b      	ldr	r3, [r7, #0]
10041804:	685a      	ldr	r2, [r3, #4]
10041806:	23c0      	movs	r3, #192	@ 0xc0
10041808:	029b      	lsls	r3, r3, #10
1004180a:	4013      	ands	r3, r2
1004180c:	d100      	bne.n	10041810 <HAL_GPIO_Init+0x174>
1004180e:	e0db      	b.n	100419c8 <HAL_GPIO_Init+0x32c>
      {

        /* Edge/Level line configuration */
        if ((GPIO_Init->Mode & DETECTION_TYPE) != 0x00u)
10041810:	683b      	ldr	r3, [r7, #0]
10041812:	685a      	ldr	r2, [r3, #4]
10041814:	2380      	movs	r3, #128	@ 0x80
10041816:	02db      	lsls	r3, r3, #11
10041818:	4013      	ands	r3, r2
1004181a:	d030      	beq.n	1004187e <HAL_GPIO_Init+0x1e2>
        {
          temp = SYSCFG->IO_DTR;
1004181c:	2380      	movs	r3, #128	@ 0x80
1004181e:	05db      	lsls	r3, r3, #23
10041820:	68db      	ldr	r3, [r3, #12]
10041822:	613b      	str	r3, [r7, #16]
          if (GPIOx == GPIOA)
10041824:	687a      	ldr	r2, [r7, #4]
10041826:	2390      	movs	r3, #144	@ 0x90
10041828:	05db      	lsls	r3, r3, #23
1004182a:	429a      	cmp	r2, r3
1004182c:	d111      	bne.n	10041852 <HAL_GPIO_Init+0x1b6>
          {
            temp &= ~(1 << position);
1004182e:	2201      	movs	r2, #1
10041830:	697b      	ldr	r3, [r7, #20]
10041832:	409a      	lsls	r2, r3
10041834:	0013      	movs	r3, r2
10041836:	43db      	mvns	r3, r3
10041838:	001a      	movs	r2, r3
1004183a:	693b      	ldr	r3, [r7, #16]
1004183c:	4013      	ands	r3, r2
1004183e:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
10041840:	2201      	movs	r2, #1
10041842:	697b      	ldr	r3, [r7, #20]
10041844:	409a      	lsls	r2, r3
10041846:	0013      	movs	r3, r2
10041848:	001a      	movs	r2, r3
1004184a:	693b      	ldr	r3, [r7, #16]
1004184c:	4313      	orrs	r3, r2
1004184e:	613b      	str	r3, [r7, #16]
10041850:	e011      	b.n	10041876 <HAL_GPIO_Init+0x1da>
          }
          else
          {
            temp &= ~((1 << position) << 16);
10041852:	2201      	movs	r2, #1
10041854:	697b      	ldr	r3, [r7, #20]
10041856:	409a      	lsls	r2, r3
10041858:	0013      	movs	r3, r2
1004185a:	041b      	lsls	r3, r3, #16
1004185c:	43db      	mvns	r3, r3
1004185e:	001a      	movs	r2, r3
10041860:	693b      	ldr	r3, [r7, #16]
10041862:	4013      	ands	r3, r2
10041864:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
10041866:	2201      	movs	r2, #1
10041868:	697b      	ldr	r3, [r7, #20]
1004186a:	409a      	lsls	r2, r3
1004186c:	0013      	movs	r3, r2
1004186e:	041b      	lsls	r3, r3, #16
10041870:	693a      	ldr	r2, [r7, #16]
10041872:	4313      	orrs	r3, r2
10041874:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_DTR = temp;
10041876:	2380      	movs	r3, #128	@ 0x80
10041878:	05db      	lsls	r3, r3, #23
1004187a:	693a      	ldr	r2, [r7, #16]
1004187c:	60da      	str	r2, [r3, #12]
        }

		/* Edge selection configuration */
		if ((GPIO_Init->Mode & EDGE_SELECTION) != 0x00u)
1004187e:	683b      	ldr	r3, [r7, #0]
10041880:	685a      	ldr	r2, [r3, #4]
10041882:	2380      	movs	r3, #128	@ 0x80
10041884:	035b      	lsls	r3, r3, #13
10041886:	4013      	ands	r3, r2
10041888:	d030      	beq.n	100418ec <HAL_GPIO_Init+0x250>
        {
          temp = SYSCFG->IO_IBER;
1004188a:	2380      	movs	r3, #128	@ 0x80
1004188c:	05db      	lsls	r3, r3, #23
1004188e:	691b      	ldr	r3, [r3, #16]
10041890:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
10041892:	687a      	ldr	r2, [r7, #4]
10041894:	2390      	movs	r3, #144	@ 0x90
10041896:	05db      	lsls	r3, r3, #23
10041898:	429a      	cmp	r2, r3
1004189a:	d111      	bne.n	100418c0 <HAL_GPIO_Init+0x224>
          {
            temp &= ~(1 << position);
1004189c:	2201      	movs	r2, #1
1004189e:	697b      	ldr	r3, [r7, #20]
100418a0:	409a      	lsls	r2, r3
100418a2:	0013      	movs	r3, r2
100418a4:	43db      	mvns	r3, r3
100418a6:	001a      	movs	r2, r3
100418a8:	693b      	ldr	r3, [r7, #16]
100418aa:	4013      	ands	r3, r2
100418ac:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
100418ae:	2201      	movs	r2, #1
100418b0:	697b      	ldr	r3, [r7, #20]
100418b2:	409a      	lsls	r2, r3
100418b4:	0013      	movs	r3, r2
100418b6:	001a      	movs	r2, r3
100418b8:	693b      	ldr	r3, [r7, #16]
100418ba:	4313      	orrs	r3, r2
100418bc:	613b      	str	r3, [r7, #16]
100418be:	e011      	b.n	100418e4 <HAL_GPIO_Init+0x248>
          }
          else
          {
            temp &= ~((1 << position) << 16);
100418c0:	2201      	movs	r2, #1
100418c2:	697b      	ldr	r3, [r7, #20]
100418c4:	409a      	lsls	r2, r3
100418c6:	0013      	movs	r3, r2
100418c8:	041b      	lsls	r3, r3, #16
100418ca:	43db      	mvns	r3, r3
100418cc:	001a      	movs	r2, r3
100418ce:	693b      	ldr	r3, [r7, #16]
100418d0:	4013      	ands	r3, r2
100418d2:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
100418d4:	2201      	movs	r2, #1
100418d6:	697b      	ldr	r3, [r7, #20]
100418d8:	409a      	lsls	r2, r3
100418da:	0013      	movs	r3, r2
100418dc:	041b      	lsls	r3, r3, #16
100418de:	693a      	ldr	r2, [r7, #16]
100418e0:	4313      	orrs	r3, r2
100418e2:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IBER= temp;
100418e4:	2380      	movs	r3, #128	@ 0x80
100418e6:	05db      	lsls	r3, r3, #23
100418e8:	693a      	ldr	r2, [r7, #16]
100418ea:	611a      	str	r2, [r3, #16]
        }

        /* Trigger mode configuration */
		if ((GPIO_Init->Mode & TRIGGER_MODE) != 0x00u)
100418ec:	683b      	ldr	r3, [r7, #0]
100418ee:	685a      	ldr	r2, [r3, #4]
100418f0:	2380      	movs	r3, #128	@ 0x80
100418f2:	03db      	lsls	r3, r3, #15
100418f4:	4013      	ands	r3, r2
100418f6:	d030      	beq.n	1004195a <HAL_GPIO_Init+0x2be>
        {
          temp = SYSCFG->IO_IEVR;
100418f8:	2380      	movs	r3, #128	@ 0x80
100418fa:	05db      	lsls	r3, r3, #23
100418fc:	695b      	ldr	r3, [r3, #20]
100418fe:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
10041900:	687a      	ldr	r2, [r7, #4]
10041902:	2390      	movs	r3, #144	@ 0x90
10041904:	05db      	lsls	r3, r3, #23
10041906:	429a      	cmp	r2, r3
10041908:	d111      	bne.n	1004192e <HAL_GPIO_Init+0x292>
          {
            temp &= ~(1 << position);
1004190a:	2201      	movs	r2, #1
1004190c:	697b      	ldr	r3, [r7, #20]
1004190e:	409a      	lsls	r2, r3
10041910:	0013      	movs	r3, r2
10041912:	43db      	mvns	r3, r3
10041914:	001a      	movs	r2, r3
10041916:	693b      	ldr	r3, [r7, #16]
10041918:	4013      	ands	r3, r2
1004191a:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
1004191c:	2201      	movs	r2, #1
1004191e:	697b      	ldr	r3, [r7, #20]
10041920:	409a      	lsls	r2, r3
10041922:	0013      	movs	r3, r2
10041924:	001a      	movs	r2, r3
10041926:	693b      	ldr	r3, [r7, #16]
10041928:	4313      	orrs	r3, r2
1004192a:	613b      	str	r3, [r7, #16]
1004192c:	e011      	b.n	10041952 <HAL_GPIO_Init+0x2b6>
          }
          else
          {
            temp &= ~((1 << position) << 16);
1004192e:	2201      	movs	r2, #1
10041930:	697b      	ldr	r3, [r7, #20]
10041932:	409a      	lsls	r2, r3
10041934:	0013      	movs	r3, r2
10041936:	041b      	lsls	r3, r3, #16
10041938:	43db      	mvns	r3, r3
1004193a:	001a      	movs	r2, r3
1004193c:	693b      	ldr	r3, [r7, #16]
1004193e:	4013      	ands	r3, r2
10041940:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
10041942:	2201      	movs	r2, #1
10041944:	697b      	ldr	r3, [r7, #20]
10041946:	409a      	lsls	r2, r3
10041948:	0013      	movs	r3, r2
1004194a:	041b      	lsls	r3, r3, #16
1004194c:	693a      	ldr	r2, [r7, #16]
1004194e:	4313      	orrs	r3, r2
10041950:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IEVR= temp;
10041952:	2380      	movs	r3, #128	@ 0x80
10041954:	05db      	lsls	r3, r3, #23
10041956:	693a      	ldr	r2, [r7, #16]
10041958:	615a      	str	r2, [r3, #20]
        }

        /* Enable the specified EXTI interrupt line */
        if ((GPIO_Init->Mode & EXTI_IT) == EXTI_IT)
1004195a:	683b      	ldr	r3, [r7, #0]
1004195c:	685a      	ldr	r2, [r3, #4]
1004195e:	2380      	movs	r3, #128	@ 0x80
10041960:	025b      	lsls	r3, r3, #9
10041962:	4013      	ands	r3, r2
10041964:	d030      	beq.n	100419c8 <HAL_GPIO_Init+0x32c>
        {
          temp = SYSCFG->IO_IER;
10041966:	2380      	movs	r3, #128	@ 0x80
10041968:	05db      	lsls	r3, r3, #23
1004196a:	699b      	ldr	r3, [r3, #24]
1004196c:	613b      	str	r3, [r7, #16]

          if (GPIOx == GPIOA)
1004196e:	687a      	ldr	r2, [r7, #4]
10041970:	2390      	movs	r3, #144	@ 0x90
10041972:	05db      	lsls	r3, r3, #23
10041974:	429a      	cmp	r2, r3
10041976:	d111      	bne.n	1004199c <HAL_GPIO_Init+0x300>
          {
            temp &= ~(1 << position);
10041978:	2201      	movs	r2, #1
1004197a:	697b      	ldr	r3, [r7, #20]
1004197c:	409a      	lsls	r2, r3
1004197e:	0013      	movs	r3, r2
10041980:	43db      	mvns	r3, r3
10041982:	001a      	movs	r2, r3
10041984:	693b      	ldr	r3, [r7, #16]
10041986:	4013      	ands	r3, r2
10041988:	613b      	str	r3, [r7, #16]
            temp |= (1 << position);
1004198a:	2201      	movs	r2, #1
1004198c:	697b      	ldr	r3, [r7, #20]
1004198e:	409a      	lsls	r2, r3
10041990:	0013      	movs	r3, r2
10041992:	001a      	movs	r2, r3
10041994:	693b      	ldr	r3, [r7, #16]
10041996:	4313      	orrs	r3, r2
10041998:	613b      	str	r3, [r7, #16]
1004199a:	e011      	b.n	100419c0 <HAL_GPIO_Init+0x324>
          }
          else
          {
            temp &= ~((1 << position) << 16);
1004199c:	2201      	movs	r2, #1
1004199e:	697b      	ldr	r3, [r7, #20]
100419a0:	409a      	lsls	r2, r3
100419a2:	0013      	movs	r3, r2
100419a4:	041b      	lsls	r3, r3, #16
100419a6:	43db      	mvns	r3, r3
100419a8:	001a      	movs	r2, r3
100419aa:	693b      	ldr	r3, [r7, #16]
100419ac:	4013      	ands	r3, r2
100419ae:	613b      	str	r3, [r7, #16]
            temp |= ((1 << position) << 16);
100419b0:	2201      	movs	r2, #1
100419b2:	697b      	ldr	r3, [r7, #20]
100419b4:	409a      	lsls	r2, r3
100419b6:	0013      	movs	r3, r2
100419b8:	041b      	lsls	r3, r3, #16
100419ba:	693a      	ldr	r2, [r7, #16]
100419bc:	4313      	orrs	r3, r2
100419be:	613b      	str	r3, [r7, #16]
          }
          SYSCFG->IO_IER= temp;
100419c0:	2380      	movs	r3, #128	@ 0x80
100419c2:	05db      	lsls	r3, r3, #23
100419c4:	693a      	ldr	r2, [r7, #16]
100419c6:	619a      	str	r2, [r3, #24]
        }
      }
    }

    position++;
100419c8:	697b      	ldr	r3, [r7, #20]
100419ca:	3301      	adds	r3, #1
100419cc:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
100419ce:	683b      	ldr	r3, [r7, #0]
100419d0:	681a      	ldr	r2, [r3, #0]
100419d2:	697b      	ldr	r3, [r7, #20]
100419d4:	40da      	lsrs	r2, r3
100419d6:	1e13      	subs	r3, r2, #0
100419d8:	d000      	beq.n	100419dc <HAL_GPIO_Init+0x340>
100419da:	e667      	b.n	100416ac <HAL_GPIO_Init+0x10>
  }
}
100419dc:	46c0      	nop			@ (mov r8, r8)
100419de:	46c0      	nop			@ (mov r8, r8)
100419e0:	46bd      	mov	sp, r7
100419e2:	b006      	add	sp, #24
100419e4:	bd80      	pop	{r7, pc}
	...

100419e8 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
100419e8:	b580      	push	{r7, lr}
100419ea:	b082      	sub	sp, #8
100419ec:	af00      	add	r7, sp, #0
100419ee:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
100419f0:	687b      	ldr	r3, [r7, #4]
100419f2:	2b00      	cmp	r3, #0
100419f4:	d101      	bne.n	100419fa <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
100419f6:	2301      	movs	r3, #1
100419f8:	e08f      	b.n	10041b1a <HAL_I2C_Init+0x132>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
100419fa:	687b      	ldr	r3, [r7, #4]
100419fc:	2241      	movs	r2, #65	@ 0x41
100419fe:	5c9b      	ldrb	r3, [r3, r2]
10041a00:	b2db      	uxtb	r3, r3
10041a02:	2b00      	cmp	r3, #0
10041a04:	d107      	bne.n	10041a16 <HAL_I2C_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
10041a06:	687b      	ldr	r3, [r7, #4]
10041a08:	2240      	movs	r2, #64	@ 0x40
10041a0a:	2100      	movs	r1, #0
10041a0c:	5499      	strb	r1, [r3, r2]

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
10041a0e:	687b      	ldr	r3, [r7, #4]
10041a10:	0018      	movs	r0, r3
10041a12:	f7ff faa7 	bl	10040f64 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
10041a16:	687b      	ldr	r3, [r7, #4]
10041a18:	2241      	movs	r2, #65	@ 0x41
10041a1a:	2124      	movs	r1, #36	@ 0x24
10041a1c:	5499      	strb	r1, [r3, r2]

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
10041a1e:	687b      	ldr	r3, [r7, #4]
10041a20:	681b      	ldr	r3, [r3, #0]
10041a22:	681a      	ldr	r2, [r3, #0]
10041a24:	687b      	ldr	r3, [r7, #4]
10041a26:	681b      	ldr	r3, [r3, #0]
10041a28:	2101      	movs	r1, #1
10041a2a:	438a      	bics	r2, r1
10041a2c:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
10041a2e:	687b      	ldr	r3, [r7, #4]
10041a30:	685a      	ldr	r2, [r3, #4]
10041a32:	687b      	ldr	r3, [r7, #4]
10041a34:	681b      	ldr	r3, [r3, #0]
10041a36:	493b      	ldr	r1, [pc, #236]	@ (10041b24 <HAL_I2C_Init+0x13c>)
10041a38:	400a      	ands	r2, r1
10041a3a:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
10041a3c:	687b      	ldr	r3, [r7, #4]
10041a3e:	681b      	ldr	r3, [r3, #0]
10041a40:	689a      	ldr	r2, [r3, #8]
10041a42:	687b      	ldr	r3, [r7, #4]
10041a44:	681b      	ldr	r3, [r3, #0]
10041a46:	4938      	ldr	r1, [pc, #224]	@ (10041b28 <HAL_I2C_Init+0x140>)
10041a48:	400a      	ands	r2, r1
10041a4a:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
10041a4c:	687b      	ldr	r3, [r7, #4]
10041a4e:	68db      	ldr	r3, [r3, #12]
10041a50:	2b01      	cmp	r3, #1
10041a52:	d108      	bne.n	10041a66 <HAL_I2C_Init+0x7e>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
10041a54:	687b      	ldr	r3, [r7, #4]
10041a56:	689a      	ldr	r2, [r3, #8]
10041a58:	687b      	ldr	r3, [r7, #4]
10041a5a:	681b      	ldr	r3, [r3, #0]
10041a5c:	2180      	movs	r1, #128	@ 0x80
10041a5e:	0209      	lsls	r1, r1, #8
10041a60:	430a      	orrs	r2, r1
10041a62:	609a      	str	r2, [r3, #8]
10041a64:	e007      	b.n	10041a76 <HAL_I2C_Init+0x8e>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
10041a66:	687b      	ldr	r3, [r7, #4]
10041a68:	689a      	ldr	r2, [r3, #8]
10041a6a:	687b      	ldr	r3, [r7, #4]
10041a6c:	681b      	ldr	r3, [r3, #0]
10041a6e:	2184      	movs	r1, #132	@ 0x84
10041a70:	0209      	lsls	r1, r1, #8
10041a72:	430a      	orrs	r2, r1
10041a74:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
10041a76:	687b      	ldr	r3, [r7, #4]
10041a78:	68db      	ldr	r3, [r3, #12]
10041a7a:	2b02      	cmp	r3, #2
10041a7c:	d109      	bne.n	10041a92 <HAL_I2C_Init+0xaa>
  {
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
10041a7e:	687b      	ldr	r3, [r7, #4]
10041a80:	681b      	ldr	r3, [r3, #0]
10041a82:	685a      	ldr	r2, [r3, #4]
10041a84:	687b      	ldr	r3, [r7, #4]
10041a86:	681b      	ldr	r3, [r3, #0]
10041a88:	2180      	movs	r1, #128	@ 0x80
10041a8a:	0109      	lsls	r1, r1, #4
10041a8c:	430a      	orrs	r2, r1
10041a8e:	605a      	str	r2, [r3, #4]
10041a90:	e007      	b.n	10041aa2 <HAL_I2C_Init+0xba>
  }
  else
  {
    /* Clear the I2C ADD10 bit */
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
10041a92:	687b      	ldr	r3, [r7, #4]
10041a94:	681b      	ldr	r3, [r3, #0]
10041a96:	685a      	ldr	r2, [r3, #4]
10041a98:	687b      	ldr	r3, [r7, #4]
10041a9a:	681b      	ldr	r3, [r3, #0]
10041a9c:	4923      	ldr	r1, [pc, #140]	@ (10041b2c <HAL_I2C_Init+0x144>)
10041a9e:	400a      	ands	r2, r1
10041aa0:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
10041aa2:	687b      	ldr	r3, [r7, #4]
10041aa4:	681b      	ldr	r3, [r3, #0]
10041aa6:	685a      	ldr	r2, [r3, #4]
10041aa8:	687b      	ldr	r3, [r7, #4]
10041aaa:	681b      	ldr	r3, [r3, #0]
10041aac:	4920      	ldr	r1, [pc, #128]	@ (10041b30 <HAL_I2C_Init+0x148>)
10041aae:	430a      	orrs	r2, r1
10041ab0:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
10041ab2:	687b      	ldr	r3, [r7, #4]
10041ab4:	681b      	ldr	r3, [r3, #0]
10041ab6:	68da      	ldr	r2, [r3, #12]
10041ab8:	687b      	ldr	r3, [r7, #4]
10041aba:	681b      	ldr	r3, [r3, #0]
10041abc:	491a      	ldr	r1, [pc, #104]	@ (10041b28 <HAL_I2C_Init+0x140>)
10041abe:	400a      	ands	r2, r1
10041ac0:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
10041ac2:	687b      	ldr	r3, [r7, #4]
10041ac4:	691a      	ldr	r2, [r3, #16]
10041ac6:	687b      	ldr	r3, [r7, #4]
10041ac8:	695b      	ldr	r3, [r3, #20]
10041aca:	431a      	orrs	r2, r3
10041acc:	0011      	movs	r1, r2
                          (hi2c->Init.OwnAddress2Masks << 8));
10041ace:	687b      	ldr	r3, [r7, #4]
10041ad0:	699b      	ldr	r3, [r3, #24]
10041ad2:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
10041ad4:	687b      	ldr	r3, [r7, #4]
10041ad6:	681b      	ldr	r3, [r3, #0]
10041ad8:	430a      	orrs	r2, r1
10041ada:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
10041adc:	687b      	ldr	r3, [r7, #4]
10041ade:	69d9      	ldr	r1, [r3, #28]
10041ae0:	687b      	ldr	r3, [r7, #4]
10041ae2:	6a1a      	ldr	r2, [r3, #32]
10041ae4:	687b      	ldr	r3, [r7, #4]
10041ae6:	681b      	ldr	r3, [r3, #0]
10041ae8:	430a      	orrs	r2, r1
10041aea:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
10041aec:	687b      	ldr	r3, [r7, #4]
10041aee:	681b      	ldr	r3, [r3, #0]
10041af0:	681a      	ldr	r2, [r3, #0]
10041af2:	687b      	ldr	r3, [r7, #4]
10041af4:	681b      	ldr	r3, [r3, #0]
10041af6:	2101      	movs	r1, #1
10041af8:	430a      	orrs	r2, r1
10041afa:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
10041afc:	687b      	ldr	r3, [r7, #4]
10041afe:	2200      	movs	r2, #0
10041b00:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
10041b02:	687b      	ldr	r3, [r7, #4]
10041b04:	2241      	movs	r2, #65	@ 0x41
10041b06:	2120      	movs	r1, #32
10041b08:	5499      	strb	r1, [r3, r2]
  hi2c->PreviousState = I2C_STATE_NONE;
10041b0a:	687b      	ldr	r3, [r7, #4]
10041b0c:	2200      	movs	r2, #0
10041b0e:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
10041b10:	687b      	ldr	r3, [r7, #4]
10041b12:	2242      	movs	r2, #66	@ 0x42
10041b14:	2100      	movs	r1, #0
10041b16:	5499      	strb	r1, [r3, r2]

  return HAL_OK;
10041b18:	2300      	movs	r3, #0
}
10041b1a:	0018      	movs	r0, r3
10041b1c:	46bd      	mov	sp, r7
10041b1e:	b002      	add	sp, #8
10041b20:	bd80      	pop	{r7, pc}
10041b22:	46c0      	nop			@ (mov r8, r8)
10041b24:	f0ffffff 	.word	0xf0ffffff
10041b28:	ffff7fff 	.word	0xffff7fff
10041b2c:	fffff7ff 	.word	0xfffff7ff
10041b30:	02008000 	.word	0x02008000

10041b34 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
10041b34:	b590      	push	{r4, r7, lr}
10041b36:	b089      	sub	sp, #36	@ 0x24
10041b38:	af02      	add	r7, sp, #8
10041b3a:	60f8      	str	r0, [r7, #12]
10041b3c:	000c      	movs	r4, r1
10041b3e:	0010      	movs	r0, r2
10041b40:	0019      	movs	r1, r3
10041b42:	230a      	movs	r3, #10
10041b44:	18fb      	adds	r3, r7, r3
10041b46:	1c22      	adds	r2, r4, #0
10041b48:	801a      	strh	r2, [r3, #0]
10041b4a:	2308      	movs	r3, #8
10041b4c:	18fb      	adds	r3, r7, r3
10041b4e:	1c02      	adds	r2, r0, #0
10041b50:	801a      	strh	r2, [r3, #0]
10041b52:	1dbb      	adds	r3, r7, #6
10041b54:	1c0a      	adds	r2, r1, #0
10041b56:	801a      	strh	r2, [r3, #0]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
10041b58:	68fb      	ldr	r3, [r7, #12]
10041b5a:	2241      	movs	r2, #65	@ 0x41
10041b5c:	5c9b      	ldrb	r3, [r3, r2]
10041b5e:	b2db      	uxtb	r3, r3
10041b60:	2b20      	cmp	r3, #32
10041b62:	d000      	beq.n	10041b66 <HAL_I2C_Mem_Write+0x32>
10041b64:	e10c      	b.n	10041d80 <HAL_I2C_Mem_Write+0x24c>
  {
    if ((pData == NULL) || (Size == 0U))
10041b66:	6abb      	ldr	r3, [r7, #40]	@ 0x28
10041b68:	2b00      	cmp	r3, #0
10041b6a:	d004      	beq.n	10041b76 <HAL_I2C_Mem_Write+0x42>
10041b6c:	232c      	movs	r3, #44	@ 0x2c
10041b6e:	18fb      	adds	r3, r7, r3
10041b70:	881b      	ldrh	r3, [r3, #0]
10041b72:	2b00      	cmp	r3, #0
10041b74:	d105      	bne.n	10041b82 <HAL_I2C_Mem_Write+0x4e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
10041b76:	68fb      	ldr	r3, [r7, #12]
10041b78:	2280      	movs	r2, #128	@ 0x80
10041b7a:	0092      	lsls	r2, r2, #2
10041b7c:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
10041b7e:	2301      	movs	r3, #1
10041b80:	e0ff      	b.n	10041d82 <HAL_I2C_Mem_Write+0x24e>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
10041b82:	68fb      	ldr	r3, [r7, #12]
10041b84:	2240      	movs	r2, #64	@ 0x40
10041b86:	5c9b      	ldrb	r3, [r3, r2]
10041b88:	2b01      	cmp	r3, #1
10041b8a:	d101      	bne.n	10041b90 <HAL_I2C_Mem_Write+0x5c>
10041b8c:	2302      	movs	r3, #2
10041b8e:	e0f8      	b.n	10041d82 <HAL_I2C_Mem_Write+0x24e>
10041b90:	68fb      	ldr	r3, [r7, #12]
10041b92:	2240      	movs	r2, #64	@ 0x40
10041b94:	2101      	movs	r1, #1
10041b96:	5499      	strb	r1, [r3, r2]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
10041b98:	f7ff fc94 	bl	100414c4 <HAL_GetTick>
10041b9c:	0003      	movs	r3, r0
10041b9e:	617b      	str	r3, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
10041ba0:	2380      	movs	r3, #128	@ 0x80
10041ba2:	0219      	lsls	r1, r3, #8
10041ba4:	68f8      	ldr	r0, [r7, #12]
10041ba6:	697b      	ldr	r3, [r7, #20]
10041ba8:	9300      	str	r3, [sp, #0]
10041baa:	2319      	movs	r3, #25
10041bac:	2201      	movs	r2, #1
10041bae:	f000 fb0b 	bl	100421c8 <I2C_WaitOnFlagUntilTimeout>
10041bb2:	1e03      	subs	r3, r0, #0
10041bb4:	d001      	beq.n	10041bba <HAL_I2C_Mem_Write+0x86>
    {
      return HAL_ERROR;
10041bb6:	2301      	movs	r3, #1
10041bb8:	e0e3      	b.n	10041d82 <HAL_I2C_Mem_Write+0x24e>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
10041bba:	68fb      	ldr	r3, [r7, #12]
10041bbc:	2241      	movs	r2, #65	@ 0x41
10041bbe:	2121      	movs	r1, #33	@ 0x21
10041bc0:	5499      	strb	r1, [r3, r2]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
10041bc2:	68fb      	ldr	r3, [r7, #12]
10041bc4:	2242      	movs	r2, #66	@ 0x42
10041bc6:	2140      	movs	r1, #64	@ 0x40
10041bc8:	5499      	strb	r1, [r3, r2]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
10041bca:	68fb      	ldr	r3, [r7, #12]
10041bcc:	2200      	movs	r2, #0
10041bce:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
10041bd0:	68fb      	ldr	r3, [r7, #12]
10041bd2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
10041bd4:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
10041bd6:	68fb      	ldr	r3, [r7, #12]
10041bd8:	222c      	movs	r2, #44	@ 0x2c
10041bda:	18ba      	adds	r2, r7, r2
10041bdc:	8812      	ldrh	r2, [r2, #0]
10041bde:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
10041be0:	68fb      	ldr	r3, [r7, #12]
10041be2:	2200      	movs	r2, #0
10041be4:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
10041be6:	1dbb      	adds	r3, r7, #6
10041be8:	881c      	ldrh	r4, [r3, #0]
10041bea:	2308      	movs	r3, #8
10041bec:	18fb      	adds	r3, r7, r3
10041bee:	881a      	ldrh	r2, [r3, #0]
10041bf0:	230a      	movs	r3, #10
10041bf2:	18fb      	adds	r3, r7, r3
10041bf4:	8819      	ldrh	r1, [r3, #0]
10041bf6:	68f8      	ldr	r0, [r7, #12]
10041bf8:	697b      	ldr	r3, [r7, #20]
10041bfa:	9301      	str	r3, [sp, #4]
10041bfc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10041bfe:	9300      	str	r3, [sp, #0]
10041c00:	0023      	movs	r3, r4
10041c02:	f000 f9f9 	bl	10041ff8 <I2C_RequestMemoryWrite>
10041c06:	1e03      	subs	r3, r0, #0
10041c08:	d005      	beq.n	10041c16 <HAL_I2C_Mem_Write+0xe2>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
10041c0a:	68fb      	ldr	r3, [r7, #12]
10041c0c:	2240      	movs	r2, #64	@ 0x40
10041c0e:	2100      	movs	r1, #0
10041c10:	5499      	strb	r1, [r3, r2]
      return HAL_ERROR;
10041c12:	2301      	movs	r3, #1
10041c14:	e0b5      	b.n	10041d82 <HAL_I2C_Mem_Write+0x24e>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
10041c16:	68fb      	ldr	r3, [r7, #12]
10041c18:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041c1a:	b29b      	uxth	r3, r3
10041c1c:	2bff      	cmp	r3, #255	@ 0xff
10041c1e:	d911      	bls.n	10041c44 <HAL_I2C_Mem_Write+0x110>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
10041c20:	68fb      	ldr	r3, [r7, #12]
10041c22:	22ff      	movs	r2, #255	@ 0xff
10041c24:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
10041c26:	68fb      	ldr	r3, [r7, #12]
10041c28:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10041c2a:	b2da      	uxtb	r2, r3
10041c2c:	2380      	movs	r3, #128	@ 0x80
10041c2e:	045c      	lsls	r4, r3, #17
10041c30:	230a      	movs	r3, #10
10041c32:	18fb      	adds	r3, r7, r3
10041c34:	8819      	ldrh	r1, [r3, #0]
10041c36:	68f8      	ldr	r0, [r7, #12]
10041c38:	2300      	movs	r3, #0
10041c3a:	9300      	str	r3, [sp, #0]
10041c3c:	0023      	movs	r3, r4
10041c3e:	f000 fc9d 	bl	1004257c <I2C_TransferConfig>
10041c42:	e012      	b.n	10041c6a <HAL_I2C_Mem_Write+0x136>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
10041c44:	68fb      	ldr	r3, [r7, #12]
10041c46:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041c48:	b29a      	uxth	r2, r3
10041c4a:	68fb      	ldr	r3, [r7, #12]
10041c4c:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
10041c4e:	68fb      	ldr	r3, [r7, #12]
10041c50:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10041c52:	b2da      	uxtb	r2, r3
10041c54:	2380      	movs	r3, #128	@ 0x80
10041c56:	049c      	lsls	r4, r3, #18
10041c58:	230a      	movs	r3, #10
10041c5a:	18fb      	adds	r3, r7, r3
10041c5c:	8819      	ldrh	r1, [r3, #0]
10041c5e:	68f8      	ldr	r0, [r7, #12]
10041c60:	2300      	movs	r3, #0
10041c62:	9300      	str	r3, [sp, #0]
10041c64:	0023      	movs	r3, r4
10041c66:	f000 fc89 	bl	1004257c <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
10041c6a:	697a      	ldr	r2, [r7, #20]
10041c6c:	6b39      	ldr	r1, [r7, #48]	@ 0x30
10041c6e:	68fb      	ldr	r3, [r7, #12]
10041c70:	0018      	movs	r0, r3
10041c72:	f000 fb01 	bl	10042278 <I2C_WaitOnTXISFlagUntilTimeout>
10041c76:	1e03      	subs	r3, r0, #0
10041c78:	d001      	beq.n	10041c7e <HAL_I2C_Mem_Write+0x14a>
      {
        return HAL_ERROR;
10041c7a:	2301      	movs	r3, #1
10041c7c:	e081      	b.n	10041d82 <HAL_I2C_Mem_Write+0x24e>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
10041c7e:	68fb      	ldr	r3, [r7, #12]
10041c80:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
10041c82:	781a      	ldrb	r2, [r3, #0]
10041c84:	68fb      	ldr	r3, [r7, #12]
10041c86:	681b      	ldr	r3, [r3, #0]
10041c88:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
10041c8a:	68fb      	ldr	r3, [r7, #12]
10041c8c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
10041c8e:	1c5a      	adds	r2, r3, #1
10041c90:	68fb      	ldr	r3, [r7, #12]
10041c92:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
10041c94:	68fb      	ldr	r3, [r7, #12]
10041c96:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041c98:	b29b      	uxth	r3, r3
10041c9a:	3b01      	subs	r3, #1
10041c9c:	b29a      	uxth	r2, r3
10041c9e:	68fb      	ldr	r3, [r7, #12]
10041ca0:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
10041ca2:	68fb      	ldr	r3, [r7, #12]
10041ca4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10041ca6:	3b01      	subs	r3, #1
10041ca8:	b29a      	uxth	r2, r3
10041caa:	68fb      	ldr	r3, [r7, #12]
10041cac:	851a      	strh	r2, [r3, #40]	@ 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
10041cae:	68fb      	ldr	r3, [r7, #12]
10041cb0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041cb2:	b29b      	uxth	r3, r3
10041cb4:	2b00      	cmp	r3, #0
10041cb6:	d03a      	beq.n	10041d2e <HAL_I2C_Mem_Write+0x1fa>
10041cb8:	68fb      	ldr	r3, [r7, #12]
10041cba:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10041cbc:	2b00      	cmp	r3, #0
10041cbe:	d136      	bne.n	10041d2e <HAL_I2C_Mem_Write+0x1fa>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
10041cc0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10041cc2:	68f8      	ldr	r0, [r7, #12]
10041cc4:	697b      	ldr	r3, [r7, #20]
10041cc6:	9300      	str	r3, [sp, #0]
10041cc8:	0013      	movs	r3, r2
10041cca:	2200      	movs	r2, #0
10041ccc:	2180      	movs	r1, #128	@ 0x80
10041cce:	f000 fa7b 	bl	100421c8 <I2C_WaitOnFlagUntilTimeout>
10041cd2:	1e03      	subs	r3, r0, #0
10041cd4:	d001      	beq.n	10041cda <HAL_I2C_Mem_Write+0x1a6>
        {
          return HAL_ERROR;
10041cd6:	2301      	movs	r3, #1
10041cd8:	e053      	b.n	10041d82 <HAL_I2C_Mem_Write+0x24e>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
10041cda:	68fb      	ldr	r3, [r7, #12]
10041cdc:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041cde:	b29b      	uxth	r3, r3
10041ce0:	2bff      	cmp	r3, #255	@ 0xff
10041ce2:	d911      	bls.n	10041d08 <HAL_I2C_Mem_Write+0x1d4>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
10041ce4:	68fb      	ldr	r3, [r7, #12]
10041ce6:	22ff      	movs	r2, #255	@ 0xff
10041ce8:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
10041cea:	68fb      	ldr	r3, [r7, #12]
10041cec:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10041cee:	b2da      	uxtb	r2, r3
10041cf0:	2380      	movs	r3, #128	@ 0x80
10041cf2:	045c      	lsls	r4, r3, #17
10041cf4:	230a      	movs	r3, #10
10041cf6:	18fb      	adds	r3, r7, r3
10041cf8:	8819      	ldrh	r1, [r3, #0]
10041cfa:	68f8      	ldr	r0, [r7, #12]
10041cfc:	2300      	movs	r3, #0
10041cfe:	9300      	str	r3, [sp, #0]
10041d00:	0023      	movs	r3, r4
10041d02:	f000 fc3b 	bl	1004257c <I2C_TransferConfig>
10041d06:	e012      	b.n	10041d2e <HAL_I2C_Mem_Write+0x1fa>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
10041d08:	68fb      	ldr	r3, [r7, #12]
10041d0a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041d0c:	b29a      	uxth	r2, r3
10041d0e:	68fb      	ldr	r3, [r7, #12]
10041d10:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
10041d12:	68fb      	ldr	r3, [r7, #12]
10041d14:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10041d16:	b2da      	uxtb	r2, r3
10041d18:	2380      	movs	r3, #128	@ 0x80
10041d1a:	049c      	lsls	r4, r3, #18
10041d1c:	230a      	movs	r3, #10
10041d1e:	18fb      	adds	r3, r7, r3
10041d20:	8819      	ldrh	r1, [r3, #0]
10041d22:	68f8      	ldr	r0, [r7, #12]
10041d24:	2300      	movs	r3, #0
10041d26:	9300      	str	r3, [sp, #0]
10041d28:	0023      	movs	r3, r4
10041d2a:	f000 fc27 	bl	1004257c <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
10041d2e:	68fb      	ldr	r3, [r7, #12]
10041d30:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041d32:	b29b      	uxth	r3, r3
10041d34:	2b00      	cmp	r3, #0
10041d36:	d198      	bne.n	10041c6a <HAL_I2C_Mem_Write+0x136>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
10041d38:	697a      	ldr	r2, [r7, #20]
10041d3a:	6b39      	ldr	r1, [r7, #48]	@ 0x30
10041d3c:	68fb      	ldr	r3, [r7, #12]
10041d3e:	0018      	movs	r0, r3
10041d40:	f000 fae0 	bl	10042304 <I2C_WaitOnSTOPFlagUntilTimeout>
10041d44:	1e03      	subs	r3, r0, #0
10041d46:	d001      	beq.n	10041d4c <HAL_I2C_Mem_Write+0x218>
    {
      return HAL_ERROR;
10041d48:	2301      	movs	r3, #1
10041d4a:	e01a      	b.n	10041d82 <HAL_I2C_Mem_Write+0x24e>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
10041d4c:	68fb      	ldr	r3, [r7, #12]
10041d4e:	681b      	ldr	r3, [r3, #0]
10041d50:	2220      	movs	r2, #32
10041d52:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
10041d54:	68fb      	ldr	r3, [r7, #12]
10041d56:	681b      	ldr	r3, [r3, #0]
10041d58:	685a      	ldr	r2, [r3, #4]
10041d5a:	68fb      	ldr	r3, [r7, #12]
10041d5c:	681b      	ldr	r3, [r3, #0]
10041d5e:	490b      	ldr	r1, [pc, #44]	@ (10041d8c <HAL_I2C_Mem_Write+0x258>)
10041d60:	400a      	ands	r2, r1
10041d62:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
10041d64:	68fb      	ldr	r3, [r7, #12]
10041d66:	2241      	movs	r2, #65	@ 0x41
10041d68:	2120      	movs	r1, #32
10041d6a:	5499      	strb	r1, [r3, r2]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
10041d6c:	68fb      	ldr	r3, [r7, #12]
10041d6e:	2242      	movs	r2, #66	@ 0x42
10041d70:	2100      	movs	r1, #0
10041d72:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
10041d74:	68fb      	ldr	r3, [r7, #12]
10041d76:	2240      	movs	r2, #64	@ 0x40
10041d78:	2100      	movs	r1, #0
10041d7a:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
10041d7c:	2300      	movs	r3, #0
10041d7e:	e000      	b.n	10041d82 <HAL_I2C_Mem_Write+0x24e>
  }
  else
  {
    return HAL_BUSY;
10041d80:	2302      	movs	r3, #2
  }
}
10041d82:	0018      	movs	r0, r3
10041d84:	46bd      	mov	sp, r7
10041d86:	b007      	add	sp, #28
10041d88:	bd90      	pop	{r4, r7, pc}
10041d8a:	46c0      	nop			@ (mov r8, r8)
10041d8c:	fe00e800 	.word	0xfe00e800

10041d90 <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
10041d90:	b590      	push	{r4, r7, lr}
10041d92:	b089      	sub	sp, #36	@ 0x24
10041d94:	af02      	add	r7, sp, #8
10041d96:	60f8      	str	r0, [r7, #12]
10041d98:	000c      	movs	r4, r1
10041d9a:	0010      	movs	r0, r2
10041d9c:	0019      	movs	r1, r3
10041d9e:	230a      	movs	r3, #10
10041da0:	18fb      	adds	r3, r7, r3
10041da2:	1c22      	adds	r2, r4, #0
10041da4:	801a      	strh	r2, [r3, #0]
10041da6:	2308      	movs	r3, #8
10041da8:	18fb      	adds	r3, r7, r3
10041daa:	1c02      	adds	r2, r0, #0
10041dac:	801a      	strh	r2, [r3, #0]
10041dae:	1dbb      	adds	r3, r7, #6
10041db0:	1c0a      	adds	r2, r1, #0
10041db2:	801a      	strh	r2, [r3, #0]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
10041db4:	68fb      	ldr	r3, [r7, #12]
10041db6:	2241      	movs	r2, #65	@ 0x41
10041db8:	5c9b      	ldrb	r3, [r3, r2]
10041dba:	b2db      	uxtb	r3, r3
10041dbc:	2b20      	cmp	r3, #32
10041dbe:	d000      	beq.n	10041dc2 <HAL_I2C_Mem_Read+0x32>
10041dc0:	e110      	b.n	10041fe4 <HAL_I2C_Mem_Read+0x254>
  {
    if ((pData == NULL) || (Size == 0U))
10041dc2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
10041dc4:	2b00      	cmp	r3, #0
10041dc6:	d004      	beq.n	10041dd2 <HAL_I2C_Mem_Read+0x42>
10041dc8:	232c      	movs	r3, #44	@ 0x2c
10041dca:	18fb      	adds	r3, r7, r3
10041dcc:	881b      	ldrh	r3, [r3, #0]
10041dce:	2b00      	cmp	r3, #0
10041dd0:	d105      	bne.n	10041dde <HAL_I2C_Mem_Read+0x4e>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
10041dd2:	68fb      	ldr	r3, [r7, #12]
10041dd4:	2280      	movs	r2, #128	@ 0x80
10041dd6:	0092      	lsls	r2, r2, #2
10041dd8:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
10041dda:	2301      	movs	r3, #1
10041ddc:	e103      	b.n	10041fe6 <HAL_I2C_Mem_Read+0x256>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
10041dde:	68fb      	ldr	r3, [r7, #12]
10041de0:	2240      	movs	r2, #64	@ 0x40
10041de2:	5c9b      	ldrb	r3, [r3, r2]
10041de4:	2b01      	cmp	r3, #1
10041de6:	d101      	bne.n	10041dec <HAL_I2C_Mem_Read+0x5c>
10041de8:	2302      	movs	r3, #2
10041dea:	e0fc      	b.n	10041fe6 <HAL_I2C_Mem_Read+0x256>
10041dec:	68fb      	ldr	r3, [r7, #12]
10041dee:	2240      	movs	r2, #64	@ 0x40
10041df0:	2101      	movs	r1, #1
10041df2:	5499      	strb	r1, [r3, r2]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
10041df4:	f7ff fb66 	bl	100414c4 <HAL_GetTick>
10041df8:	0003      	movs	r3, r0
10041dfa:	617b      	str	r3, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
10041dfc:	2380      	movs	r3, #128	@ 0x80
10041dfe:	0219      	lsls	r1, r3, #8
10041e00:	68f8      	ldr	r0, [r7, #12]
10041e02:	697b      	ldr	r3, [r7, #20]
10041e04:	9300      	str	r3, [sp, #0]
10041e06:	2319      	movs	r3, #25
10041e08:	2201      	movs	r2, #1
10041e0a:	f000 f9dd 	bl	100421c8 <I2C_WaitOnFlagUntilTimeout>
10041e0e:	1e03      	subs	r3, r0, #0
10041e10:	d001      	beq.n	10041e16 <HAL_I2C_Mem_Read+0x86>
    {
      return HAL_ERROR;
10041e12:	2301      	movs	r3, #1
10041e14:	e0e7      	b.n	10041fe6 <HAL_I2C_Mem_Read+0x256>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
10041e16:	68fb      	ldr	r3, [r7, #12]
10041e18:	2241      	movs	r2, #65	@ 0x41
10041e1a:	2122      	movs	r1, #34	@ 0x22
10041e1c:	5499      	strb	r1, [r3, r2]
    hi2c->Mode      = HAL_I2C_MODE_MEM;
10041e1e:	68fb      	ldr	r3, [r7, #12]
10041e20:	2242      	movs	r2, #66	@ 0x42
10041e22:	2140      	movs	r1, #64	@ 0x40
10041e24:	5499      	strb	r1, [r3, r2]
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
10041e26:	68fb      	ldr	r3, [r7, #12]
10041e28:	2200      	movs	r2, #0
10041e2a:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
10041e2c:	68fb      	ldr	r3, [r7, #12]
10041e2e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
10041e30:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
10041e32:	68fb      	ldr	r3, [r7, #12]
10041e34:	222c      	movs	r2, #44	@ 0x2c
10041e36:	18ba      	adds	r2, r7, r2
10041e38:	8812      	ldrh	r2, [r2, #0]
10041e3a:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
10041e3c:	68fb      	ldr	r3, [r7, #12]
10041e3e:	2200      	movs	r2, #0
10041e40:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
10041e42:	1dbb      	adds	r3, r7, #6
10041e44:	881c      	ldrh	r4, [r3, #0]
10041e46:	2308      	movs	r3, #8
10041e48:	18fb      	adds	r3, r7, r3
10041e4a:	881a      	ldrh	r2, [r3, #0]
10041e4c:	230a      	movs	r3, #10
10041e4e:	18fb      	adds	r3, r7, r3
10041e50:	8819      	ldrh	r1, [r3, #0]
10041e52:	68f8      	ldr	r0, [r7, #12]
10041e54:	697b      	ldr	r3, [r7, #20]
10041e56:	9301      	str	r3, [sp, #4]
10041e58:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
10041e5a:	9300      	str	r3, [sp, #0]
10041e5c:	0023      	movs	r3, r4
10041e5e:	f000 f92f 	bl	100420c0 <I2C_RequestMemoryRead>
10041e62:	1e03      	subs	r3, r0, #0
10041e64:	d005      	beq.n	10041e72 <HAL_I2C_Mem_Read+0xe2>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
10041e66:	68fb      	ldr	r3, [r7, #12]
10041e68:	2240      	movs	r2, #64	@ 0x40
10041e6a:	2100      	movs	r1, #0
10041e6c:	5499      	strb	r1, [r3, r2]
      return HAL_ERROR;
10041e6e:	2301      	movs	r3, #1
10041e70:	e0b9      	b.n	10041fe6 <HAL_I2C_Mem_Read+0x256>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
10041e72:	68fb      	ldr	r3, [r7, #12]
10041e74:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041e76:	b29b      	uxth	r3, r3
10041e78:	2bff      	cmp	r3, #255	@ 0xff
10041e7a:	d911      	bls.n	10041ea0 <HAL_I2C_Mem_Read+0x110>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
10041e7c:	68fb      	ldr	r3, [r7, #12]
10041e7e:	22ff      	movs	r2, #255	@ 0xff
10041e80:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
10041e82:	68fb      	ldr	r3, [r7, #12]
10041e84:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10041e86:	b2da      	uxtb	r2, r3
10041e88:	2380      	movs	r3, #128	@ 0x80
10041e8a:	045c      	lsls	r4, r3, #17
10041e8c:	230a      	movs	r3, #10
10041e8e:	18fb      	adds	r3, r7, r3
10041e90:	8819      	ldrh	r1, [r3, #0]
10041e92:	68f8      	ldr	r0, [r7, #12]
10041e94:	4b56      	ldr	r3, [pc, #344]	@ (10041ff0 <HAL_I2C_Mem_Read+0x260>)
10041e96:	9300      	str	r3, [sp, #0]
10041e98:	0023      	movs	r3, r4
10041e9a:	f000 fb6f 	bl	1004257c <I2C_TransferConfig>
10041e9e:	e012      	b.n	10041ec6 <HAL_I2C_Mem_Read+0x136>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
10041ea0:	68fb      	ldr	r3, [r7, #12]
10041ea2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041ea4:	b29a      	uxth	r2, r3
10041ea6:	68fb      	ldr	r3, [r7, #12]
10041ea8:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
10041eaa:	68fb      	ldr	r3, [r7, #12]
10041eac:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10041eae:	b2da      	uxtb	r2, r3
10041eb0:	2380      	movs	r3, #128	@ 0x80
10041eb2:	049c      	lsls	r4, r3, #18
10041eb4:	230a      	movs	r3, #10
10041eb6:	18fb      	adds	r3, r7, r3
10041eb8:	8819      	ldrh	r1, [r3, #0]
10041eba:	68f8      	ldr	r0, [r7, #12]
10041ebc:	4b4c      	ldr	r3, [pc, #304]	@ (10041ff0 <HAL_I2C_Mem_Read+0x260>)
10041ebe:	9300      	str	r3, [sp, #0]
10041ec0:	0023      	movs	r3, r4
10041ec2:	f000 fb5b 	bl	1004257c <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
10041ec6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10041ec8:	68f8      	ldr	r0, [r7, #12]
10041eca:	697b      	ldr	r3, [r7, #20]
10041ecc:	9300      	str	r3, [sp, #0]
10041ece:	0013      	movs	r3, r2
10041ed0:	2200      	movs	r2, #0
10041ed2:	2104      	movs	r1, #4
10041ed4:	f000 f978 	bl	100421c8 <I2C_WaitOnFlagUntilTimeout>
10041ed8:	1e03      	subs	r3, r0, #0
10041eda:	d001      	beq.n	10041ee0 <HAL_I2C_Mem_Read+0x150>
      {
        return HAL_ERROR;
10041edc:	2301      	movs	r3, #1
10041ede:	e082      	b.n	10041fe6 <HAL_I2C_Mem_Read+0x256>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
10041ee0:	68fb      	ldr	r3, [r7, #12]
10041ee2:	681b      	ldr	r3, [r3, #0]
10041ee4:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
10041ee6:	68fb      	ldr	r3, [r7, #12]
10041ee8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
10041eea:	b2d2      	uxtb	r2, r2
10041eec:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
10041eee:	68fb      	ldr	r3, [r7, #12]
10041ef0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
10041ef2:	1c5a      	adds	r2, r3, #1
10041ef4:	68fb      	ldr	r3, [r7, #12]
10041ef6:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferSize--;
10041ef8:	68fb      	ldr	r3, [r7, #12]
10041efa:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10041efc:	3b01      	subs	r3, #1
10041efe:	b29a      	uxth	r2, r3
10041f00:	68fb      	ldr	r3, [r7, #12]
10041f02:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
10041f04:	68fb      	ldr	r3, [r7, #12]
10041f06:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041f08:	b29b      	uxth	r3, r3
10041f0a:	3b01      	subs	r3, #1
10041f0c:	b29a      	uxth	r2, r3
10041f0e:	68fb      	ldr	r3, [r7, #12]
10041f10:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
10041f12:	68fb      	ldr	r3, [r7, #12]
10041f14:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041f16:	b29b      	uxth	r3, r3
10041f18:	2b00      	cmp	r3, #0
10041f1a:	d03a      	beq.n	10041f92 <HAL_I2C_Mem_Read+0x202>
10041f1c:	68fb      	ldr	r3, [r7, #12]
10041f1e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10041f20:	2b00      	cmp	r3, #0
10041f22:	d136      	bne.n	10041f92 <HAL_I2C_Mem_Read+0x202>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
10041f24:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
10041f26:	68f8      	ldr	r0, [r7, #12]
10041f28:	697b      	ldr	r3, [r7, #20]
10041f2a:	9300      	str	r3, [sp, #0]
10041f2c:	0013      	movs	r3, r2
10041f2e:	2200      	movs	r2, #0
10041f30:	2180      	movs	r1, #128	@ 0x80
10041f32:	f000 f949 	bl	100421c8 <I2C_WaitOnFlagUntilTimeout>
10041f36:	1e03      	subs	r3, r0, #0
10041f38:	d001      	beq.n	10041f3e <HAL_I2C_Mem_Read+0x1ae>
        {
          return HAL_ERROR;
10041f3a:	2301      	movs	r3, #1
10041f3c:	e053      	b.n	10041fe6 <HAL_I2C_Mem_Read+0x256>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
10041f3e:	68fb      	ldr	r3, [r7, #12]
10041f40:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041f42:	b29b      	uxth	r3, r3
10041f44:	2bff      	cmp	r3, #255	@ 0xff
10041f46:	d911      	bls.n	10041f6c <HAL_I2C_Mem_Read+0x1dc>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
10041f48:	68fb      	ldr	r3, [r7, #12]
10041f4a:	22ff      	movs	r2, #255	@ 0xff
10041f4c:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
10041f4e:	68fb      	ldr	r3, [r7, #12]
10041f50:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10041f52:	b2da      	uxtb	r2, r3
10041f54:	2380      	movs	r3, #128	@ 0x80
10041f56:	045c      	lsls	r4, r3, #17
10041f58:	230a      	movs	r3, #10
10041f5a:	18fb      	adds	r3, r7, r3
10041f5c:	8819      	ldrh	r1, [r3, #0]
10041f5e:	68f8      	ldr	r0, [r7, #12]
10041f60:	2300      	movs	r3, #0
10041f62:	9300      	str	r3, [sp, #0]
10041f64:	0023      	movs	r3, r4
10041f66:	f000 fb09 	bl	1004257c <I2C_TransferConfig>
10041f6a:	e012      	b.n	10041f92 <HAL_I2C_Mem_Read+0x202>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
10041f6c:	68fb      	ldr	r3, [r7, #12]
10041f6e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041f70:	b29a      	uxth	r2, r3
10041f72:	68fb      	ldr	r3, [r7, #12]
10041f74:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
10041f76:	68fb      	ldr	r3, [r7, #12]
10041f78:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
10041f7a:	b2da      	uxtb	r2, r3
10041f7c:	2380      	movs	r3, #128	@ 0x80
10041f7e:	049c      	lsls	r4, r3, #18
10041f80:	230a      	movs	r3, #10
10041f82:	18fb      	adds	r3, r7, r3
10041f84:	8819      	ldrh	r1, [r3, #0]
10041f86:	68f8      	ldr	r0, [r7, #12]
10041f88:	2300      	movs	r3, #0
10041f8a:	9300      	str	r3, [sp, #0]
10041f8c:	0023      	movs	r3, r4
10041f8e:	f000 faf5 	bl	1004257c <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }
    } while (hi2c->XferCount > 0U);
10041f92:	68fb      	ldr	r3, [r7, #12]
10041f94:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
10041f96:	b29b      	uxth	r3, r3
10041f98:	2b00      	cmp	r3, #0
10041f9a:	d194      	bne.n	10041ec6 <HAL_I2C_Mem_Read+0x136>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
10041f9c:	697a      	ldr	r2, [r7, #20]
10041f9e:	6b39      	ldr	r1, [r7, #48]	@ 0x30
10041fa0:	68fb      	ldr	r3, [r7, #12]
10041fa2:	0018      	movs	r0, r3
10041fa4:	f000 f9ae 	bl	10042304 <I2C_WaitOnSTOPFlagUntilTimeout>
10041fa8:	1e03      	subs	r3, r0, #0
10041faa:	d001      	beq.n	10041fb0 <HAL_I2C_Mem_Read+0x220>
    {
      return HAL_ERROR;
10041fac:	2301      	movs	r3, #1
10041fae:	e01a      	b.n	10041fe6 <HAL_I2C_Mem_Read+0x256>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
10041fb0:	68fb      	ldr	r3, [r7, #12]
10041fb2:	681b      	ldr	r3, [r3, #0]
10041fb4:	2220      	movs	r2, #32
10041fb6:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
10041fb8:	68fb      	ldr	r3, [r7, #12]
10041fba:	681b      	ldr	r3, [r3, #0]
10041fbc:	685a      	ldr	r2, [r3, #4]
10041fbe:	68fb      	ldr	r3, [r7, #12]
10041fc0:	681b      	ldr	r3, [r3, #0]
10041fc2:	490c      	ldr	r1, [pc, #48]	@ (10041ff4 <HAL_I2C_Mem_Read+0x264>)
10041fc4:	400a      	ands	r2, r1
10041fc6:	605a      	str	r2, [r3, #4]

    hi2c->State = HAL_I2C_STATE_READY;
10041fc8:	68fb      	ldr	r3, [r7, #12]
10041fca:	2241      	movs	r2, #65	@ 0x41
10041fcc:	2120      	movs	r1, #32
10041fce:	5499      	strb	r1, [r3, r2]
    hi2c->Mode  = HAL_I2C_MODE_NONE;
10041fd0:	68fb      	ldr	r3, [r7, #12]
10041fd2:	2242      	movs	r2, #66	@ 0x42
10041fd4:	2100      	movs	r1, #0
10041fd6:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
10041fd8:	68fb      	ldr	r3, [r7, #12]
10041fda:	2240      	movs	r2, #64	@ 0x40
10041fdc:	2100      	movs	r1, #0
10041fde:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
10041fe0:	2300      	movs	r3, #0
10041fe2:	e000      	b.n	10041fe6 <HAL_I2C_Mem_Read+0x256>
  }
  else
  {
    return HAL_BUSY;
10041fe4:	2302      	movs	r3, #2
  }
}
10041fe6:	0018      	movs	r0, r3
10041fe8:	46bd      	mov	sp, r7
10041fea:	b007      	add	sp, #28
10041fec:	bd90      	pop	{r4, r7, pc}
10041fee:	46c0      	nop			@ (mov r8, r8)
10041ff0:	80002400 	.word	0x80002400
10041ff4:	fe00e800 	.word	0xfe00e800

10041ff8 <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
10041ff8:	b5b0      	push	{r4, r5, r7, lr}
10041ffa:	b086      	sub	sp, #24
10041ffc:	af02      	add	r7, sp, #8
10041ffe:	60f8      	str	r0, [r7, #12]
10042000:	000c      	movs	r4, r1
10042002:	0010      	movs	r0, r2
10042004:	0019      	movs	r1, r3
10042006:	250a      	movs	r5, #10
10042008:	197b      	adds	r3, r7, r5
1004200a:	1c22      	adds	r2, r4, #0
1004200c:	801a      	strh	r2, [r3, #0]
1004200e:	2308      	movs	r3, #8
10042010:	18fb      	adds	r3, r7, r3
10042012:	1c02      	adds	r2, r0, #0
10042014:	801a      	strh	r2, [r3, #0]
10042016:	1dbb      	adds	r3, r7, #6
10042018:	1c0a      	adds	r2, r1, #0
1004201a:	801a      	strh	r2, [r3, #0]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
1004201c:	1dbb      	adds	r3, r7, #6
1004201e:	881b      	ldrh	r3, [r3, #0]
10042020:	b2da      	uxtb	r2, r3
10042022:	2380      	movs	r3, #128	@ 0x80
10042024:	045c      	lsls	r4, r3, #17
10042026:	197b      	adds	r3, r7, r5
10042028:	8819      	ldrh	r1, [r3, #0]
1004202a:	68f8      	ldr	r0, [r7, #12]
1004202c:	4b23      	ldr	r3, [pc, #140]	@ (100420bc <I2C_RequestMemoryWrite+0xc4>)
1004202e:	9300      	str	r3, [sp, #0]
10042030:	0023      	movs	r3, r4
10042032:	f000 faa3 	bl	1004257c <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
10042036:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
10042038:	6a39      	ldr	r1, [r7, #32]
1004203a:	68fb      	ldr	r3, [r7, #12]
1004203c:	0018      	movs	r0, r3
1004203e:	f000 f91b 	bl	10042278 <I2C_WaitOnTXISFlagUntilTimeout>
10042042:	1e03      	subs	r3, r0, #0
10042044:	d001      	beq.n	1004204a <I2C_RequestMemoryWrite+0x52>
  {
    return HAL_ERROR;
10042046:	2301      	movs	r3, #1
10042048:	e033      	b.n	100420b2 <I2C_RequestMemoryWrite+0xba>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
1004204a:	1dbb      	adds	r3, r7, #6
1004204c:	881b      	ldrh	r3, [r3, #0]
1004204e:	2b01      	cmp	r3, #1
10042050:	d107      	bne.n	10042062 <I2C_RequestMemoryWrite+0x6a>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
10042052:	2308      	movs	r3, #8
10042054:	18fb      	adds	r3, r7, r3
10042056:	881b      	ldrh	r3, [r3, #0]
10042058:	b2da      	uxtb	r2, r3
1004205a:	68fb      	ldr	r3, [r7, #12]
1004205c:	681b      	ldr	r3, [r3, #0]
1004205e:	629a      	str	r2, [r3, #40]	@ 0x28
10042060:	e019      	b.n	10042096 <I2C_RequestMemoryWrite+0x9e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
10042062:	2308      	movs	r3, #8
10042064:	18fb      	adds	r3, r7, r3
10042066:	881b      	ldrh	r3, [r3, #0]
10042068:	0a1b      	lsrs	r3, r3, #8
1004206a:	b29b      	uxth	r3, r3
1004206c:	b2da      	uxtb	r2, r3
1004206e:	68fb      	ldr	r3, [r7, #12]
10042070:	681b      	ldr	r3, [r3, #0]
10042072:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
10042074:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
10042076:	6a39      	ldr	r1, [r7, #32]
10042078:	68fb      	ldr	r3, [r7, #12]
1004207a:	0018      	movs	r0, r3
1004207c:	f000 f8fc 	bl	10042278 <I2C_WaitOnTXISFlagUntilTimeout>
10042080:	1e03      	subs	r3, r0, #0
10042082:	d001      	beq.n	10042088 <I2C_RequestMemoryWrite+0x90>
    {
      return HAL_ERROR;
10042084:	2301      	movs	r3, #1
10042086:	e014      	b.n	100420b2 <I2C_RequestMemoryWrite+0xba>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
10042088:	2308      	movs	r3, #8
1004208a:	18fb      	adds	r3, r7, r3
1004208c:	881b      	ldrh	r3, [r3, #0]
1004208e:	b2da      	uxtb	r2, r3
10042090:	68fb      	ldr	r3, [r7, #12]
10042092:	681b      	ldr	r3, [r3, #0]
10042094:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
10042096:	6a3a      	ldr	r2, [r7, #32]
10042098:	68f8      	ldr	r0, [r7, #12]
1004209a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
1004209c:	9300      	str	r3, [sp, #0]
1004209e:	0013      	movs	r3, r2
100420a0:	2200      	movs	r2, #0
100420a2:	2180      	movs	r1, #128	@ 0x80
100420a4:	f000 f890 	bl	100421c8 <I2C_WaitOnFlagUntilTimeout>
100420a8:	1e03      	subs	r3, r0, #0
100420aa:	d001      	beq.n	100420b0 <I2C_RequestMemoryWrite+0xb8>
  {
    return HAL_ERROR;
100420ac:	2301      	movs	r3, #1
100420ae:	e000      	b.n	100420b2 <I2C_RequestMemoryWrite+0xba>
  }

  return HAL_OK;
100420b0:	2300      	movs	r3, #0
}
100420b2:	0018      	movs	r0, r3
100420b4:	46bd      	mov	sp, r7
100420b6:	b004      	add	sp, #16
100420b8:	bdb0      	pop	{r4, r5, r7, pc}
100420ba:	46c0      	nop			@ (mov r8, r8)
100420bc:	80002000 	.word	0x80002000

100420c0 <I2C_RequestMemoryRead>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                               uint32_t Tickstart)
{
100420c0:	b5b0      	push	{r4, r5, r7, lr}
100420c2:	b086      	sub	sp, #24
100420c4:	af02      	add	r7, sp, #8
100420c6:	60f8      	str	r0, [r7, #12]
100420c8:	000c      	movs	r4, r1
100420ca:	0010      	movs	r0, r2
100420cc:	0019      	movs	r1, r3
100420ce:	250a      	movs	r5, #10
100420d0:	197b      	adds	r3, r7, r5
100420d2:	1c22      	adds	r2, r4, #0
100420d4:	801a      	strh	r2, [r3, #0]
100420d6:	2308      	movs	r3, #8
100420d8:	18fb      	adds	r3, r7, r3
100420da:	1c02      	adds	r2, r0, #0
100420dc:	801a      	strh	r2, [r3, #0]
100420de:	1dbb      	adds	r3, r7, #6
100420e0:	1c0a      	adds	r2, r1, #0
100420e2:	801a      	strh	r2, [r3, #0]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
100420e4:	1dbb      	adds	r3, r7, #6
100420e6:	881b      	ldrh	r3, [r3, #0]
100420e8:	b2da      	uxtb	r2, r3
100420ea:	197b      	adds	r3, r7, r5
100420ec:	8819      	ldrh	r1, [r3, #0]
100420ee:	68f8      	ldr	r0, [r7, #12]
100420f0:	4b23      	ldr	r3, [pc, #140]	@ (10042180 <I2C_RequestMemoryRead+0xc0>)
100420f2:	9300      	str	r3, [sp, #0]
100420f4:	2300      	movs	r3, #0
100420f6:	f000 fa41 	bl	1004257c <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
100420fa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
100420fc:	6a39      	ldr	r1, [r7, #32]
100420fe:	68fb      	ldr	r3, [r7, #12]
10042100:	0018      	movs	r0, r3
10042102:	f000 f8b9 	bl	10042278 <I2C_WaitOnTXISFlagUntilTimeout>
10042106:	1e03      	subs	r3, r0, #0
10042108:	d001      	beq.n	1004210e <I2C_RequestMemoryRead+0x4e>
  {
    return HAL_ERROR;
1004210a:	2301      	movs	r3, #1
1004210c:	e033      	b.n	10042176 <I2C_RequestMemoryRead+0xb6>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
1004210e:	1dbb      	adds	r3, r7, #6
10042110:	881b      	ldrh	r3, [r3, #0]
10042112:	2b01      	cmp	r3, #1
10042114:	d107      	bne.n	10042126 <I2C_RequestMemoryRead+0x66>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
10042116:	2308      	movs	r3, #8
10042118:	18fb      	adds	r3, r7, r3
1004211a:	881b      	ldrh	r3, [r3, #0]
1004211c:	b2da      	uxtb	r2, r3
1004211e:	68fb      	ldr	r3, [r7, #12]
10042120:	681b      	ldr	r3, [r3, #0]
10042122:	629a      	str	r2, [r3, #40]	@ 0x28
10042124:	e019      	b.n	1004215a <I2C_RequestMemoryRead+0x9a>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
10042126:	2308      	movs	r3, #8
10042128:	18fb      	adds	r3, r7, r3
1004212a:	881b      	ldrh	r3, [r3, #0]
1004212c:	0a1b      	lsrs	r3, r3, #8
1004212e:	b29b      	uxth	r3, r3
10042130:	b2da      	uxtb	r2, r3
10042132:	68fb      	ldr	r3, [r7, #12]
10042134:	681b      	ldr	r3, [r3, #0]
10042136:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
10042138:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
1004213a:	6a39      	ldr	r1, [r7, #32]
1004213c:	68fb      	ldr	r3, [r7, #12]
1004213e:	0018      	movs	r0, r3
10042140:	f000 f89a 	bl	10042278 <I2C_WaitOnTXISFlagUntilTimeout>
10042144:	1e03      	subs	r3, r0, #0
10042146:	d001      	beq.n	1004214c <I2C_RequestMemoryRead+0x8c>
    {
      return HAL_ERROR;
10042148:	2301      	movs	r3, #1
1004214a:	e014      	b.n	10042176 <I2C_RequestMemoryRead+0xb6>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
1004214c:	2308      	movs	r3, #8
1004214e:	18fb      	adds	r3, r7, r3
10042150:	881b      	ldrh	r3, [r3, #0]
10042152:	b2da      	uxtb	r2, r3
10042154:	68fb      	ldr	r3, [r7, #12]
10042156:	681b      	ldr	r3, [r3, #0]
10042158:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
1004215a:	6a3a      	ldr	r2, [r7, #32]
1004215c:	68f8      	ldr	r0, [r7, #12]
1004215e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
10042160:	9300      	str	r3, [sp, #0]
10042162:	0013      	movs	r3, r2
10042164:	2200      	movs	r2, #0
10042166:	2140      	movs	r1, #64	@ 0x40
10042168:	f000 f82e 	bl	100421c8 <I2C_WaitOnFlagUntilTimeout>
1004216c:	1e03      	subs	r3, r0, #0
1004216e:	d001      	beq.n	10042174 <I2C_RequestMemoryRead+0xb4>
  {
    return HAL_ERROR;
10042170:	2301      	movs	r3, #1
10042172:	e000      	b.n	10042176 <I2C_RequestMemoryRead+0xb6>
  }

  return HAL_OK;
10042174:	2300      	movs	r3, #0
}
10042176:	0018      	movs	r0, r3
10042178:	46bd      	mov	sp, r7
1004217a:	b004      	add	sp, #16
1004217c:	bdb0      	pop	{r4, r5, r7, pc}
1004217e:	46c0      	nop			@ (mov r8, r8)
10042180:	80002000 	.word	0x80002000

10042184 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
10042184:	b580      	push	{r7, lr}
10042186:	b082      	sub	sp, #8
10042188:	af00      	add	r7, sp, #0
1004218a:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
1004218c:	687b      	ldr	r3, [r7, #4]
1004218e:	681b      	ldr	r3, [r3, #0]
10042190:	699b      	ldr	r3, [r3, #24]
10042192:	2202      	movs	r2, #2
10042194:	4013      	ands	r3, r2
10042196:	2b02      	cmp	r3, #2
10042198:	d103      	bne.n	100421a2 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
1004219a:	687b      	ldr	r3, [r7, #4]
1004219c:	681b      	ldr	r3, [r3, #0]
1004219e:	2200      	movs	r2, #0
100421a0:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
100421a2:	687b      	ldr	r3, [r7, #4]
100421a4:	681b      	ldr	r3, [r3, #0]
100421a6:	699b      	ldr	r3, [r3, #24]
100421a8:	2201      	movs	r2, #1
100421aa:	4013      	ands	r3, r2
100421ac:	2b01      	cmp	r3, #1
100421ae:	d007      	beq.n	100421c0 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
100421b0:	687b      	ldr	r3, [r7, #4]
100421b2:	681b      	ldr	r3, [r3, #0]
100421b4:	699a      	ldr	r2, [r3, #24]
100421b6:	687b      	ldr	r3, [r7, #4]
100421b8:	681b      	ldr	r3, [r3, #0]
100421ba:	2101      	movs	r1, #1
100421bc:	430a      	orrs	r2, r1
100421be:	619a      	str	r2, [r3, #24]
  }
}
100421c0:	46c0      	nop			@ (mov r8, r8)
100421c2:	46bd      	mov	sp, r7
100421c4:	b002      	add	sp, #8
100421c6:	bd80      	pop	{r7, pc}

100421c8 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
100421c8:	b580      	push	{r7, lr}
100421ca:	b084      	sub	sp, #16
100421cc:	af00      	add	r7, sp, #0
100421ce:	60f8      	str	r0, [r7, #12]
100421d0:	60b9      	str	r1, [r7, #8]
100421d2:	603b      	str	r3, [r7, #0]
100421d4:	1dfb      	adds	r3, r7, #7
100421d6:	701a      	strb	r2, [r3, #0]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
100421d8:	e03a      	b.n	10042250 <I2C_WaitOnFlagUntilTimeout+0x88>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
100421da:	69ba      	ldr	r2, [r7, #24]
100421dc:	6839      	ldr	r1, [r7, #0]
100421de:	68fb      	ldr	r3, [r7, #12]
100421e0:	0018      	movs	r0, r3
100421e2:	f000 f8d3 	bl	1004238c <I2C_IsErrorOccurred>
100421e6:	1e03      	subs	r3, r0, #0
100421e8:	d001      	beq.n	100421ee <I2C_WaitOnFlagUntilTimeout+0x26>
    {
      return HAL_ERROR;
100421ea:	2301      	movs	r3, #1
100421ec:	e040      	b.n	10042270 <I2C_WaitOnFlagUntilTimeout+0xa8>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
100421ee:	683b      	ldr	r3, [r7, #0]
100421f0:	3301      	adds	r3, #1
100421f2:	d02d      	beq.n	10042250 <I2C_WaitOnFlagUntilTimeout+0x88>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
100421f4:	f7ff f966 	bl	100414c4 <HAL_GetTick>
100421f8:	0002      	movs	r2, r0
100421fa:	69bb      	ldr	r3, [r7, #24]
100421fc:	1ad3      	subs	r3, r2, r3
100421fe:	683a      	ldr	r2, [r7, #0]
10042200:	429a      	cmp	r2, r3
10042202:	d302      	bcc.n	1004220a <I2C_WaitOnFlagUntilTimeout+0x42>
10042204:	683b      	ldr	r3, [r7, #0]
10042206:	2b00      	cmp	r3, #0
10042208:	d122      	bne.n	10042250 <I2C_WaitOnFlagUntilTimeout+0x88>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
1004220a:	68fb      	ldr	r3, [r7, #12]
1004220c:	681b      	ldr	r3, [r3, #0]
1004220e:	699b      	ldr	r3, [r3, #24]
10042210:	68ba      	ldr	r2, [r7, #8]
10042212:	4013      	ands	r3, r2
10042214:	68ba      	ldr	r2, [r7, #8]
10042216:	1ad3      	subs	r3, r2, r3
10042218:	425a      	negs	r2, r3
1004221a:	4153      	adcs	r3, r2
1004221c:	b2db      	uxtb	r3, r3
1004221e:	001a      	movs	r2, r3
10042220:	1dfb      	adds	r3, r7, #7
10042222:	781b      	ldrb	r3, [r3, #0]
10042224:	429a      	cmp	r2, r3
10042226:	d113      	bne.n	10042250 <I2C_WaitOnFlagUntilTimeout+0x88>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
10042228:	68fb      	ldr	r3, [r7, #12]
1004222a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
1004222c:	2220      	movs	r2, #32
1004222e:	431a      	orrs	r2, r3
10042230:	68fb      	ldr	r3, [r7, #12]
10042232:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
10042234:	68fb      	ldr	r3, [r7, #12]
10042236:	2241      	movs	r2, #65	@ 0x41
10042238:	2120      	movs	r1, #32
1004223a:	5499      	strb	r1, [r3, r2]
          hi2c->Mode = HAL_I2C_MODE_NONE;
1004223c:	68fb      	ldr	r3, [r7, #12]
1004223e:	2242      	movs	r2, #66	@ 0x42
10042240:	2100      	movs	r1, #0
10042242:	5499      	strb	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
10042244:	68fb      	ldr	r3, [r7, #12]
10042246:	2240      	movs	r2, #64	@ 0x40
10042248:	2100      	movs	r1, #0
1004224a:	5499      	strb	r1, [r3, r2]
          return HAL_ERROR;
1004224c:	2301      	movs	r3, #1
1004224e:	e00f      	b.n	10042270 <I2C_WaitOnFlagUntilTimeout+0xa8>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
10042250:	68fb      	ldr	r3, [r7, #12]
10042252:	681b      	ldr	r3, [r3, #0]
10042254:	699b      	ldr	r3, [r3, #24]
10042256:	68ba      	ldr	r2, [r7, #8]
10042258:	4013      	ands	r3, r2
1004225a:	68ba      	ldr	r2, [r7, #8]
1004225c:	1ad3      	subs	r3, r2, r3
1004225e:	425a      	negs	r2, r3
10042260:	4153      	adcs	r3, r2
10042262:	b2db      	uxtb	r3, r3
10042264:	001a      	movs	r2, r3
10042266:	1dfb      	adds	r3, r7, #7
10042268:	781b      	ldrb	r3, [r3, #0]
1004226a:	429a      	cmp	r2, r3
1004226c:	d0b5      	beq.n	100421da <I2C_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
1004226e:	2300      	movs	r3, #0
}
10042270:	0018      	movs	r0, r3
10042272:	46bd      	mov	sp, r7
10042274:	b004      	add	sp, #16
10042276:	bd80      	pop	{r7, pc}

10042278 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
10042278:	b580      	push	{r7, lr}
1004227a:	b084      	sub	sp, #16
1004227c:	af00      	add	r7, sp, #0
1004227e:	60f8      	str	r0, [r7, #12]
10042280:	60b9      	str	r1, [r7, #8]
10042282:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
10042284:	e032      	b.n	100422ec <I2C_WaitOnTXISFlagUntilTimeout+0x74>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
10042286:	687a      	ldr	r2, [r7, #4]
10042288:	68b9      	ldr	r1, [r7, #8]
1004228a:	68fb      	ldr	r3, [r7, #12]
1004228c:	0018      	movs	r0, r3
1004228e:	f000 f87d 	bl	1004238c <I2C_IsErrorOccurred>
10042292:	1e03      	subs	r3, r0, #0
10042294:	d001      	beq.n	1004229a <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
10042296:	2301      	movs	r3, #1
10042298:	e030      	b.n	100422fc <I2C_WaitOnTXISFlagUntilTimeout+0x84>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
1004229a:	68bb      	ldr	r3, [r7, #8]
1004229c:	3301      	adds	r3, #1
1004229e:	d025      	beq.n	100422ec <I2C_WaitOnTXISFlagUntilTimeout+0x74>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
100422a0:	f7ff f910 	bl	100414c4 <HAL_GetTick>
100422a4:	0002      	movs	r2, r0
100422a6:	687b      	ldr	r3, [r7, #4]
100422a8:	1ad3      	subs	r3, r2, r3
100422aa:	68ba      	ldr	r2, [r7, #8]
100422ac:	429a      	cmp	r2, r3
100422ae:	d302      	bcc.n	100422b6 <I2C_WaitOnTXISFlagUntilTimeout+0x3e>
100422b0:	68bb      	ldr	r3, [r7, #8]
100422b2:	2b00      	cmp	r3, #0
100422b4:	d11a      	bne.n	100422ec <I2C_WaitOnTXISFlagUntilTimeout+0x74>
      {
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
100422b6:	68fb      	ldr	r3, [r7, #12]
100422b8:	681b      	ldr	r3, [r3, #0]
100422ba:	699b      	ldr	r3, [r3, #24]
100422bc:	2202      	movs	r2, #2
100422be:	4013      	ands	r3, r2
100422c0:	2b02      	cmp	r3, #2
100422c2:	d013      	beq.n	100422ec <I2C_WaitOnTXISFlagUntilTimeout+0x74>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
100422c4:	68fb      	ldr	r3, [r7, #12]
100422c6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
100422c8:	2220      	movs	r2, #32
100422ca:	431a      	orrs	r2, r3
100422cc:	68fb      	ldr	r3, [r7, #12]
100422ce:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
100422d0:	68fb      	ldr	r3, [r7, #12]
100422d2:	2241      	movs	r2, #65	@ 0x41
100422d4:	2120      	movs	r1, #32
100422d6:	5499      	strb	r1, [r3, r2]
          hi2c->Mode = HAL_I2C_MODE_NONE;
100422d8:	68fb      	ldr	r3, [r7, #12]
100422da:	2242      	movs	r2, #66	@ 0x42
100422dc:	2100      	movs	r1, #0
100422de:	5499      	strb	r1, [r3, r2]

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
100422e0:	68fb      	ldr	r3, [r7, #12]
100422e2:	2240      	movs	r2, #64	@ 0x40
100422e4:	2100      	movs	r1, #0
100422e6:	5499      	strb	r1, [r3, r2]

          return HAL_ERROR;
100422e8:	2301      	movs	r3, #1
100422ea:	e007      	b.n	100422fc <I2C_WaitOnTXISFlagUntilTimeout+0x84>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
100422ec:	68fb      	ldr	r3, [r7, #12]
100422ee:	681b      	ldr	r3, [r3, #0]
100422f0:	699b      	ldr	r3, [r3, #24]
100422f2:	2202      	movs	r2, #2
100422f4:	4013      	ands	r3, r2
100422f6:	2b02      	cmp	r3, #2
100422f8:	d1c5      	bne.n	10042286 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
100422fa:	2300      	movs	r3, #0
}
100422fc:	0018      	movs	r0, r3
100422fe:	46bd      	mov	sp, r7
10042300:	b004      	add	sp, #16
10042302:	bd80      	pop	{r7, pc}

10042304 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
10042304:	b580      	push	{r7, lr}
10042306:	b084      	sub	sp, #16
10042308:	af00      	add	r7, sp, #0
1004230a:	60f8      	str	r0, [r7, #12]
1004230c:	60b9      	str	r1, [r7, #8]
1004230e:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
10042310:	e02f      	b.n	10042372 <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
10042312:	687a      	ldr	r2, [r7, #4]
10042314:	68b9      	ldr	r1, [r7, #8]
10042316:	68fb      	ldr	r3, [r7, #12]
10042318:	0018      	movs	r0, r3
1004231a:	f000 f837 	bl	1004238c <I2C_IsErrorOccurred>
1004231e:	1e03      	subs	r3, r0, #0
10042320:	d001      	beq.n	10042326 <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
10042322:	2301      	movs	r3, #1
10042324:	e02d      	b.n	10042382 <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
10042326:	f7ff f8cd 	bl	100414c4 <HAL_GetTick>
1004232a:	0002      	movs	r2, r0
1004232c:	687b      	ldr	r3, [r7, #4]
1004232e:	1ad3      	subs	r3, r2, r3
10042330:	68ba      	ldr	r2, [r7, #8]
10042332:	429a      	cmp	r2, r3
10042334:	d302      	bcc.n	1004233c <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
10042336:	68bb      	ldr	r3, [r7, #8]
10042338:	2b00      	cmp	r3, #0
1004233a:	d11a      	bne.n	10042372 <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
    {
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
1004233c:	68fb      	ldr	r3, [r7, #12]
1004233e:	681b      	ldr	r3, [r3, #0]
10042340:	699b      	ldr	r3, [r3, #24]
10042342:	2220      	movs	r2, #32
10042344:	4013      	ands	r3, r2
10042346:	2b20      	cmp	r3, #32
10042348:	d013      	beq.n	10042372 <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
1004234a:	68fb      	ldr	r3, [r7, #12]
1004234c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
1004234e:	2220      	movs	r2, #32
10042350:	431a      	orrs	r2, r3
10042352:	68fb      	ldr	r3, [r7, #12]
10042354:	645a      	str	r2, [r3, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
10042356:	68fb      	ldr	r3, [r7, #12]
10042358:	2241      	movs	r2, #65	@ 0x41
1004235a:	2120      	movs	r1, #32
1004235c:	5499      	strb	r1, [r3, r2]
        hi2c->Mode = HAL_I2C_MODE_NONE;
1004235e:	68fb      	ldr	r3, [r7, #12]
10042360:	2242      	movs	r2, #66	@ 0x42
10042362:	2100      	movs	r1, #0
10042364:	5499      	strb	r1, [r3, r2]

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
10042366:	68fb      	ldr	r3, [r7, #12]
10042368:	2240      	movs	r2, #64	@ 0x40
1004236a:	2100      	movs	r1, #0
1004236c:	5499      	strb	r1, [r3, r2]

        return HAL_ERROR;
1004236e:	2301      	movs	r3, #1
10042370:	e007      	b.n	10042382 <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
10042372:	68fb      	ldr	r3, [r7, #12]
10042374:	681b      	ldr	r3, [r3, #0]
10042376:	699b      	ldr	r3, [r3, #24]
10042378:	2220      	movs	r2, #32
1004237a:	4013      	ands	r3, r2
1004237c:	2b20      	cmp	r3, #32
1004237e:	d1c8      	bne.n	10042312 <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
10042380:	2300      	movs	r3, #0
}
10042382:	0018      	movs	r0, r3
10042384:	46bd      	mov	sp, r7
10042386:	b004      	add	sp, #16
10042388:	bd80      	pop	{r7, pc}
	...

1004238c <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
1004238c:	b580      	push	{r7, lr}
1004238e:	b08a      	sub	sp, #40	@ 0x28
10042390:	af00      	add	r7, sp, #0
10042392:	60f8      	str	r0, [r7, #12]
10042394:	60b9      	str	r1, [r7, #8]
10042396:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
10042398:	2327      	movs	r3, #39	@ 0x27
1004239a:	18fb      	adds	r3, r7, r3
1004239c:	2200      	movs	r2, #0
1004239e:	701a      	strb	r2, [r3, #0]
  uint32_t itflag   = hi2c->Instance->ISR;
100423a0:	68fb      	ldr	r3, [r7, #12]
100423a2:	681b      	ldr	r3, [r3, #0]
100423a4:	699b      	ldr	r3, [r3, #24]
100423a6:	61bb      	str	r3, [r7, #24]
  uint32_t error_code = 0;
100423a8:	2300      	movs	r3, #0
100423aa:	623b      	str	r3, [r7, #32]
  uint32_t tickstart = Tickstart;
100423ac:	687b      	ldr	r3, [r7, #4]
100423ae:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
100423b0:	69bb      	ldr	r3, [r7, #24]
100423b2:	2210      	movs	r2, #16
100423b4:	4013      	ands	r3, r2
100423b6:	d100      	bne.n	100423ba <I2C_IsErrorOccurred+0x2e>
100423b8:	e079      	b.n	100424ae <I2C_IsErrorOccurred+0x122>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
100423ba:	68fb      	ldr	r3, [r7, #12]
100423bc:	681b      	ldr	r3, [r3, #0]
100423be:	2210      	movs	r2, #16
100423c0:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
100423c2:	e057      	b.n	10042474 <I2C_IsErrorOccurred+0xe8>
100423c4:	2227      	movs	r2, #39	@ 0x27
100423c6:	18bb      	adds	r3, r7, r2
100423c8:	18ba      	adds	r2, r7, r2
100423ca:	7812      	ldrb	r2, [r2, #0]
100423cc:	701a      	strb	r2, [r3, #0]
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
100423ce:	68bb      	ldr	r3, [r7, #8]
100423d0:	3301      	adds	r3, #1
100423d2:	d04f      	beq.n	10042474 <I2C_IsErrorOccurred+0xe8>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
100423d4:	f7ff f876 	bl	100414c4 <HAL_GetTick>
100423d8:	0002      	movs	r2, r0
100423da:	69fb      	ldr	r3, [r7, #28]
100423dc:	1ad3      	subs	r3, r2, r3
100423de:	68ba      	ldr	r2, [r7, #8]
100423e0:	429a      	cmp	r2, r3
100423e2:	d302      	bcc.n	100423ea <I2C_IsErrorOccurred+0x5e>
100423e4:	68bb      	ldr	r3, [r7, #8]
100423e6:	2b00      	cmp	r3, #0
100423e8:	d144      	bne.n	10042474 <I2C_IsErrorOccurred+0xe8>
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
100423ea:	68fb      	ldr	r3, [r7, #12]
100423ec:	681b      	ldr	r3, [r3, #0]
100423ee:	685a      	ldr	r2, [r3, #4]
100423f0:	2380      	movs	r3, #128	@ 0x80
100423f2:	01db      	lsls	r3, r3, #7
100423f4:	4013      	ands	r3, r2
100423f6:	617b      	str	r3, [r7, #20]
          tmp2 = hi2c->Mode;
100423f8:	2013      	movs	r0, #19
100423fa:	183b      	adds	r3, r7, r0
100423fc:	68fa      	ldr	r2, [r7, #12]
100423fe:	2142      	movs	r1, #66	@ 0x42
10042400:	5c52      	ldrb	r2, [r2, r1]
10042402:	701a      	strb	r2, [r3, #0]

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
10042404:	68fb      	ldr	r3, [r7, #12]
10042406:	681b      	ldr	r3, [r3, #0]
10042408:	699a      	ldr	r2, [r3, #24]
1004240a:	2380      	movs	r3, #128	@ 0x80
1004240c:	021b      	lsls	r3, r3, #8
1004240e:	401a      	ands	r2, r3
10042410:	2380      	movs	r3, #128	@ 0x80
10042412:	021b      	lsls	r3, r3, #8
10042414:	429a      	cmp	r2, r3
10042416:	d126      	bne.n	10042466 <I2C_IsErrorOccurred+0xda>
10042418:	697a      	ldr	r2, [r7, #20]
1004241a:	2380      	movs	r3, #128	@ 0x80
1004241c:	01db      	lsls	r3, r3, #7
1004241e:	429a      	cmp	r2, r3
10042420:	d021      	beq.n	10042466 <I2C_IsErrorOccurred+0xda>
              (tmp1 != I2C_CR2_STOP) && \
10042422:	183b      	adds	r3, r7, r0
10042424:	781b      	ldrb	r3, [r3, #0]
10042426:	2b20      	cmp	r3, #32
10042428:	d01d      	beq.n	10042466 <I2C_IsErrorOccurred+0xda>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
1004242a:	68fb      	ldr	r3, [r7, #12]
1004242c:	681b      	ldr	r3, [r3, #0]
1004242e:	685a      	ldr	r2, [r3, #4]
10042430:	68fb      	ldr	r3, [r7, #12]
10042432:	681b      	ldr	r3, [r3, #0]
10042434:	2180      	movs	r1, #128	@ 0x80
10042436:	01c9      	lsls	r1, r1, #7
10042438:	430a      	orrs	r2, r1
1004243a:	605a      	str	r2, [r3, #4]

            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
1004243c:	f7ff f842 	bl	100414c4 <HAL_GetTick>
10042440:	0003      	movs	r3, r0
10042442:	61fb      	str	r3, [r7, #28]
          }

          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
10042444:	e00f      	b.n	10042466 <I2C_IsErrorOccurred+0xda>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
10042446:	f7ff f83d 	bl	100414c4 <HAL_GetTick>
1004244a:	0002      	movs	r2, r0
1004244c:	69fb      	ldr	r3, [r7, #28]
1004244e:	1ad3      	subs	r3, r2, r3
10042450:	2b19      	cmp	r3, #25
10042452:	d908      	bls.n	10042466 <I2C_IsErrorOccurred+0xda>
            {
              error_code |= HAL_I2C_ERROR_TIMEOUT;
10042454:	6a3b      	ldr	r3, [r7, #32]
10042456:	2220      	movs	r2, #32
10042458:	4313      	orrs	r3, r2
1004245a:	623b      	str	r3, [r7, #32]

              status = HAL_ERROR;
1004245c:	2327      	movs	r3, #39	@ 0x27
1004245e:	18fb      	adds	r3, r7, r3
10042460:	2201      	movs	r2, #1
10042462:	701a      	strb	r2, [r3, #0]

              break;
10042464:	e006      	b.n	10042474 <I2C_IsErrorOccurred+0xe8>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
10042466:	68fb      	ldr	r3, [r7, #12]
10042468:	681b      	ldr	r3, [r3, #0]
1004246a:	699b      	ldr	r3, [r3, #24]
1004246c:	2220      	movs	r2, #32
1004246e:	4013      	ands	r3, r2
10042470:	2b20      	cmp	r3, #32
10042472:	d1e8      	bne.n	10042446 <I2C_IsErrorOccurred+0xba>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
10042474:	68fb      	ldr	r3, [r7, #12]
10042476:	681b      	ldr	r3, [r3, #0]
10042478:	699b      	ldr	r3, [r3, #24]
1004247a:	2220      	movs	r2, #32
1004247c:	4013      	ands	r3, r2
1004247e:	2b20      	cmp	r3, #32
10042480:	d004      	beq.n	1004248c <I2C_IsErrorOccurred+0x100>
10042482:	2327      	movs	r3, #39	@ 0x27
10042484:	18fb      	adds	r3, r7, r3
10042486:	781b      	ldrb	r3, [r3, #0]
10042488:	2b00      	cmp	r3, #0
1004248a:	d09b      	beq.n	100423c4 <I2C_IsErrorOccurred+0x38>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
1004248c:	2327      	movs	r3, #39	@ 0x27
1004248e:	18fb      	adds	r3, r7, r3
10042490:	781b      	ldrb	r3, [r3, #0]
10042492:	2b00      	cmp	r3, #0
10042494:	d103      	bne.n	1004249e <I2C_IsErrorOccurred+0x112>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
10042496:	68fb      	ldr	r3, [r7, #12]
10042498:	681b      	ldr	r3, [r3, #0]
1004249a:	2220      	movs	r2, #32
1004249c:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
1004249e:	6a3b      	ldr	r3, [r7, #32]
100424a0:	2204      	movs	r2, #4
100424a2:	4313      	orrs	r3, r2
100424a4:	623b      	str	r3, [r7, #32]

    status = HAL_ERROR;
100424a6:	2327      	movs	r3, #39	@ 0x27
100424a8:	18fb      	adds	r3, r7, r3
100424aa:	2201      	movs	r2, #1
100424ac:	701a      	strb	r2, [r3, #0]
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
100424ae:	68fb      	ldr	r3, [r7, #12]
100424b0:	681b      	ldr	r3, [r3, #0]
100424b2:	699b      	ldr	r3, [r3, #24]
100424b4:	61bb      	str	r3, [r7, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
100424b6:	69ba      	ldr	r2, [r7, #24]
100424b8:	2380      	movs	r3, #128	@ 0x80
100424ba:	005b      	lsls	r3, r3, #1
100424bc:	4013      	ands	r3, r2
100424be:	d00c      	beq.n	100424da <I2C_IsErrorOccurred+0x14e>
  {
    error_code |= HAL_I2C_ERROR_BERR;
100424c0:	6a3b      	ldr	r3, [r7, #32]
100424c2:	2201      	movs	r2, #1
100424c4:	4313      	orrs	r3, r2
100424c6:	623b      	str	r3, [r7, #32]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
100424c8:	68fb      	ldr	r3, [r7, #12]
100424ca:	681b      	ldr	r3, [r3, #0]
100424cc:	2280      	movs	r2, #128	@ 0x80
100424ce:	0052      	lsls	r2, r2, #1
100424d0:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
100424d2:	2327      	movs	r3, #39	@ 0x27
100424d4:	18fb      	adds	r3, r7, r3
100424d6:	2201      	movs	r2, #1
100424d8:	701a      	strb	r2, [r3, #0]
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
100424da:	69ba      	ldr	r2, [r7, #24]
100424dc:	2380      	movs	r3, #128	@ 0x80
100424de:	00db      	lsls	r3, r3, #3
100424e0:	4013      	ands	r3, r2
100424e2:	d00c      	beq.n	100424fe <I2C_IsErrorOccurred+0x172>
  {
    error_code |= HAL_I2C_ERROR_OVR;
100424e4:	6a3b      	ldr	r3, [r7, #32]
100424e6:	2208      	movs	r2, #8
100424e8:	4313      	orrs	r3, r2
100424ea:	623b      	str	r3, [r7, #32]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
100424ec:	68fb      	ldr	r3, [r7, #12]
100424ee:	681b      	ldr	r3, [r3, #0]
100424f0:	2280      	movs	r2, #128	@ 0x80
100424f2:	00d2      	lsls	r2, r2, #3
100424f4:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
100424f6:	2327      	movs	r3, #39	@ 0x27
100424f8:	18fb      	adds	r3, r7, r3
100424fa:	2201      	movs	r2, #1
100424fc:	701a      	strb	r2, [r3, #0]
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
100424fe:	69ba      	ldr	r2, [r7, #24]
10042500:	2380      	movs	r3, #128	@ 0x80
10042502:	009b      	lsls	r3, r3, #2
10042504:	4013      	ands	r3, r2
10042506:	d00c      	beq.n	10042522 <I2C_IsErrorOccurred+0x196>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
10042508:	6a3b      	ldr	r3, [r7, #32]
1004250a:	2202      	movs	r2, #2
1004250c:	4313      	orrs	r3, r2
1004250e:	623b      	str	r3, [r7, #32]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
10042510:	68fb      	ldr	r3, [r7, #12]
10042512:	681b      	ldr	r3, [r3, #0]
10042514:	2280      	movs	r2, #128	@ 0x80
10042516:	0092      	lsls	r2, r2, #2
10042518:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
1004251a:	2327      	movs	r3, #39	@ 0x27
1004251c:	18fb      	adds	r3, r7, r3
1004251e:	2201      	movs	r2, #1
10042520:	701a      	strb	r2, [r3, #0]
  }

  if (status != HAL_OK)
10042522:	2327      	movs	r3, #39	@ 0x27
10042524:	18fb      	adds	r3, r7, r3
10042526:	781b      	ldrb	r3, [r3, #0]
10042528:	2b00      	cmp	r3, #0
1004252a:	d01d      	beq.n	10042568 <I2C_IsErrorOccurred+0x1dc>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
1004252c:	68fb      	ldr	r3, [r7, #12]
1004252e:	0018      	movs	r0, r3
10042530:	f7ff fe28 	bl	10042184 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
10042534:	68fb      	ldr	r3, [r7, #12]
10042536:	681b      	ldr	r3, [r3, #0]
10042538:	685a      	ldr	r2, [r3, #4]
1004253a:	68fb      	ldr	r3, [r7, #12]
1004253c:	681b      	ldr	r3, [r3, #0]
1004253e:	490e      	ldr	r1, [pc, #56]	@ (10042578 <I2C_IsErrorOccurred+0x1ec>)
10042540:	400a      	ands	r2, r1
10042542:	605a      	str	r2, [r3, #4]

    hi2c->ErrorCode |= error_code;
10042544:	68fb      	ldr	r3, [r7, #12]
10042546:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
10042548:	6a3b      	ldr	r3, [r7, #32]
1004254a:	431a      	orrs	r2, r3
1004254c:	68fb      	ldr	r3, [r7, #12]
1004254e:	645a      	str	r2, [r3, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
10042550:	68fb      	ldr	r3, [r7, #12]
10042552:	2241      	movs	r2, #65	@ 0x41
10042554:	2120      	movs	r1, #32
10042556:	5499      	strb	r1, [r3, r2]
    hi2c->Mode = HAL_I2C_MODE_NONE;
10042558:	68fb      	ldr	r3, [r7, #12]
1004255a:	2242      	movs	r2, #66	@ 0x42
1004255c:	2100      	movs	r1, #0
1004255e:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
10042560:	68fb      	ldr	r3, [r7, #12]
10042562:	2240      	movs	r2, #64	@ 0x40
10042564:	2100      	movs	r1, #0
10042566:	5499      	strb	r1, [r3, r2]
  }

  return status;
10042568:	2327      	movs	r3, #39	@ 0x27
1004256a:	18fb      	adds	r3, r7, r3
1004256c:	781b      	ldrb	r3, [r3, #0]
}
1004256e:	0018      	movs	r0, r3
10042570:	46bd      	mov	sp, r7
10042572:	b00a      	add	sp, #40	@ 0x28
10042574:	bd80      	pop	{r7, pc}
10042576:	46c0      	nop			@ (mov r8, r8)
10042578:	fe00e800 	.word	0xfe00e800

1004257c <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
1004257c:	b590      	push	{r4, r7, lr}
1004257e:	b087      	sub	sp, #28
10042580:	af00      	add	r7, sp, #0
10042582:	60f8      	str	r0, [r7, #12]
10042584:	0008      	movs	r0, r1
10042586:	0011      	movs	r1, r2
10042588:	607b      	str	r3, [r7, #4]
1004258a:	240a      	movs	r4, #10
1004258c:	193b      	adds	r3, r7, r4
1004258e:	1c02      	adds	r2, r0, #0
10042590:	801a      	strh	r2, [r3, #0]
10042592:	2009      	movs	r0, #9
10042594:	183b      	adds	r3, r7, r0
10042596:	1c0a      	adds	r2, r1, #0
10042598:	701a      	strb	r2, [r3, #0]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
1004259a:	193b      	adds	r3, r7, r4
1004259c:	881b      	ldrh	r3, [r3, #0]
1004259e:	059b      	lsls	r3, r3, #22
100425a0:	0d9a      	lsrs	r2, r3, #22
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
100425a2:	183b      	adds	r3, r7, r0
100425a4:	781b      	ldrb	r3, [r3, #0]
100425a6:	0419      	lsls	r1, r3, #16
100425a8:	23ff      	movs	r3, #255	@ 0xff
100425aa:	041b      	lsls	r3, r3, #16
100425ac:	400b      	ands	r3, r1
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
100425ae:	431a      	orrs	r2, r3
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
100425b0:	687b      	ldr	r3, [r7, #4]
100425b2:	431a      	orrs	r2, r3
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
100425b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
100425b6:	4313      	orrs	r3, r2
100425b8:	005b      	lsls	r3, r3, #1
100425ba:	085b      	lsrs	r3, r3, #1
100425bc:	617b      	str	r3, [r7, #20]
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
100425be:	68fb      	ldr	r3, [r7, #12]
100425c0:	681b      	ldr	r3, [r3, #0]
100425c2:	685b      	ldr	r3, [r3, #4]
100425c4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
100425c6:	0d51      	lsrs	r1, r2, #21
100425c8:	2280      	movs	r2, #128	@ 0x80
100425ca:	00d2      	lsls	r2, r2, #3
100425cc:	400a      	ands	r2, r1
100425ce:	4907      	ldr	r1, [pc, #28]	@ (100425ec <I2C_TransferConfig+0x70>)
100425d0:	430a      	orrs	r2, r1
100425d2:	43d2      	mvns	r2, r2
100425d4:	401a      	ands	r2, r3
100425d6:	0011      	movs	r1, r2
100425d8:	68fb      	ldr	r3, [r7, #12]
100425da:	681b      	ldr	r3, [r3, #0]
100425dc:	697a      	ldr	r2, [r7, #20]
100425de:	430a      	orrs	r2, r1
100425e0:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
100425e2:	46c0      	nop			@ (mov r8, r8)
100425e4:	46bd      	mov	sp, r7
100425e6:	b007      	add	sp, #28
100425e8:	bd90      	pop	{r4, r7, pc}
100425ea:	46c0      	nop			@ (mov r8, r8)
100425ec:	03ff63ff 	.word	0x03ff63ff

100425f0 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
100425f0:	b580      	push	{r7, lr}
100425f2:	b082      	sub	sp, #8
100425f4:	af00      	add	r7, sp, #0
100425f6:	6078      	str	r0, [r7, #4]
100425f8:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
100425fa:	687b      	ldr	r3, [r7, #4]
100425fc:	2241      	movs	r2, #65	@ 0x41
100425fe:	5c9b      	ldrb	r3, [r3, r2]
10042600:	b2db      	uxtb	r3, r3
10042602:	2b20      	cmp	r3, #32
10042604:	d138      	bne.n	10042678 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
10042606:	687b      	ldr	r3, [r7, #4]
10042608:	2240      	movs	r2, #64	@ 0x40
1004260a:	5c9b      	ldrb	r3, [r3, r2]
1004260c:	2b01      	cmp	r3, #1
1004260e:	d101      	bne.n	10042614 <HAL_I2CEx_ConfigAnalogFilter+0x24>
10042610:	2302      	movs	r3, #2
10042612:	e032      	b.n	1004267a <HAL_I2CEx_ConfigAnalogFilter+0x8a>
10042614:	687b      	ldr	r3, [r7, #4]
10042616:	2240      	movs	r2, #64	@ 0x40
10042618:	2101      	movs	r1, #1
1004261a:	5499      	strb	r1, [r3, r2]

    hi2c->State = HAL_I2C_STATE_BUSY;
1004261c:	687b      	ldr	r3, [r7, #4]
1004261e:	2241      	movs	r2, #65	@ 0x41
10042620:	2124      	movs	r1, #36	@ 0x24
10042622:	5499      	strb	r1, [r3, r2]

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
10042624:	687b      	ldr	r3, [r7, #4]
10042626:	681b      	ldr	r3, [r3, #0]
10042628:	681a      	ldr	r2, [r3, #0]
1004262a:	687b      	ldr	r3, [r7, #4]
1004262c:	681b      	ldr	r3, [r3, #0]
1004262e:	2101      	movs	r1, #1
10042630:	438a      	bics	r2, r1
10042632:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
10042634:	687b      	ldr	r3, [r7, #4]
10042636:	681b      	ldr	r3, [r3, #0]
10042638:	681a      	ldr	r2, [r3, #0]
1004263a:	687b      	ldr	r3, [r7, #4]
1004263c:	681b      	ldr	r3, [r3, #0]
1004263e:	4911      	ldr	r1, [pc, #68]	@ (10042684 <HAL_I2CEx_ConfigAnalogFilter+0x94>)
10042640:	400a      	ands	r2, r1
10042642:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
10042644:	687b      	ldr	r3, [r7, #4]
10042646:	681b      	ldr	r3, [r3, #0]
10042648:	6819      	ldr	r1, [r3, #0]
1004264a:	687b      	ldr	r3, [r7, #4]
1004264c:	681b      	ldr	r3, [r3, #0]
1004264e:	683a      	ldr	r2, [r7, #0]
10042650:	430a      	orrs	r2, r1
10042652:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
10042654:	687b      	ldr	r3, [r7, #4]
10042656:	681b      	ldr	r3, [r3, #0]
10042658:	681a      	ldr	r2, [r3, #0]
1004265a:	687b      	ldr	r3, [r7, #4]
1004265c:	681b      	ldr	r3, [r3, #0]
1004265e:	2101      	movs	r1, #1
10042660:	430a      	orrs	r2, r1
10042662:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
10042664:	687b      	ldr	r3, [r7, #4]
10042666:	2241      	movs	r2, #65	@ 0x41
10042668:	2120      	movs	r1, #32
1004266a:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
1004266c:	687b      	ldr	r3, [r7, #4]
1004266e:	2240      	movs	r2, #64	@ 0x40
10042670:	2100      	movs	r1, #0
10042672:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
10042674:	2300      	movs	r3, #0
10042676:	e000      	b.n	1004267a <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
10042678:	2302      	movs	r3, #2
  }
}
1004267a:	0018      	movs	r0, r3
1004267c:	46bd      	mov	sp, r7
1004267e:	b002      	add	sp, #8
10042680:	bd80      	pop	{r7, pc}
10042682:	46c0      	nop			@ (mov r8, r8)
10042684:	ffffefff 	.word	0xffffefff

10042688 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
10042688:	b580      	push	{r7, lr}
1004268a:	b084      	sub	sp, #16
1004268c:	af00      	add	r7, sp, #0
1004268e:	6078      	str	r0, [r7, #4]
10042690:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
10042692:	687b      	ldr	r3, [r7, #4]
10042694:	2241      	movs	r2, #65	@ 0x41
10042696:	5c9b      	ldrb	r3, [r3, r2]
10042698:	b2db      	uxtb	r3, r3
1004269a:	2b20      	cmp	r3, #32
1004269c:	d139      	bne.n	10042712 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
1004269e:	687b      	ldr	r3, [r7, #4]
100426a0:	2240      	movs	r2, #64	@ 0x40
100426a2:	5c9b      	ldrb	r3, [r3, r2]
100426a4:	2b01      	cmp	r3, #1
100426a6:	d101      	bne.n	100426ac <HAL_I2CEx_ConfigDigitalFilter+0x24>
100426a8:	2302      	movs	r3, #2
100426aa:	e033      	b.n	10042714 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
100426ac:	687b      	ldr	r3, [r7, #4]
100426ae:	2240      	movs	r2, #64	@ 0x40
100426b0:	2101      	movs	r1, #1
100426b2:	5499      	strb	r1, [r3, r2]

    hi2c->State = HAL_I2C_STATE_BUSY;
100426b4:	687b      	ldr	r3, [r7, #4]
100426b6:	2241      	movs	r2, #65	@ 0x41
100426b8:	2124      	movs	r1, #36	@ 0x24
100426ba:	5499      	strb	r1, [r3, r2]

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
100426bc:	687b      	ldr	r3, [r7, #4]
100426be:	681b      	ldr	r3, [r3, #0]
100426c0:	681a      	ldr	r2, [r3, #0]
100426c2:	687b      	ldr	r3, [r7, #4]
100426c4:	681b      	ldr	r3, [r3, #0]
100426c6:	2101      	movs	r1, #1
100426c8:	438a      	bics	r2, r1
100426ca:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
100426cc:	687b      	ldr	r3, [r7, #4]
100426ce:	681b      	ldr	r3, [r3, #0]
100426d0:	681b      	ldr	r3, [r3, #0]
100426d2:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
100426d4:	68fb      	ldr	r3, [r7, #12]
100426d6:	4a11      	ldr	r2, [pc, #68]	@ (1004271c <HAL_I2CEx_ConfigDigitalFilter+0x94>)
100426d8:	4013      	ands	r3, r2
100426da:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
100426dc:	683b      	ldr	r3, [r7, #0]
100426de:	021b      	lsls	r3, r3, #8
100426e0:	68fa      	ldr	r2, [r7, #12]
100426e2:	4313      	orrs	r3, r2
100426e4:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
100426e6:	687b      	ldr	r3, [r7, #4]
100426e8:	681b      	ldr	r3, [r3, #0]
100426ea:	68fa      	ldr	r2, [r7, #12]
100426ec:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
100426ee:	687b      	ldr	r3, [r7, #4]
100426f0:	681b      	ldr	r3, [r3, #0]
100426f2:	681a      	ldr	r2, [r3, #0]
100426f4:	687b      	ldr	r3, [r7, #4]
100426f6:	681b      	ldr	r3, [r3, #0]
100426f8:	2101      	movs	r1, #1
100426fa:	430a      	orrs	r2, r1
100426fc:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
100426fe:	687b      	ldr	r3, [r7, #4]
10042700:	2241      	movs	r2, #65	@ 0x41
10042702:	2120      	movs	r1, #32
10042704:	5499      	strb	r1, [r3, r2]

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
10042706:	687b      	ldr	r3, [r7, #4]
10042708:	2240      	movs	r2, #64	@ 0x40
1004270a:	2100      	movs	r1, #0
1004270c:	5499      	strb	r1, [r3, r2]

    return HAL_OK;
1004270e:	2300      	movs	r3, #0
10042710:	e000      	b.n	10042714 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
10042712:	2302      	movs	r3, #2
  }
}
10042714:	0018      	movs	r0, r3
10042716:	46bd      	mov	sp, r7
10042718:	b004      	add	sp, #16
1004271a:	bd80      	pop	{r7, pc}
1004271c:	fffff0ff 	.word	0xfffff0ff

10042720 <LL_RCC_HSE_IsReady>:
  * @brief  Check if HSE oscillator Ready
  * @rmtoll CR           HSERDY        LL_RCC_HSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
{
10042720:	b580      	push	{r7, lr}
10042722:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
10042724:	4b07      	ldr	r3, [pc, #28]	@ (10042744 <LL_RCC_HSE_IsReady+0x24>)
10042726:	681a      	ldr	r2, [r3, #0]
10042728:	2380      	movs	r3, #128	@ 0x80
1004272a:	029b      	lsls	r3, r3, #10
1004272c:	401a      	ands	r2, r3
1004272e:	2380      	movs	r3, #128	@ 0x80
10042730:	029b      	lsls	r3, r3, #10
10042732:	429a      	cmp	r2, r3
10042734:	d101      	bne.n	1004273a <LL_RCC_HSE_IsReady+0x1a>
10042736:	2301      	movs	r3, #1
10042738:	e000      	b.n	1004273c <LL_RCC_HSE_IsReady+0x1c>
1004273a:	2300      	movs	r3, #0
}
1004273c:	0018      	movs	r0, r3
1004273e:	46bd      	mov	sp, r7
10042740:	bd80      	pop	{r7, pc}
10042742:	46c0      	nop			@ (mov r8, r8)
10042744:	48400000 	.word	0x48400000

10042748 <LL_RCC_HSI_Enable>:
  * @brief  Enable HSI
  * @rmtoll CFGR           STOPHSI        LL_RCC_HSI_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSI_Enable(void)
{
10042748:	b580      	push	{r7, lr}
1004274a:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CFGR, RCC_CFGR_STOPHSI);
1004274c:	4b07      	ldr	r3, [pc, #28]	@ (1004276c <LL_RCC_HSI_Enable+0x24>)
1004274e:	689a      	ldr	r2, [r3, #8]
10042750:	4b06      	ldr	r3, [pc, #24]	@ (1004276c <LL_RCC_HSI_Enable+0x24>)
10042752:	2104      	movs	r1, #4
10042754:	438a      	bics	r2, r1
10042756:	609a      	str	r2, [r3, #8]
  CLEAR_BIT(RCC->CFGR, RCC_CFGR_HSESEL);
10042758:	4b04      	ldr	r3, [pc, #16]	@ (1004276c <LL_RCC_HSI_Enable+0x24>)
1004275a:	689a      	ldr	r2, [r3, #8]
1004275c:	4b03      	ldr	r3, [pc, #12]	@ (1004276c <LL_RCC_HSI_Enable+0x24>)
1004275e:	2102      	movs	r1, #2
10042760:	438a      	bics	r2, r1
10042762:	609a      	str	r2, [r3, #8]
}
10042764:	46c0      	nop			@ (mov r8, r8)
10042766:	46bd      	mov	sp, r7
10042768:	bd80      	pop	{r7, pc}
1004276a:	46c0      	nop			@ (mov r8, r8)
1004276c:	48400000 	.word	0x48400000

10042770 <LL_RCC_HSI_IsReady>:
  * @brief  Check if HSI clock is ready
  * @rmtoll CR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
10042770:	b580      	push	{r7, lr}
10042772:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
10042774:	4b07      	ldr	r3, [pc, #28]	@ (10042794 <LL_RCC_HSI_IsReady+0x24>)
10042776:	681a      	ldr	r2, [r3, #0]
10042778:	2380      	movs	r3, #128	@ 0x80
1004277a:	00db      	lsls	r3, r3, #3
1004277c:	401a      	ands	r2, r3
1004277e:	2380      	movs	r3, #128	@ 0x80
10042780:	00db      	lsls	r3, r3, #3
10042782:	429a      	cmp	r2, r3
10042784:	d101      	bne.n	1004278a <LL_RCC_HSI_IsReady+0x1a>
10042786:	2301      	movs	r3, #1
10042788:	e000      	b.n	1004278c <LL_RCC_HSI_IsReady+0x1c>
1004278a:	2300      	movs	r3, #0
}
1004278c:	0018      	movs	r0, r3
1004278e:	46bd      	mov	sp, r7
10042790:	bd80      	pop	{r7, pc}
10042792:	46c0      	nop			@ (mov r8, r8)
10042794:	48400000 	.word	0x48400000

10042798 <LL_RCC_DIRECT_HSE_Enable>:
  * @brief  Enable DIRECT_HSE mode
  * @rmtoll CFGR       HSESEL/STOPHSI         LL_RCC_HSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_DIRECT_HSE_Enable(void)
{
10042798:	b580      	push	{r7, lr}
1004279a:	b082      	sub	sp, #8
1004279c:	af00      	add	r7, sp, #0
  while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0);
1004279e:	46c0      	nop			@ (mov r8, r8)
100427a0:	4b0f      	ldr	r3, [pc, #60]	@ (100427e0 <LL_RCC_DIRECT_HSE_Enable+0x48>)
100427a2:	681a      	ldr	r2, [r3, #0]
100427a4:	2380      	movs	r3, #128	@ 0x80
100427a6:	029b      	lsls	r3, r3, #10
100427a8:	4013      	ands	r3, r2
100427aa:	d0f9      	beq.n	100427a0 <LL_RCC_DIRECT_HSE_Enable+0x8>
  SET_BIT(RCC->CFGR, RCC_CFGR_HSESEL);
100427ac:	4b0c      	ldr	r3, [pc, #48]	@ (100427e0 <LL_RCC_DIRECT_HSE_Enable+0x48>)
100427ae:	689a      	ldr	r2, [r3, #8]
100427b0:	4b0b      	ldr	r3, [pc, #44]	@ (100427e0 <LL_RCC_DIRECT_HSE_Enable+0x48>)
100427b2:	2102      	movs	r1, #2
100427b4:	430a      	orrs	r2, r1
100427b6:	609a      	str	r2, [r3, #8]
  for (volatile int i = 0; i < 6; i++)
100427b8:	2300      	movs	r3, #0
100427ba:	607b      	str	r3, [r7, #4]
100427bc:	e003      	b.n	100427c6 <LL_RCC_DIRECT_HSE_Enable+0x2e>
  {
    __asm("NOP");
100427be:	46c0      	nop			@ (mov r8, r8)
  for (volatile int i = 0; i < 6; i++)
100427c0:	687b      	ldr	r3, [r7, #4]
100427c2:	3301      	adds	r3, #1
100427c4:	607b      	str	r3, [r7, #4]
100427c6:	687b      	ldr	r3, [r7, #4]
100427c8:	2b05      	cmp	r3, #5
100427ca:	ddf8      	ble.n	100427be <LL_RCC_DIRECT_HSE_Enable+0x26>
  }
  SET_BIT(RCC->CFGR, RCC_CFGR_STOPHSI);
100427cc:	4b04      	ldr	r3, [pc, #16]	@ (100427e0 <LL_RCC_DIRECT_HSE_Enable+0x48>)
100427ce:	689a      	ldr	r2, [r3, #8]
100427d0:	4b03      	ldr	r3, [pc, #12]	@ (100427e0 <LL_RCC_DIRECT_HSE_Enable+0x48>)
100427d2:	2104      	movs	r1, #4
100427d4:	430a      	orrs	r2, r1
100427d6:	609a      	str	r2, [r3, #8]
}
100427d8:	46c0      	nop			@ (mov r8, r8)
100427da:	46bd      	mov	sp, r7
100427dc:	b002      	add	sp, #8
100427de:	bd80      	pop	{r7, pc}
100427e0:	48400000 	.word	0x48400000

100427e4 <LL_RCC_RC64MPLL_Enable>:
  * @brief  Enable RC64MPLL
  * @rmtoll CR           HSIPLLON         LL_RCC_RC64MPLL_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_RC64MPLL_Enable(void)
{
100427e4:	b580      	push	{r7, lr}
100427e6:	af00      	add	r7, sp, #0
  SET_BIT(RCC->CR, RCC_CR_HSIPLLON);
100427e8:	4b04      	ldr	r3, [pc, #16]	@ (100427fc <LL_RCC_RC64MPLL_Enable+0x18>)
100427ea:	681a      	ldr	r2, [r3, #0]
100427ec:	4b03      	ldr	r3, [pc, #12]	@ (100427fc <LL_RCC_RC64MPLL_Enable+0x18>)
100427ee:	2180      	movs	r1, #128	@ 0x80
100427f0:	0189      	lsls	r1, r1, #6
100427f2:	430a      	orrs	r2, r1
100427f4:	601a      	str	r2, [r3, #0]
}
100427f6:	46c0      	nop			@ (mov r8, r8)
100427f8:	46bd      	mov	sp, r7
100427fa:	bd80      	pop	{r7, pc}
100427fc:	48400000 	.word	0x48400000

10042800 <LL_RCC_RC64MPLL_Disable>:
  * @note Cannot be disabled if the RC64MPLL clock is used as the system clock
  * @rmtoll CR           HSIPLLON         LL_RCC_RC64MPLL_Disable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_RC64MPLL_Disable(void)
{
10042800:	b580      	push	{r7, lr}
10042802:	af00      	add	r7, sp, #0
  CLEAR_BIT(RCC->CR, RCC_CR_HSIPLLON);
10042804:	4b04      	ldr	r3, [pc, #16]	@ (10042818 <LL_RCC_RC64MPLL_Disable+0x18>)
10042806:	681a      	ldr	r2, [r3, #0]
10042808:	4b03      	ldr	r3, [pc, #12]	@ (10042818 <LL_RCC_RC64MPLL_Disable+0x18>)
1004280a:	4904      	ldr	r1, [pc, #16]	@ (1004281c <LL_RCC_RC64MPLL_Disable+0x1c>)
1004280c:	400a      	ands	r2, r1
1004280e:	601a      	str	r2, [r3, #0]
}
10042810:	46c0      	nop			@ (mov r8, r8)
10042812:	46bd      	mov	sp, r7
10042814:	bd80      	pop	{r7, pc}
10042816:	46c0      	nop			@ (mov r8, r8)
10042818:	48400000 	.word	0x48400000
1004281c:	ffffdfff 	.word	0xffffdfff

10042820 <LL_RCC_RC64MPLL_IsReady>:
  * @brief  Check if RC64MPLL is Ready
  * @rmtoll CR           HSIPLLRDY        LL_RCC_RC64MPLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_RC64MPLL_IsReady(void)
{
10042820:	b580      	push	{r7, lr}
10042822:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSIPLLRDY) == (RCC_CR_HSIPLLRDY)) ? 1UL : 0UL);
10042824:	4b07      	ldr	r3, [pc, #28]	@ (10042844 <LL_RCC_RC64MPLL_IsReady+0x24>)
10042826:	681a      	ldr	r2, [r3, #0]
10042828:	2380      	movs	r3, #128	@ 0x80
1004282a:	01db      	lsls	r3, r3, #7
1004282c:	401a      	ands	r2, r3
1004282e:	2380      	movs	r3, #128	@ 0x80
10042830:	01db      	lsls	r3, r3, #7
10042832:	429a      	cmp	r2, r3
10042834:	d101      	bne.n	1004283a <LL_RCC_RC64MPLL_IsReady+0x1a>
10042836:	2301      	movs	r3, #1
10042838:	e000      	b.n	1004283c <LL_RCC_RC64MPLL_IsReady+0x1c>
1004283a:	2300      	movs	r3, #0
}
1004283c:	0018      	movs	r0, r3
1004283e:	46bd      	mov	sp, r7
10042840:	bd80      	pop	{r7, pc}
10042842:	46c0      	nop			@ (mov r8, r8)
10042844:	48400000 	.word	0x48400000

10042848 <LL_RCC_SetRC64MPLLPrescaler>:
  *         @arg @ref LL_RCC_RC64MPLL_DIV_32
  *         @arg @ref LL_RCC_RC64MPLL_DIV_64
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetRC64MPLLPrescaler(uint32_t Prescaler)
{
10042848:	b580      	push	{r7, lr}
1004284a:	b082      	sub	sp, #8
1004284c:	af00      	add	r7, sp, #0
1004284e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_CLKSYSDIV, Prescaler);
10042850:	4b06      	ldr	r3, [pc, #24]	@ (1004286c <LL_RCC_SetRC64MPLLPrescaler+0x24>)
10042852:	689b      	ldr	r3, [r3, #8]
10042854:	22e0      	movs	r2, #224	@ 0xe0
10042856:	4393      	bics	r3, r2
10042858:	0019      	movs	r1, r3
1004285a:	4b04      	ldr	r3, [pc, #16]	@ (1004286c <LL_RCC_SetRC64MPLLPrescaler+0x24>)
1004285c:	687a      	ldr	r2, [r7, #4]
1004285e:	430a      	orrs	r2, r1
10042860:	609a      	str	r2, [r3, #8]
}
10042862:	46c0      	nop			@ (mov r8, r8)
10042864:	46bd      	mov	sp, r7
10042866:	b002      	add	sp, #8
10042868:	bd80      	pop	{r7, pc}
1004286a:	46c0      	nop			@ (mov r8, r8)
1004286c:	48400000 	.word	0x48400000

10042870 <HAL_RCC_ClockConfig>:
  *         currently used as system clock source.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
10042870:	b580      	push	{r7, lr}
10042872:	b084      	sub	sp, #16
10042874:	af00      	add	r7, sp, #0
10042876:	6078      	str	r0, [r7, #4]
10042878:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
1004287a:	687b      	ldr	r3, [r7, #4]
1004287c:	2b00      	cmp	r3, #0
1004287e:	d101      	bne.n	10042884 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
10042880:	2301      	movs	r3, #1
10042882:	e098      	b.n	100429b6 <HAL_RCC_ClockConfig+0x146>

  /* Check the parameters */
  assert_param(IS_FLASH_WAIT_STATES(FLatency));

  /* Set FALSH_WAIT_STATES_1 */
  __HAL_FLASH_SET_WAIT_STATES(FLatency);
10042884:	4b4e      	ldr	r3, [pc, #312]	@ (100429c0 <HAL_RCC_ClockConfig+0x150>)
10042886:	685b      	ldr	r3, [r3, #4]
10042888:	2230      	movs	r2, #48	@ 0x30
1004288a:	4393      	bics	r3, r2
1004288c:	0019      	movs	r1, r3
1004288e:	4b4c      	ldr	r3, [pc, #304]	@ (100429c0 <HAL_RCC_ClockConfig+0x150>)
10042890:	683a      	ldr	r2, [r7, #0]
10042892:	430a      	orrs	r2, r1
10042894:	605a      	str	r2, [r3, #4]
  /*------------------------- SYSCLK Configuration ---------------------------*/
  assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
  assert_param(IS_RCC_SYSCLK_DIVIDER(RCC_ClkInitStruct->SYSCLKDivider));

  /* HSI is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
10042896:	687b      	ldr	r3, [r7, #4]
10042898:	681b      	ldr	r3, [r3, #0]
1004289a:	2b02      	cmp	r3, #2
1004289c:	d10e      	bne.n	100428bc <HAL_RCC_ClockConfig+0x4c>
  {
    LL_RCC_HSI_Enable();
1004289e:	f7ff ff53 	bl	10042748 <LL_RCC_HSI_Enable>
    
    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() == 0U)
100428a2:	f7ff ff65 	bl	10042770 <LL_RCC_HSI_IsReady>
100428a6:	1e03      	subs	r3, r0, #0
100428a8:	d101      	bne.n	100428ae <HAL_RCC_ClockConfig+0x3e>
    {
      return HAL_ERROR;
100428aa:	2301      	movs	r3, #1
100428ac:	e083      	b.n	100429b6 <HAL_RCC_ClockConfig+0x146>
    }

    /* Disable the RC64MPLL*/
    __HAL_RCC_RC64MPLL_DISABLE();
100428ae:	f7ff ffa7 	bl	10042800 <LL_RCC_RC64MPLL_Disable>
    
    /* Configure the RC64MPLL multiplication factor */
    __HAL_RCC_RC64MPLL_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
100428b2:	687b      	ldr	r3, [r7, #4]
100428b4:	685b      	ldr	r3, [r3, #4]
100428b6:	0018      	movs	r0, r3
100428b8:	f7ff ffc6 	bl	10042848 <LL_RCC_SetRC64MPLLPrescaler>
  }

  /* RC64MPLL is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_RC64MPLL)
100428bc:	687b      	ldr	r3, [r7, #4]
100428be:	681b      	ldr	r3, [r3, #0]
100428c0:	2b00      	cmp	r3, #0
100428c2:	d124      	bne.n	1004290e <HAL_RCC_ClockConfig+0x9e>
  {
    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() == 0U)
100428c4:	f7ff ff54 	bl	10042770 <LL_RCC_HSI_IsReady>
100428c8:	1e03      	subs	r3, r0, #0
100428ca:	d101      	bne.n	100428d0 <HAL_RCC_ClockConfig+0x60>
    {
      return HAL_ERROR;
100428cc:	2301      	movs	r3, #1
100428ce:	e072      	b.n	100429b6 <HAL_RCC_ClockConfig+0x146>
    }

    /* Check the HSE ready flag */
    if (LL_RCC_HSE_IsReady() == 0U)
100428d0:	f7ff ff26 	bl	10042720 <LL_RCC_HSE_IsReady>
100428d4:	1e03      	subs	r3, r0, #0
100428d6:	d101      	bne.n	100428dc <HAL_RCC_ClockConfig+0x6c>
    {
      return HAL_ERROR;
100428d8:	2301      	movs	r3, #1
100428da:	e06c      	b.n	100429b6 <HAL_RCC_ClockConfig+0x146>
    }

    /* Enable the RC64MPLL*/
    __HAL_RCC_RC64MPLL_ENABLE();
100428dc:	f7ff ff82 	bl	100427e4 <LL_RCC_RC64MPLL_Enable>

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
100428e0:	f7fe fdf0 	bl	100414c4 <HAL_GetTick>
100428e4:	0003      	movs	r3, r0
100428e6:	60fb      	str	r3, [r7, #12]

    /* Wait till RC64MPLL is ready */
    while (LL_RCC_RC64MPLL_IsReady() == 0)
100428e8:	e008      	b.n	100428fc <HAL_RCC_ClockConfig+0x8c>
    {
      if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
100428ea:	f7fe fdeb 	bl	100414c4 <HAL_GetTick>
100428ee:	0002      	movs	r2, r0
100428f0:	68fb      	ldr	r3, [r7, #12]
100428f2:	1ad3      	subs	r3, r2, r3
100428f4:	2b02      	cmp	r3, #2
100428f6:	d901      	bls.n	100428fc <HAL_RCC_ClockConfig+0x8c>
      {
        return HAL_TIMEOUT;
100428f8:	2303      	movs	r3, #3
100428fa:	e05c      	b.n	100429b6 <HAL_RCC_ClockConfig+0x146>
    while (LL_RCC_RC64MPLL_IsReady() == 0)
100428fc:	f7ff ff90 	bl	10042820 <LL_RCC_RC64MPLL_IsReady>
10042900:	1e03      	subs	r3, r0, #0
10042902:	d0f2      	beq.n	100428ea <HAL_RCC_ClockConfig+0x7a>
      }
    }

    /* Configure the RC64MPLL multiplication factor */
    __HAL_RCC_RC64MPLL_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
10042904:	687b      	ldr	r3, [r7, #4]
10042906:	685b      	ldr	r3, [r3, #4]
10042908:	0018      	movs	r0, r3
1004290a:	f7ff ff9d 	bl	10042848 <LL_RCC_SetRC64MPLLPrescaler>
  }

  /* DIRECT_HSE is selected as System Clock Source */
  if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_DIRECT_HSE)
1004290e:	687b      	ldr	r3, [r7, #4]
10042910:	681b      	ldr	r3, [r3, #0]
10042912:	2b01      	cmp	r3, #1
10042914:	d117      	bne.n	10042946 <HAL_RCC_ClockConfig+0xd6>
  {
    /* Enable the DIRECT_HSE configuration */
    LL_RCC_DIRECT_HSE_Enable();
10042916:	f7ff ff3f 	bl	10042798 <LL_RCC_DIRECT_HSE_Enable>

    /* Check the HSI ready flag */
    if (LL_RCC_HSI_IsReady() != 0U)
1004291a:	f7ff ff29 	bl	10042770 <LL_RCC_HSI_IsReady>
1004291e:	1e03      	subs	r3, r0, #0
10042920:	d001      	beq.n	10042926 <HAL_RCC_ClockConfig+0xb6>
    {
      return HAL_ERROR;
10042922:	2301      	movs	r3, #1
10042924:	e047      	b.n	100429b6 <HAL_RCC_ClockConfig+0x146>
    }

    /* Check the HSE ready flag */
    if (LL_RCC_HSE_IsReady() == 0U)
10042926:	f7ff fefb 	bl	10042720 <LL_RCC_HSE_IsReady>
1004292a:	1e03      	subs	r3, r0, #0
1004292c:	d101      	bne.n	10042932 <HAL_RCC_ClockConfig+0xc2>
    {
      return HAL_ERROR;
1004292e:	2301      	movs	r3, #1
10042930:	e041      	b.n	100429b6 <HAL_RCC_ClockConfig+0x146>
    }

    /* Configure the DIRECT_HSE multiplication factor */
    __HAL_RCC_DIRECT_HSE_PRESC_CONFIG(RCC_ClkInitStruct->SYSCLKDivider);
10042932:	4b24      	ldr	r3, [pc, #144]	@ (100429c4 <HAL_RCC_ClockConfig+0x154>)
10042934:	689b      	ldr	r3, [r3, #8]
10042936:	22e0      	movs	r2, #224	@ 0xe0
10042938:	4393      	bics	r3, r2
1004293a:	0019      	movs	r1, r3
1004293c:	687b      	ldr	r3, [r7, #4]
1004293e:	685a      	ldr	r2, [r3, #4]
10042940:	4b20      	ldr	r3, [pc, #128]	@ (100429c4 <HAL_RCC_ClockConfig+0x154>)
10042942:	430a      	orrs	r2, r1
10042944:	609a      	str	r2, [r3, #8]
  /*----------------------- FLASH Latency Configuration ------------------------*/
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the FLASH clock */

  /* Setup flash wait states because according the system clock frequency */
  if (FLatency != __HAL_FLASH_GET_WAIT_STATES())
10042946:	4b1e      	ldr	r3, [pc, #120]	@ (100429c0 <HAL_RCC_ClockConfig+0x150>)
10042948:	685b      	ldr	r3, [r3, #4]
1004294a:	2230      	movs	r2, #48	@ 0x30
1004294c:	4013      	ands	r3, r2
1004294e:	683a      	ldr	r2, [r7, #0]
10042950:	429a      	cmp	r2, r3
10042952:	d01d      	beq.n	10042990 <HAL_RCC_ClockConfig+0x120>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_CONFIG register */
    __HAL_FLASH_SET_WAIT_STATES(FLatency);
10042954:	4b1a      	ldr	r3, [pc, #104]	@ (100429c0 <HAL_RCC_ClockConfig+0x150>)
10042956:	685b      	ldr	r3, [r3, #4]
10042958:	2230      	movs	r2, #48	@ 0x30
1004295a:	4393      	bics	r3, r2
1004295c:	0019      	movs	r1, r3
1004295e:	4b18      	ldr	r3, [pc, #96]	@ (100429c0 <HAL_RCC_ClockConfig+0x150>)
10042960:	683a      	ldr	r2, [r7, #0]
10042962:	430a      	orrs	r2, r1
10042964:	605a      	str	r2, [r3, #4]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
10042966:	f7fe fdad 	bl	100414c4 <HAL_GetTick>
1004296a:	0003      	movs	r3, r0
1004296c:	60fb      	str	r3, [r7, #12]

    /* Check that the new number of wait states is taken into account to access the Flash
       memory by reading the FLASH_CONFIG register */
    while (__HAL_FLASH_GET_WAIT_STATES() != FLatency)
1004296e:	e008      	b.n	10042982 <HAL_RCC_ClockConfig+0x112>
    {
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
10042970:	f7fe fda8 	bl	100414c4 <HAL_GetTick>
10042974:	0002      	movs	r2, r0
10042976:	68fb      	ldr	r3, [r7, #12]
10042978:	1ad3      	subs	r3, r2, r3
1004297a:	2b02      	cmp	r3, #2
1004297c:	d901      	bls.n	10042982 <HAL_RCC_ClockConfig+0x112>
      {
        return HAL_TIMEOUT;
1004297e:	2303      	movs	r3, #3
10042980:	e019      	b.n	100429b6 <HAL_RCC_ClockConfig+0x146>
    while (__HAL_FLASH_GET_WAIT_STATES() != FLatency)
10042982:	4b0f      	ldr	r3, [pc, #60]	@ (100429c0 <HAL_RCC_ClockConfig+0x150>)
10042984:	685b      	ldr	r3, [r3, #4]
10042986:	2230      	movs	r2, #48	@ 0x30
10042988:	4013      	ands	r3, r2
1004298a:	683a      	ldr	r2, [r7, #0]
1004298c:	429a      	cmp	r2, r3
1004298e:	d1ef      	bne.n	10042970 <HAL_RCC_ClockConfig+0x100>
  }

  /*---------------------------------------------------------------------------*/

  /* Update the SystemCoreClock global variable */
  for (volatile int i = 0; i < 6; i++)
10042990:	2300      	movs	r3, #0
10042992:	60bb      	str	r3, [r7, #8]
10042994:	e003      	b.n	1004299e <HAL_RCC_ClockConfig+0x12e>
  {
    __asm("NOP");
10042996:	46c0      	nop			@ (mov r8, r8)
  for (volatile int i = 0; i < 6; i++)
10042998:	68bb      	ldr	r3, [r7, #8]
1004299a:	3301      	adds	r3, #1
1004299c:	60bb      	str	r3, [r7, #8]
1004299e:	68bb      	ldr	r3, [r7, #8]
100429a0:	2b05      	cmp	r3, #5
100429a2:	ddf8      	ble.n	10042996 <HAL_RCC_ClockConfig+0x126>
  }
  SystemCoreClockUpdate();
100429a4:	f7fe fcb2 	bl	1004130c <SystemCoreClockUpdate>

  /* Configure the source of time base considering new system clocks settings*/
  return HAL_InitTick(HAL_GetTickPrio());
100429a8:	f7fe fd96 	bl	100414d8 <HAL_GetTickPrio>
100429ac:	0003      	movs	r3, r0
100429ae:	0018      	movs	r0, r3
100429b0:	f7fe fd2e 	bl	10041410 <HAL_InitTick>
100429b4:	0003      	movs	r3, r0
}
100429b6:	0018      	movs	r0, r3
100429b8:	46bd      	mov	sp, r7
100429ba:	b004      	add	sp, #16
100429bc:	bd80      	pop	{r7, pc}
100429be:	46c0      	nop			@ (mov r8, r8)
100429c0:	40001000 	.word	0x40001000
100429c4:	48400000 	.word	0x48400000

100429c8 <HAL_RCC_GetSysClockFreq>:
  *         content of the SystemCoreClock CMSIS variable
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
100429c8:	b580      	push	{r7, lr}
100429ca:	af00      	add	r7, sp, #0
  return SystemCoreClock;
100429cc:	4b02      	ldr	r3, [pc, #8]	@ (100429d8 <HAL_RCC_GetSysClockFreq+0x10>)
100429ce:	681b      	ldr	r3, [r3, #0]
}
100429d0:	0018      	movs	r0, r3
100429d2:	46bd      	mov	sp, r7
100429d4:	bd80      	pop	{r7, pc}
100429d6:	46c0      	nop			@ (mov r8, r8)
100429d8:	2000011c 	.word	0x2000011c

100429dc <LL_RCC_LSCO_SetSource>:
{
100429dc:	b580      	push	{r7, lr}
100429de:	b082      	sub	sp, #8
100429e0:	af00      	add	r7, sp, #0
100429e2:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_CLKSLOWSEL, Source);
100429e4:	4b06      	ldr	r3, [pc, #24]	@ (10042a00 <LL_RCC_LSCO_SetSource+0x24>)
100429e6:	689b      	ldr	r3, [r3, #8]
100429e8:	4a06      	ldr	r2, [pc, #24]	@ (10042a04 <LL_RCC_LSCO_SetSource+0x28>)
100429ea:	4013      	ands	r3, r2
100429ec:	0019      	movs	r1, r3
100429ee:	4b04      	ldr	r3, [pc, #16]	@ (10042a00 <LL_RCC_LSCO_SetSource+0x24>)
100429f0:	687a      	ldr	r2, [r7, #4]
100429f2:	430a      	orrs	r2, r1
100429f4:	609a      	str	r2, [r3, #8]
}
100429f6:	46c0      	nop			@ (mov r8, r8)
100429f8:	46bd      	mov	sp, r7
100429fa:	b002      	add	sp, #8
100429fc:	bd80      	pop	{r7, pc}
100429fe:	46c0      	nop			@ (mov r8, r8)
10042a00:	48400000 	.word	0x48400000
10042a04:	fffe7fff 	.word	0xfffe7fff

10042a08 <LL_RCC_SetRFClock>:
{
10042a08:	b580      	push	{r7, lr}
10042a0a:	b082      	sub	sp, #8
10042a0c:	af00      	add	r7, sp, #0
10042a0e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->APB2ENR, RCC_APB2ENR_CLKBLEDIV, Source);
10042a10:	4b06      	ldr	r3, [pc, #24]	@ (10042a2c <LL_RCC_SetRFClock+0x24>)
10042a12:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
10042a14:	2204      	movs	r2, #4
10042a16:	4393      	bics	r3, r2
10042a18:	0019      	movs	r1, r3
10042a1a:	4b04      	ldr	r3, [pc, #16]	@ (10042a2c <LL_RCC_SetRFClock+0x24>)
10042a1c:	687a      	ldr	r2, [r7, #4]
10042a1e:	430a      	orrs	r2, r1
10042a20:	661a      	str	r2, [r3, #96]	@ 0x60
}
10042a22:	46c0      	nop			@ (mov r8, r8)
10042a24:	46bd      	mov	sp, r7
10042a26:	b002      	add	sp, #8
10042a28:	bd80      	pop	{r7, pc}
10042a2a:	46c0      	nop			@ (mov r8, r8)
10042a2c:	48400000 	.word	0x48400000

10042a30 <LL_RCC_SetSMPSPrescaler>:
{
10042a30:	b580      	push	{r7, lr}
10042a32:	b082      	sub	sp, #8
10042a34:	af00      	add	r7, sp, #0
10042a36:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SMPSDIV, Prescaler);
10042a38:	4b06      	ldr	r3, [pc, #24]	@ (10042a54 <LL_RCC_SetSMPSPrescaler+0x24>)
10042a3a:	689b      	ldr	r3, [r3, #8]
10042a3c:	4a06      	ldr	r2, [pc, #24]	@ (10042a58 <LL_RCC_SetSMPSPrescaler+0x28>)
10042a3e:	4013      	ands	r3, r2
10042a40:	0019      	movs	r1, r3
10042a42:	4b04      	ldr	r3, [pc, #16]	@ (10042a54 <LL_RCC_SetSMPSPrescaler+0x24>)
10042a44:	687a      	ldr	r2, [r7, #4]
10042a46:	430a      	orrs	r2, r1
10042a48:	609a      	str	r2, [r3, #8]
}
10042a4a:	46c0      	nop			@ (mov r8, r8)
10042a4c:	46bd      	mov	sp, r7
10042a4e:	b002      	add	sp, #8
10042a50:	bd80      	pop	{r7, pc}
10042a52:	46c0      	nop			@ (mov r8, r8)
10042a54:	48400000 	.word	0x48400000
10042a58:	ffffefff 	.word	0xffffefff

10042a5c <LL_RCC_SetLPUARTClockSource>:
{
10042a5c:	b580      	push	{r7, lr}
10042a5e:	b082      	sub	sp, #8
10042a60:	af00      	add	r7, sp, #0
10042a62:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_LPUCLKSEL, Source);
10042a64:	4b06      	ldr	r3, [pc, #24]	@ (10042a80 <LL_RCC_SetLPUARTClockSource+0x24>)
10042a66:	689b      	ldr	r3, [r3, #8]
10042a68:	4a06      	ldr	r2, [pc, #24]	@ (10042a84 <LL_RCC_SetLPUARTClockSource+0x28>)
10042a6a:	4013      	ands	r3, r2
10042a6c:	0019      	movs	r1, r3
10042a6e:	4b04      	ldr	r3, [pc, #16]	@ (10042a80 <LL_RCC_SetLPUARTClockSource+0x24>)
10042a70:	687a      	ldr	r2, [r7, #4]
10042a72:	430a      	orrs	r2, r1
10042a74:	609a      	str	r2, [r3, #8]
}
10042a76:	46c0      	nop			@ (mov r8, r8)
10042a78:	46bd      	mov	sp, r7
10042a7a:	b002      	add	sp, #8
10042a7c:	bd80      	pop	{r7, pc}
10042a7e:	46c0      	nop			@ (mov r8, r8)
10042a80:	48400000 	.word	0x48400000
10042a84:	ffffdfff 	.word	0xffffdfff

10042a88 <LL_RCC_SetSPI3I2SClockSource>:
{
10042a88:	b580      	push	{r7, lr}
10042a8a:	b082      	sub	sp, #8
10042a8c:	af00      	add	r7, sp, #0
10042a8e:	6078      	str	r0, [r7, #4]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SPI3I2SCLKSEL, Source);
10042a90:	4b06      	ldr	r3, [pc, #24]	@ (10042aac <LL_RCC_SetSPI3I2SClockSource+0x24>)
10042a92:	689b      	ldr	r3, [r3, #8]
10042a94:	4a06      	ldr	r2, [pc, #24]	@ (10042ab0 <LL_RCC_SetSPI3I2SClockSource+0x28>)
10042a96:	4013      	ands	r3, r2
10042a98:	0019      	movs	r1, r3
10042a9a:	4b04      	ldr	r3, [pc, #16]	@ (10042aac <LL_RCC_SetSPI3I2SClockSource+0x24>)
10042a9c:	687a      	ldr	r2, [r7, #4]
10042a9e:	430a      	orrs	r2, r1
10042aa0:	609a      	str	r2, [r3, #8]
}
10042aa2:	46c0      	nop			@ (mov r8, r8)
10042aa4:	46bd      	mov	sp, r7
10042aa6:	b002      	add	sp, #8
10042aa8:	bd80      	pop	{r7, pc}
10042aaa:	46c0      	nop			@ (mov r8, r8)
10042aac:	48400000 	.word	0x48400000
10042ab0:	ff3fffff 	.word	0xff3fffff

10042ab4 <HAL_RCCEx_PeriphCLKConfig>:
  *  @note   (*) Peripherals are not available on all devices
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
10042ab4:	b580      	push	{r7, lr}
10042ab6:	b082      	sub	sp, #8
10042ab8:	af00      	add	r7, sp, #0
10042aba:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RF_BLE clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RF) == RCC_PERIPHCLK_RF))
10042abc:	687b      	ldr	r3, [r7, #4]
10042abe:	681b      	ldr	r3, [r3, #0]
10042ac0:	2201      	movs	r2, #1
10042ac2:	4013      	ands	r3, r2
10042ac4:	d004      	beq.n	10042ad0 <HAL_RCCEx_PeriphCLKConfig+0x1c>
  {
    assert_param(IS_RCC_RF_BLE_CLOCK_SOURCE(PeriphClkInit->RFClockSelection));
    __HAL_RCC_RF_CLK_SET_CONFIG(PeriphClkInit->RFClockSelection);
10042ac6:	687b      	ldr	r3, [r7, #4]
10042ac8:	691b      	ldr	r3, [r3, #16]
10042aca:	0018      	movs	r0, r3
10042acc:	f7ff ff9c 	bl	10042a08 <LL_RCC_SetRFClock>
  }

  /*-------------------------- SMPS clock configuration -------------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SMPS) == RCC_PERIPHCLK_SMPS))
10042ad0:	687b      	ldr	r3, [r7, #4]
10042ad2:	681b      	ldr	r3, [r3, #0]
10042ad4:	2202      	movs	r2, #2
10042ad6:	4013      	ands	r3, r2
10042ad8:	d004      	beq.n	10042ae4 <HAL_RCCEx_PeriphCLKConfig+0x30>
  {
    assert_param(IS_RCC_SMPS_CLOCK_PRESC(PeriphClkInit->SmpsDivSelection));
    __HAL_RCC_SMPS_DIV_CONFIG(PeriphClkInit->SmpsDivSelection);
10042ada:	687b      	ldr	r3, [r7, #4]
10042adc:	695b      	ldr	r3, [r3, #20]
10042ade:	0018      	movs	r0, r3
10042ae0:	f7ff ffa6 	bl	10042a30 <LL_RCC_SetSMPSPrescaler>
    __HAL_RCC_SPI2I2S_CLK_CONFIG(PeriphClkInit->SPI2I2SClockSelection);
  }
#endif
#if defined(SPI3)
  /*-------------------------- SPI3_I2S clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI3_I2S) == RCC_PERIPHCLK_SPI3_I2S))
10042ae4:	687b      	ldr	r3, [r7, #4]
10042ae6:	681b      	ldr	r3, [r3, #0]
10042ae8:	2208      	movs	r2, #8
10042aea:	4013      	ands	r3, r2
10042aec:	d004      	beq.n	10042af8 <HAL_RCCEx_PeriphCLKConfig+0x44>
  {
    assert_param(IS_RCC_SPI3I2S_CLOCK_SOURCE(PeriphClkInit->SPI3I2SClockSelection));
    __HAL_RCC_SPI3I2S_CLK_CONFIG(PeriphClkInit->SPI3I2SClockSelection);
10042aee:	687b      	ldr	r3, [r7, #4]
10042af0:	685b      	ldr	r3, [r3, #4]
10042af2:	0018      	movs	r0, r3
10042af4:	f7ff ffc8 	bl	10042a88 <LL_RCC_SetSPI3I2SClockSource>
  }
#endif

#if defined(RCC_CFGR_LPUCLKSEL)
  /*-------------------------- LPUART1 clock source configuration ---------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1))
10042af8:	687b      	ldr	r3, [r7, #4]
10042afa:	681b      	ldr	r3, [r3, #0]
10042afc:	2210      	movs	r2, #16
10042afe:	4013      	ands	r3, r2
10042b00:	d004      	beq.n	10042b0c <HAL_RCCEx_PeriphCLKConfig+0x58>
  {
    assert_param(IS_RCC_LPUART1_CLOCK_SOURCE(PeriphClkInit->LPUART1ClockSelection));
    __HAL_RCC_LPUART1_CLK_CONFIG(PeriphClkInit->LPUART1ClockSelection);
10042b02:	687b      	ldr	r3, [r7, #4]
10042b04:	68db      	ldr	r3, [r3, #12]
10042b06:	0018      	movs	r0, r3
10042b08:	f7ff ffa8 	bl	10042a5c <LL_RCC_SetLPUARTClockSource>
  }
#endif /* RCC_CFGR_LPUCLKSEL */

  /*-------------------------- RTC WDG BLEWKUP clock source configuration ---------------------*/
  if ((((PeriphClkInit->RTCWDGBLEWKUPClockSelection) & RCC_PERIPHCLK_RTC_WDG_BLEWKUP) == RCC_PERIPHCLK_RTC_WDG_BLEWKUP))
10042b0c:	687b      	ldr	r3, [r7, #4]
10042b0e:	689b      	ldr	r3, [r3, #8]
10042b10:	2220      	movs	r2, #32
10042b12:	4013      	ands	r3, r2
10042b14:	d004      	beq.n	10042b20 <HAL_RCCEx_PeriphCLKConfig+0x6c>
  {
    assert_param(IS_RCC_RTC_WDG_BLEWKUP_CLOCK_SOURCE(PeriphClkInit->RTCWDGBLEWKUPClockSelection));
    __HAL_RCC_RTC_WDG_BLEWKUP_CLK_CONFIG(PeriphClkInit->RTCWDGBLEWKUPClockSelection);
10042b16:	687b      	ldr	r3, [r7, #4]
10042b18:	689b      	ldr	r3, [r3, #8]
10042b1a:	0018      	movs	r0, r3
10042b1c:	f7ff ff5e 	bl	100429dc <LL_RCC_LSCO_SetSource>
  }

  return HAL_OK;
10042b20:	2300      	movs	r3, #0
}
10042b22:	0018      	movs	r0, r3
10042b24:	46bd      	mov	sp, r7
10042b26:	b002      	add	sp, #8
10042b28:	bd80      	pop	{r7, pc}

10042b2a <memset>:
10042b2a:	0003      	movs	r3, r0
10042b2c:	1882      	adds	r2, r0, r2
10042b2e:	4293      	cmp	r3, r2
10042b30:	d100      	bne.n	10042b34 <memset+0xa>
10042b32:	4770      	bx	lr
10042b34:	7019      	strb	r1, [r3, #0]
10042b36:	3301      	adds	r3, #1
10042b38:	e7f9      	b.n	10042b2e <memset+0x4>
	...

Disassembly of section .init:

10042b3c <_init>:
10042b3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10042b3e:	46c0      	nop			@ (mov r8, r8)

Disassembly of section .fini:

10042b40 <_fini>:
10042b40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10042b42:	46c0      	nop			@ (mov r8, r8)
